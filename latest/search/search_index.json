{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"TM1py Documentation","text":"<p>Welcome to the TM1py documentation \ud83d\ude80</p>"},{"location":"#why-tm1py","title":"Why TM1py?","text":"<p>TM1py offers handy features to interact with TM1 from Python, such as</p> <ul> <li>Functions to read data from cubes through cube views or MDX queries (e.g. <code>tm1.cells.execute_mdx</code>)</li> <li>Functions to write data to cubes (e.g. <code>tm1.cells.write</code>)</li> <li>Functions to update dimensions and hierarchies (e.g. <code>tm1.hierarchies.get</code>)</li> <li>Functions to update metadata, clear or write to cubes directly from pandas dataframes  (e.g. <code>tm1.elements.get_elements_dataframe</code>)</li> <li>Async functions to easily parallelize your read or write operations (e.g. <code>tm1.cells.write_async</code>)</li> <li>Functions to execute TI process or loose statements of TI (e.g. <code>tm1.processes.execute_with_return</code>)</li> <li>CRUD features for all TM1 objects (cubes, dimensions, subsets, etc.)</li> </ul>"},{"location":"#explore-the-tm1py-documentation","title":"Explore the TM1py Documentation","text":"<ul> <li>Getting Started</li> <li>How to Contribute</li> <li>Links</li> <li>API Reference</li> </ul>"},{"location":"getting-started/","title":"Getting Started with TM1py","text":"<p>TM1py is a Python library for interacting with IBM Planning Analytics / TM1 via the REST API.</p>"},{"location":"getting-started/#requirements","title":"Requirements","text":"<ul> <li>Python (3.7 or higher)</li> <li>TM1/Planning Analytics (v11 or higher)</li> </ul>"},{"location":"getting-started/#optional-python-packages","title":"Optional Python Packages","text":"<p>To fully unlock TM1py's potential, these two packages are optional.</p> <ul> <li>pandas</li> <li>networkx</li> </ul>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>TM1py only</p> <pre><code>pip install TM1py\n</code></pre> <p>Or TM1py with pandas dataframe support</p> <pre><code>pip install \"tm1py[pandas]\"\n</code></pre>"},{"location":"getting-started/#connect-and-print-version","title":"Connect and print version","text":""},{"location":"getting-started/#tm1-11-on-premise","title":"TM1 11 on-premise","text":"<pre><code>from TM1py.Services import TM1Service\n\nwith TM1Service(address='localhost', port=8001, user='admin', password='apple', ssl=True) as tm1:\n    print(tm1.server.get_product_version())\n</code></pre>"},{"location":"getting-started/#tm1-11-on-ibm-cloud","title":"TM1 11 on IBM cloud","text":"<pre><code>with TM1Service(\n        base_url='https://mycompany.planning-analytics.ibmcloud.com/tm1/api/tm1/',\n        user=\"non_interactive_user\",\n        namespace=\"LDAP\",\n        password=\"U3lSn5QLwoQZY2\",\n        ssl=True,\n        verify=True,\n        async_requests_mode=True) as tm1:\n    print(tm1.server.get_product_version())\n</code></pre>"},{"location":"getting-started/#tm1-12-paaas","title":"TM1 12 PAaaS","text":"<pre><code>from TM1py import TM1Service\n\nparams = {\n    \"base_url\": \"https://us-east-1.planninganalytics.saas.ibm.com/api/&lt;TenantId&gt;/v0/tm1/&lt;DatabaseName&gt;/\",\n    \"user\": \"apikey\",\n    \"password\": \"&lt;TheActualApiKey&gt;\",\n    \"async_requests_mode\": True,\n    \"ssl\": True,\n    \"verify\": True\n}\n\nwith TM1Service(**params) as tm1:\n    print(tm1.server.get_product_version())\n</code></pre>"},{"location":"getting-started/#tm1-12-on-premise-cloud-pak-for-data","title":"TM1 12 on-premise &amp; Cloud Pak For Data","text":"<pre><code>with TM1Service(\n        address=\"tm1-ibm-operands-services.apps.cluster.your-cluster.company.com\",\n        instance=\"your instance name\",\n        database=\"your database name\",\n        application_client_id=\"client id\",\n        application_client_secret=\"client secret\",\n        user=\"admin\",\n        ssl=True) as tm1:\n\n    print(tm1.server.get_product_version())\n</code></pre>"},{"location":"getting-started/#tm1-12-on-premise-with-access-token","title":"TM1 12 on-premise with access token","text":"<pre><code>params = {\n    \"base_url\": \"https://pa12.dev.net/api/&lt;InstanceId&gt;/v0/tm1/&lt;DatabaseName&gt;\",\n    \"user\": \"8643fd6....8a6b\",\n    \"access_token\":\"&lt;TheActualAccessToken&gt;\",\n    \"async_requests_mode\": True,\n    \"ssl\": True,\n    \"verify\": True\n}\n\nwith TM1Service(**params) as tm1:\n    print(tm1.server.get_product_version())\n</code></pre>"},{"location":"how-to-contribute/","title":"How to Contribute","text":""},{"location":"how-to-contribute/#start-contributing","title":"Start Contributing","text":"<p>TM1py is an open-source project. It thrives on contributions from the TM1 community. If you find a bug or feel like you can contribute a missing feature, please follow these steps:</p> <ol> <li>Fork the Repository: Start by forking the TM1py GitHub repository.</li> <li>Make Your Changes: Update the code to fix the bug or add your feature.</li> <li>Create a Pull Request: Once your changes are ready, create a pull request so we can review and merge them.</li> </ol>"},{"location":"how-to-contribute/#code-style-and-linting","title":"Code Style and Linting","text":"<p>To ensure consistency across the codebase, we use the following tools:</p> <ul> <li>Black: An auto-formatter for Python code. Please format your code using Black before submitting a pull request.</li> <li>Ruff: A fast Python linter. Make sure your code passes all linting checks.</li> </ul>"},{"location":"how-to-contribute/#editor-integration","title":"Editor Integration","text":"<p>Both Black and Ruff have excellent integrations with popular editors like VS Code and PyCharm. Setting up these tools in your editor ensures that your code is automatically formatted and linted as you work.</p> <p>Thank you for contributing to TM1py and helping to make it better!</p>"},{"location":"links/","title":"Links","text":"<p>Here is a collection of useful links for TM1py:</p>"},{"location":"links/#tm1py-resources","title":"TM1py Resources","text":"<ul> <li>TM1py GitHub Repository: The official repository for TM1py.</li> <li>TM1py Pypi Package: The official TM1py package on PyPi</li> <li>TM1py Github Issues: Found a bug or have a feature request? Open a GitHub issue.</li> <li>TM1py Support by Cubewise: Commercial support is available from Cubewise, whose team contributes to the project. The project itself remains community-maintained.</li> </ul>"},{"location":"links/#extensions-and-tools","title":"Extensions and Tools","text":"<ul> <li>OptimusPy - Find the ideal dimension order for your cubes: Optimization tool for TM1.</li> <li>tm1cli - A command line interface for TM1: Command-line tool for TM1.</li> <li>RushTI - Run TI processes in parallel: Uses TM1py to execute TI processes in parallel using only one connection</li> <li>TM1 Data Integration and Automation Toolkit: Toolkit for data integration and automation in TM1.</li> </ul>"},{"location":"links/#tutorials-and-guides","title":"Tutorials and Guides","text":"<ul> <li>TM1py Examples: Examples and use cases for TM1py.</li> <li>Getting Started with TM1py: A practical introduction to TM1py with examples.</li> </ul>"},{"location":"links/#miscellaneous","title":"Miscellaneous","text":"<ul> <li>Interview with Marius Wirtz, Creator of TM1py: Watch an insightful interview with the creator of TM1py, Marius Wirtz.</li> </ul>"},{"location":"reference/summary/","title":"API Reference","text":"<ul> <li>Services<ul> <li>AnnotationService</li> <li>ApplicationService</li> <li>AuditLogService</li> <li>CellService</li> <li>ChoreService</li> <li>ConfigurationService</li> <li>CubeService</li> <li>DimensionService</li> <li>ElementService</li> <li>FileService</li> <li>GitService</li> <li>HierarchyService</li> <li>JobService</li> <li>LoggerService</li> <li>ManageService</li> <li>MessageLogService</li> <li>MonitoringService</li> <li>ObjectService</li> <li>PowerBiService</li> <li>ProcessService</li> <li>RestService</li> <li>SandboxService</li> <li>SecurityService</li> <li>ServerService</li> <li>SessionService</li> <li>SubsetService</li> <li>TM1Service</li> <li>ThreadService</li> <li>TransactionLogService</li> <li>UserService</li> <li>ViewService</li> </ul> </li> <li>Objects<ul> <li>Annotation</li> <li>Application</li> <li>Axis</li> <li>Chore</li> <li>ChoreFrequency</li> <li>ChoreStartTime</li> <li>ChoreTask</li> <li>Cube</li> <li>Dimension</li> <li>Element</li> <li>ElementAttribute</li> <li>Git</li> <li>GitCommit</li> <li>GitPlan</li> <li>GitProject</li> <li>GitRemote</li> <li>Hierarchy</li> <li>MDXView</li> <li>NativeView</li> <li>Process</li> <li>ProcessDebugBreakpoint</li> <li>Rules</li> <li>Sandbox</li> <li>Server</li> <li>Subset</li> <li>TM1Object</li> <li>User</li> <li>View</li> </ul> </li> <li>Utils<ul> <li>MDXUtils</li> <li>Utils</li> </ul> </li> <li>Exceptions<ul> <li>Exceptions</li> </ul> </li> </ul>"},{"location":"reference/exceptions/exceptions/","title":"Exceptions","text":""},{"location":"reference/exceptions/exceptions/#TM1py.Exceptions.Exceptions.TM1pyException","title":"<code>TM1pyException(message)</code>","text":"<p>               Bases: <code>Exception</code></p> <p>The default exception for TM1py.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <p>Exception message</p> required Source code in <code>TM1py/Exceptions/Exceptions.py</code> <pre><code>def __init__(self, message):\n    \"\"\"\n    :param message: Exception message\n    \"\"\"\n    self.message = message\n</code></pre>"},{"location":"reference/exceptions/exceptions/#TM1py.Exceptions.Exceptions.TM1pyException.message","title":"<code>message = message</code>  <code>instance-attribute</code>","text":""},{"location":"reference/exceptions/exceptions/#TM1py.Exceptions.Exceptions.TM1pyException.__str__","title":"<code>__str__()</code>","text":"Source code in <code>TM1py/Exceptions/Exceptions.py</code> <pre><code>def __str__(self):\n    return self.message\n</code></pre>"},{"location":"reference/exceptions/exceptions/#TM1py.Exceptions.Exceptions.TM1pyNotAdminException","title":"<code>TM1pyNotAdminException(function)</code>","text":"<p>               Bases: <code>TM1pyPermissionException</code></p> <p>Exception for missing admin permissions.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>str</code> <p>Name of the function</p> required Source code in <code>TM1py/Exceptions/Exceptions.py</code> <pre><code>def __init__(self, function: str):\n    \"\"\"\n    :param function: Name of the function\n    \"\"\"\n    super().__init__(function, \"admin\")\n</code></pre>"},{"location":"reference/exceptions/exceptions/#TM1py.Exceptions.Exceptions.TM1pyNotDataAdminException","title":"<code>TM1pyNotDataAdminException(function)</code>","text":"<p>               Bases: <code>TM1pyPermissionException</code></p> <p>Exception for missing DataAdmin permissions.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>str</code> <p>Name of the function</p> required Source code in <code>TM1py/Exceptions/Exceptions.py</code> <pre><code>def __init__(self, function: str):\n    \"\"\"\n    :param function: Name of the function\n    \"\"\"\n    super().__init__(function, \"DataAdmin\")\n</code></pre>"},{"location":"reference/exceptions/exceptions/#TM1py.Exceptions.Exceptions.TM1pyNotOpsAdminException","title":"<code>TM1pyNotOpsAdminException(function)</code>","text":"<p>               Bases: <code>TM1pyPermissionException</code></p> <p>Exception for missing OperationsAdmin permissions.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>str</code> <p>Name of the function</p> required Source code in <code>TM1py/Exceptions/Exceptions.py</code> <pre><code>def __init__(self, function: str):\n    \"\"\"\n    :param function: Name of the function\n    \"\"\"\n    super().__init__(function, \"OperationsAdmin\")\n</code></pre>"},{"location":"reference/exceptions/exceptions/#TM1py.Exceptions.Exceptions.TM1pyNotSecurityAdminException","title":"<code>TM1pyNotSecurityAdminException(function)</code>","text":"<p>               Bases: <code>TM1pyPermissionException</code></p> <p>Exception for missing SecurityAdmin permissions.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>str</code> <p>Name of the function</p> required Source code in <code>TM1py/Exceptions/Exceptions.py</code> <pre><code>def __init__(self, function: str):\n    \"\"\"\n    :param function: Name of the function\n    \"\"\"\n    super().__init__(function, \"SecurityAdmin\")\n</code></pre>"},{"location":"reference/exceptions/exceptions/#TM1py.Exceptions.Exceptions.TM1pyPermissionException","title":"<code>TM1pyPermissionException(function, required_permission)</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception for missing permissions.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>str</code> <p>Name of the function</p> required <code>required_permission</code> <code>str</code> <p>Name of the required permission (e.g., 'admin', 'DataAdmin', 'SecurityAdmin', 'OperationsAdmin')</p> required Source code in <code>TM1py/Exceptions/Exceptions.py</code> <pre><code>def __init__(self, function: str, required_permission: str):\n    \"\"\"\n    :param function: Name of the function\n    :param required_permission: Name of the required permission (e.g., 'admin', 'DataAdmin', 'SecurityAdmin', 'OperationsAdmin')\n    \"\"\"\n    self.function = function\n    self.required_permission = required_permission\n</code></pre>"},{"location":"reference/exceptions/exceptions/#TM1py.Exceptions.Exceptions.TM1pyPermissionException.function","title":"<code>function = function</code>  <code>instance-attribute</code>","text":""},{"location":"reference/exceptions/exceptions/#TM1py.Exceptions.Exceptions.TM1pyPermissionException.required_permission","title":"<code>required_permission = required_permission</code>  <code>instance-attribute</code>","text":""},{"location":"reference/exceptions/exceptions/#TM1py.Exceptions.Exceptions.TM1pyPermissionException.__str__","title":"<code>__str__()</code>","text":"Source code in <code>TM1py/Exceptions/Exceptions.py</code> <pre><code>def __str__(self):\n    return f\"Function '{self.function}' requires {self.required_permission} permissions\"\n</code></pre>"},{"location":"reference/exceptions/exceptions/#TM1py.Exceptions.Exceptions.TM1pyRestException","title":"<code>TM1pyRestException(response, status_code, reason, headers)</code>","text":"<p>               Bases: <code>TM1pyException</code></p> <p>Exception for failing REST operations.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>str</code> <p>Response text</p> required <code>status_code</code> <code>int</code> <p>HTTP status code</p> required <code>reason</code> <code>str</code> <p>Reason phrase</p> required <code>headers</code> <code>Mapping</code> <p>HTTP headers</p> required Source code in <code>TM1py/Exceptions/Exceptions.py</code> <pre><code>def __init__(self, response: str, status_code: int, reason: str, headers: Mapping):\n    \"\"\"\n    :param response: Response text\n    :param status_code: HTTP status code\n    :param reason: Reason phrase\n    :param headers: HTTP headers\n    \"\"\"\n    super(TM1pyRestException, self).__init__(response)\n    self._status_code = status_code\n    self._reason = reason\n    self._headers = headers\n</code></pre>"},{"location":"reference/exceptions/exceptions/#TM1py.Exceptions.Exceptions.TM1pyRestException.headers","title":"<code>headers</code>  <code>property</code>","text":"<p>HTTP headers.</p>"},{"location":"reference/exceptions/exceptions/#TM1py.Exceptions.Exceptions.TM1pyRestException.reason","title":"<code>reason</code>  <code>property</code>","text":"<p>Reason phrase.</p>"},{"location":"reference/exceptions/exceptions/#TM1py.Exceptions.Exceptions.TM1pyRestException.response","title":"<code>response</code>  <code>property</code>","text":"<p>Response text.</p>"},{"location":"reference/exceptions/exceptions/#TM1py.Exceptions.Exceptions.TM1pyRestException.status_code","title":"<code>status_code</code>  <code>property</code>","text":"<p>HTTP status code.</p>"},{"location":"reference/exceptions/exceptions/#TM1py.Exceptions.Exceptions.TM1pyRestException.__str__","title":"<code>__str__()</code>","text":"Source code in <code>TM1py/Exceptions/Exceptions.py</code> <pre><code>def __str__(self):\n    return \"Text: '{}' - Status Code: {} - Reason: '{}' - Headers: {}\".format(\n        self.message, self._status_code, self._reason, self._headers\n    )\n</code></pre>"},{"location":"reference/exceptions/exceptions/#TM1py.Exceptions.Exceptions.TM1pyTimeout","title":"<code>TM1pyTimeout(method, url, timeout)</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception for timeout during a REST request.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>HTTP method used</p> required <code>url</code> <code>str</code> <p>URL of the request</p> required <code>timeout</code> <code>float</code> <p>Timeout in seconds</p> required Source code in <code>TM1py/Exceptions/Exceptions.py</code> <pre><code>def __init__(self, method: str, url: str, timeout: float):\n    \"\"\"\n    :param method: HTTP method used\n    :param url: URL of the request\n    :param timeout: Timeout in seconds\n    \"\"\"\n    self.method = method\n    self.url = url\n    self.timeout = timeout\n</code></pre>"},{"location":"reference/exceptions/exceptions/#TM1py.Exceptions.Exceptions.TM1pyTimeout.method","title":"<code>method = method</code>  <code>instance-attribute</code>","text":""},{"location":"reference/exceptions/exceptions/#TM1py.Exceptions.Exceptions.TM1pyTimeout.timeout","title":"<code>timeout = timeout</code>  <code>instance-attribute</code>","text":""},{"location":"reference/exceptions/exceptions/#TM1py.Exceptions.Exceptions.TM1pyTimeout.url","title":"<code>url = url</code>  <code>instance-attribute</code>","text":""},{"location":"reference/exceptions/exceptions/#TM1py.Exceptions.Exceptions.TM1pyTimeout.__str__","title":"<code>__str__()</code>","text":"Source code in <code>TM1py/Exceptions/Exceptions.py</code> <pre><code>def __str__(self):\n    return f\"Timeout after {self.timeout} seconds for '{self.method}' request with url :'{self.url}'\"\n</code></pre>"},{"location":"reference/exceptions/exceptions/#TM1py.Exceptions.Exceptions.TM1pyVersionDeprecationException","title":"<code>TM1pyVersionDeprecationException(function, deprecated_in_version)</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception for usage of a deprecated feature.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>str</code> <p>Name of the function</p> required <code>deprecated_in_version</code> <p>Version in which the function was deprecated</p> required Source code in <code>TM1py/Exceptions/Exceptions.py</code> <pre><code>def __init__(self, function: str, deprecated_in_version):\n    \"\"\"\n    :param function: Name of the function\n    :param deprecated_in_version: Version in which the function was deprecated\n    \"\"\"\n    self.function = function\n    self.deprecated_in_version = deprecated_in_version\n</code></pre>"},{"location":"reference/exceptions/exceptions/#TM1py.Exceptions.Exceptions.TM1pyVersionDeprecationException.deprecated_in_version","title":"<code>deprecated_in_version = deprecated_in_version</code>  <code>instance-attribute</code>","text":""},{"location":"reference/exceptions/exceptions/#TM1py.Exceptions.Exceptions.TM1pyVersionDeprecationException.function","title":"<code>function = function</code>  <code>instance-attribute</code>","text":""},{"location":"reference/exceptions/exceptions/#TM1py.Exceptions.Exceptions.TM1pyVersionDeprecationException.__str__","title":"<code>__str__()</code>","text":"Source code in <code>TM1py/Exceptions/Exceptions.py</code> <pre><code>def __str__(self):\n    return f\"Function '{self.function}' has been deprecated in TM1 server version &gt;= '{self.deprecated_in_version}'\"\n</code></pre>"},{"location":"reference/exceptions/exceptions/#TM1py.Exceptions.Exceptions.TM1pyVersionException","title":"<code>TM1pyVersionException(function, required_version, feature=None)</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception for usage of a feature requiring a higher TM1 server version.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>str</code> <p>Name of the function</p> required <code>required_version</code> <p>Required TM1 server version</p> required <code>feature</code> <code>str</code> <p>Optional feature name</p> <code>None</code> Source code in <code>TM1py/Exceptions/Exceptions.py</code> <pre><code>def __init__(self, function: str, required_version, feature: str = None):\n    \"\"\"\n    :param function: Name of the function\n    :param required_version: Required TM1 server version\n    :param feature: Optional feature name\n    \"\"\"\n    self.function = function\n    self.required_version = required_version\n    self.feature = feature\n</code></pre>"},{"location":"reference/exceptions/exceptions/#TM1py.Exceptions.Exceptions.TM1pyVersionException.feature","title":"<code>feature = feature</code>  <code>instance-attribute</code>","text":""},{"location":"reference/exceptions/exceptions/#TM1py.Exceptions.Exceptions.TM1pyVersionException.function","title":"<code>function = function</code>  <code>instance-attribute</code>","text":""},{"location":"reference/exceptions/exceptions/#TM1py.Exceptions.Exceptions.TM1pyVersionException.required_version","title":"<code>required_version = required_version</code>  <code>instance-attribute</code>","text":""},{"location":"reference/exceptions/exceptions/#TM1py.Exceptions.Exceptions.TM1pyVersionException.__str__","title":"<code>__str__()</code>","text":"Source code in <code>TM1py/Exceptions/Exceptions.py</code> <pre><code>def __str__(self):\n    require_string = f\"requires TM1 server version &gt;= '{self.required_version}'\"\n    if self.feature:\n        return f\"'{self.feature}' feature of function '{self.function}' {require_string}\"\n    else:\n        return f\"Function '{self.function}' {require_string}\"\n</code></pre>"},{"location":"reference/exceptions/exceptions/#TM1py.Exceptions.Exceptions.TM1pyWriteFailureException","title":"<code>TM1pyWriteFailureException(statuses, error_log_files)</code>","text":"<p>               Bases: <code>TM1pyException</code></p> <p>Exception for complete failure of write operations.</p> <p>Parameters:</p> Name Type Description Default <code>statuses</code> <code>List[str]</code> <p>List of failed statuses</p> required <code>error_log_files</code> <code>List[str]</code> <p>List of error log file paths</p> required Source code in <code>TM1py/Exceptions/Exceptions.py</code> <pre><code>def __init__(self, statuses: List[str], error_log_files: List[str]):\n    \"\"\"\n    :param statuses: List of failed statuses\n    :param error_log_files: List of error log file paths\n    \"\"\"\n    self.statuses = statuses\n    self.error_log_files = error_log_files\n\n    message = f\"All {len(self.statuses)} write operations failed. Details: {self.error_log_files}\"\n    super(TM1pyWriteFailureException, self).__init__(message)\n</code></pre>"},{"location":"reference/exceptions/exceptions/#TM1py.Exceptions.Exceptions.TM1pyWriteFailureException.error_log_files","title":"<code>error_log_files = error_log_files</code>  <code>instance-attribute</code>","text":""},{"location":"reference/exceptions/exceptions/#TM1py.Exceptions.Exceptions.TM1pyWriteFailureException.statuses","title":"<code>statuses = statuses</code>  <code>instance-attribute</code>","text":""},{"location":"reference/exceptions/exceptions/#TM1py.Exceptions.Exceptions.TM1pyWritePartialFailureException","title":"<code>TM1pyWritePartialFailureException(statuses, error_log_files, attempts)</code>","text":"<p>               Bases: <code>TM1pyException</code></p> <p>Exception for partial failure of write operations.</p> <p>Parameters:</p> Name Type Description Default <code>statuses</code> <code>List[str]</code> <p>List of failed statuses</p> required <code>error_log_files</code> <code>List[str]</code> <p>List of error log file paths</p> required <code>attempts</code> <code>int</code> <p>Total number of attempts</p> required Source code in <code>TM1py/Exceptions/Exceptions.py</code> <pre><code>def __init__(self, statuses: List[str], error_log_files: List[str], attempts: int):\n    \"\"\"\n    :param statuses: List of failed statuses\n    :param error_log_files: List of error log file paths\n    :param attempts: Total number of attempts\n    \"\"\"\n    self.statuses = statuses\n    self.error_log_files = error_log_files\n    self.attempts = attempts\n\n    message = (\n        f\"{len(self.statuses)} out of {self.attempts} write operations failed partially. \"\n        f\"Details: {self.error_log_files}\"\n    )\n    super(TM1pyWritePartialFailureException, self).__init__(message)\n</code></pre>"},{"location":"reference/exceptions/exceptions/#TM1py.Exceptions.Exceptions.TM1pyWritePartialFailureException.attempts","title":"<code>attempts = attempts</code>  <code>instance-attribute</code>","text":""},{"location":"reference/exceptions/exceptions/#TM1py.Exceptions.Exceptions.TM1pyWritePartialFailureException.error_log_files","title":"<code>error_log_files = error_log_files</code>  <code>instance-attribute</code>","text":""},{"location":"reference/exceptions/exceptions/#TM1py.Exceptions.Exceptions.TM1pyWritePartialFailureException.statuses","title":"<code>statuses = statuses</code>  <code>instance-attribute</code>","text":""},{"location":"reference/objects/annotation/","title":"Annotation","text":""},{"location":"reference/objects/annotation/#TM1py.Objects.Annotation.Annotation","title":"<code>Annotation(comment_value, object_name, dimensional_context, comment_type='ANNOTATION', annotation_id=None, text='', creator=None, created=None, last_updated_by=None, last_updated=None)</code>","text":"<p>               Bases: <code>TM1Object</code></p> <p>Abtraction of TM1 Annotation</p> <p>:Notes:     - Class complete, functional and tested.     - doesn't cover Attachments though</p> <p>Initialize an Annotation object.</p> <p>Parameters:</p> Name Type Description Default <code>comment_value</code> <code>str</code> <p>The value of the annotation comment.</p> required <code>object_name</code> <code>str</code> <p>Name of the TM1 object the annotation is attached to.</p> required <code>dimensional_context</code> <code>Iterable[str]</code> <p>Iterable of dimension elements providing context.</p> required <code>comment_type</code> <code>str</code> <p>Type of the comment (default \"ANNOTATION\").</p> <code>'ANNOTATION'</code> <code>annotation_id</code> <code>str</code> <p>Unique ID of the annotation.</p> <code>None</code> <code>text</code> <code>str</code> <p>Text of the annotation.</p> <code>''</code> <code>creator</code> <code>str</code> <p>Creator of the annotation.</p> <code>None</code> <code>created</code> <code>str</code> <p>Creation timestamp.</p> <code>None</code> <code>last_updated_by</code> <code>str</code> <p>Last user who updated the annotation.</p> <code>None</code> <code>last_updated</code> <code>str</code> <p>Last update timestamp.</p> <code>None</code> Source code in <code>TM1py/Objects/Annotation.py</code> <pre><code>def __init__(\n    self,\n    comment_value: str,\n    object_name: str,\n    dimensional_context: Iterable[str],\n    comment_type: str = \"ANNOTATION\",\n    annotation_id: str = None,\n    text: str = \"\",\n    creator: str = None,\n    created: str = None,\n    last_updated_by: str = None,\n    last_updated: str = None,\n):\n    \"\"\"\n    Initialize an Annotation object.\n\n    :param comment_value: The value of the annotation comment.\n    :param object_name: Name of the TM1 object the annotation is attached to.\n    :param dimensional_context: Iterable of dimension elements providing context.\n    :param comment_type: Type of the comment (default \"ANNOTATION\").\n    :param annotation_id: Unique ID of the annotation.\n    :param text: Text of the annotation.\n    :param creator: Creator of the annotation.\n    :param created: Creation timestamp.\n    :param last_updated_by: Last user who updated the annotation.\n    :param last_updated: Last update timestamp.\n    \"\"\"\n    self._id = annotation_id\n    self._text = text\n    self._creator = creator\n    self._created = created\n    self._last_updated_by = last_updated_by\n    self._last_updated = last_updated\n    self._dimensional_context = list(dimensional_context)\n    self._comment_type = comment_type\n    self._comment_value = comment_value\n    self._object_name = object_name\n</code></pre>"},{"location":"reference/objects/annotation/#TM1py.Objects.Annotation.Annotation.body","title":"<code>body</code>  <code>property</code>","text":"<p>Get the annotation body as a JSON string.</p> <p>Returns:</p> Type Description <code>str</code> <p>JSON string representation of the annotation.</p>"},{"location":"reference/objects/annotation/#TM1py.Objects.Annotation.Annotation.body_as_dict","title":"<code>body_as_dict</code>  <code>property</code>","text":"<p>Get the annotation body as a dictionary.</p> <p>Returns:</p> Type Description <code>Dict</code> <p>Dictionary representation of the annotation.</p>"},{"location":"reference/objects/annotation/#TM1py.Objects.Annotation.Annotation.comment_value","title":"<code>comment_value</code>  <code>property</code> <code>writable</code>","text":"<p>Get the comment value.</p> <p>Returns:</p> Type Description <code>str</code> <p>The comment value string.</p>"},{"location":"reference/objects/annotation/#TM1py.Objects.Annotation.Annotation.created","title":"<code>created</code>  <code>property</code>","text":"<p>Get the creation timestamp.</p> <p>Returns:</p> Type Description <code>str</code> <p>Creation timestamp as string.</p>"},{"location":"reference/objects/annotation/#TM1py.Objects.Annotation.Annotation.dimensional_context","title":"<code>dimensional_context</code>  <code>property</code>","text":"<p>Get the dimensional context.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of dimension elements providing context.</p>"},{"location":"reference/objects/annotation/#TM1py.Objects.Annotation.Annotation.id","title":"<code>id</code>  <code>property</code>","text":"<p>Get the annotation ID.</p> <p>Returns:</p> Type Description <code>str</code> <p>Annotation ID string.</p>"},{"location":"reference/objects/annotation/#TM1py.Objects.Annotation.Annotation.last_updated","title":"<code>last_updated</code>  <code>property</code>","text":"<p>Get the last updated timestamp.</p> <p>Returns:</p> Type Description <code>str</code> <p>Last update timestamp as string.</p>"},{"location":"reference/objects/annotation/#TM1py.Objects.Annotation.Annotation.last_updated_by","title":"<code>last_updated_by</code>  <code>property</code>","text":"<p>Get the last user who updated the annotation.</p> <p>Returns:</p> Type Description <code>str</code> <p>Username of last updater.</p>"},{"location":"reference/objects/annotation/#TM1py.Objects.Annotation.Annotation.object_name","title":"<code>object_name</code>  <code>property</code>","text":"<p>Get the object name.</p> <p>Returns:</p> Type Description <code>str</code> <p>Name of the TM1 object.</p>"},{"location":"reference/objects/annotation/#TM1py.Objects.Annotation.Annotation.text","title":"<code>text</code>  <code>property</code>","text":"<p>Get the annotation text.</p> <p>Returns:</p> Type Description <code>str</code> <p>The annotation text.</p>"},{"location":"reference/objects/annotation/#TM1py.Objects.Annotation.Annotation.construct_body_for_post","title":"<code>construct_body_for_post(cube_dimensions)</code>","text":"<p>Construct the body for POST requests to create an annotation.</p> <p>Parameters:</p> Name Type Description Default <code>cube_dimensions</code> <p>List of cube dimension names.</p> required <p>Returns:</p> Type Description <code>Dict</code> <p>Dictionary for POST request body.</p> Source code in <code>TM1py/Objects/Annotation.py</code> <pre><code>def construct_body_for_post(self, cube_dimensions) -&gt; Dict:\n    \"\"\"\n    Construct the body for POST requests to create an annotation.\n\n    :param cube_dimensions: List of cube dimension names.\n    :return: Dictionary for POST request body.\n    \"\"\"\n    body = collections.OrderedDict()\n    body[\"Text\"] = self.text\n    body[\"ApplicationContext\"] = [\n        {\"Facet@odata.bind\": \"ApplicationContextFacets('}Cubes')\", \"Value\": self.object_name}\n    ]\n    body[\"DimensionalContext@odata.bind\"] = []\n\n    for dimension, element in zip(cube_dimensions, self.dimensional_context):\n        coordinates = format_url(\"Dimensions('{}')/Hierarchies('{}')/Members('{}')\", dimension, dimension, element)\n        body[\"DimensionalContext@odata.bind\"].append(coordinates)\n\n    body[\"objectName\"] = self.object_name\n    body[\"commentValue\"] = self.comment_value\n    body[\"commentType\"] = \"ANNOTATION\"\n    body[\"commentLocation\"] = \",\".join(self.dimensional_context)\n\n    return body\n</code></pre>"},{"location":"reference/objects/annotation/#TM1py.Objects.Annotation.Annotation.from_json","title":"<code>from_json(annotation_as_json)</code>  <code>classmethod</code>","text":"<p>Alternative constructor</p> <p>Parameters:</p> Name Type Description Default <code>annotation_as_json</code> <code>str</code> <p>String, JSON</p> required <p>Returns:</p> Type Description <code>Annotation</code> <p>instance of Annotation</p> Source code in <code>TM1py/Objects/Annotation.py</code> <pre><code>@classmethod\ndef from_json(cls, annotation_as_json: str) -&gt; \"Annotation\":\n    \"\"\"Alternative constructor\n\n    :param annotation_as_json: String, JSON\n    :return: instance of Annotation\n    \"\"\"\n    annotation_as_dict = json.loads(annotation_as_json)\n    annotation_id = annotation_as_dict[\"ID\"]\n    text = annotation_as_dict[\"Text\"]\n    creator = annotation_as_dict[\"Creator\"]\n    created = annotation_as_dict[\"Created\"]\n    last_updated_by = annotation_as_dict[\"LastUpdatedBy\"]\n    last_updated = annotation_as_dict[\"LastUpdated\"]\n    dimensional_context = [item[\"Name\"] for item in annotation_as_dict[\"DimensionalContext\"]]\n    comment_type = annotation_as_dict[\"commentType\"]\n    comment_value = annotation_as_dict[\"commentValue\"]\n    object_name = annotation_as_dict[\"objectName\"]\n    return cls(\n        comment_value=comment_value,\n        object_name=object_name,\n        dimensional_context=dimensional_context,\n        comment_type=comment_type,\n        annotation_id=annotation_id,\n        text=text,\n        creator=creator,\n        created=created,\n        last_updated_by=last_updated_by,\n        last_updated=last_updated,\n    )\n</code></pre>"},{"location":"reference/objects/annotation/#TM1py.Objects.Annotation.Annotation.move","title":"<code>move(dimension_order, dimension, target_element, source_element=None)</code>","text":"<p>Move annotation on given dimension from source_element to target_element.</p> <p>Parameters:</p> Name Type Description Default <code>dimension_order</code> <code>Iterable[str]</code> <p>List, order of the dimensions in the cube.</p> required <code>dimension</code> <code>str</code> <p>Dimension name.</p> required <code>target_element</code> <code>str</code> <p>Target element name.</p> required <code>source_element</code> <code>str</code> <p>Source element name (optional).</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>TM1py/Objects/Annotation.py</code> <pre><code>def move(self, dimension_order: Iterable[str], dimension: str, target_element: str, source_element: str = None):\n    \"\"\"\n    Move annotation on given dimension from source_element to target_element.\n\n    :param dimension_order: List, order of the dimensions in the cube.\n    :param dimension: Dimension name.\n    :param target_element: Target element name.\n    :param source_element: Source element name (optional).\n    :return: None\n    \"\"\"\n    for i, dimension_name in enumerate(dimension_order):\n        if dimension_name.lower() == dimension.lower():\n            if not source_element or self._dimensional_context[i] == source_element:\n                self._dimensional_context[i] = target_element\n</code></pre>"},{"location":"reference/objects/application/","title":"Application","text":""},{"location":"reference/objects/application/#TM1py.Objects.Application.ApplicationType","title":"<code>ApplicationType = namedtuple('ApplicationType', ['value', 'suffix', 'odata_type'])</code>  <code>module-attribute</code>","text":""},{"location":"reference/objects/application/#TM1py.Objects.Application.Application","title":"<code>Application(path, name, application_type)</code>","text":"<p>               Bases: <code>TM1Object</code></p> Source code in <code>TM1py/Objects/Application.py</code> <pre><code>def __init__(self, path: str, name: str, application_type: Union[ApplicationTypes, str]):\n    self.path = path\n    # remove suffix from name\n    if application_type.suffix and name.endswith(application_type.suffix):\n        self.name = name[: -len(application_type.suffix)]\n    else:\n        self.name = name\n    # raise ValueError if not a valid type\n    self.application_type = ApplicationTypes(application_type)\n</code></pre>"},{"location":"reference/objects/application/#TM1py.Objects.Application.Application.application_id","title":"<code>application_id</code>  <code>property</code>","text":""},{"location":"reference/objects/application/#TM1py.Objects.Application.Application.application_type","title":"<code>application_type = ApplicationTypes(application_type)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/objects/application/#TM1py.Objects.Application.Application.body","title":"<code>body</code>  <code>property</code>","text":""},{"location":"reference/objects/application/#TM1py.Objects.Application.Application.body_as_dict","title":"<code>body_as_dict</code>  <code>property</code>","text":""},{"location":"reference/objects/application/#TM1py.Objects.Application.Application.name","title":"<code>name = name[:(-len(application_type.suffix))]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/objects/application/#TM1py.Objects.Application.Application.path","title":"<code>path = path</code>  <code>instance-attribute</code>","text":""},{"location":"reference/objects/application/#TM1py.Objects.Application.ApplicationTypes","title":"<code>ApplicationTypes</code>","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"reference/objects/application/#TM1py.Objects.Application.ApplicationTypes.CHORE","title":"<code>CHORE = ApplicationType(1, '.chore', 'tm1.ChoreReference')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/objects/application/#TM1py.Objects.Application.ApplicationTypes.CUBE","title":"<code>CUBE = ApplicationType(2, '.cube', 'tm1.CubeReference')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/objects/application/#TM1py.Objects.Application.ApplicationTypes.DIMENSION","title":"<code>DIMENSION = ApplicationType(3, '.dimension', 'tm1.DimensionReference')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/objects/application/#TM1py.Objects.Application.ApplicationTypes.DOCUMENT","title":"<code>DOCUMENT = ApplicationType(4, '.blob', '#ibm.tm1.api.v1.Document')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/objects/application/#TM1py.Objects.Application.ApplicationTypes.FOLDER","title":"<code>FOLDER = ApplicationType(5, '', '#ibm.tm1.api.v1.Folder')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/objects/application/#TM1py.Objects.Application.ApplicationTypes.LINK","title":"<code>LINK = ApplicationType(6, '.extr', '#ibm.tm1.api.v1.Link')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/objects/application/#TM1py.Objects.Application.ApplicationTypes.PROCESS","title":"<code>PROCESS = ApplicationType(7, '.process', 'tm1.ProcessReference')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/objects/application/#TM1py.Objects.Application.ApplicationTypes.SUBSET","title":"<code>SUBSET = ApplicationType(8, '.subset', 'tm1.SubsetReference')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/objects/application/#TM1py.Objects.Application.ApplicationTypes.VIEW","title":"<code>VIEW = ApplicationType(9, '.view', 'tm1.ViewReference')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/objects/application/#TM1py.Objects.Application.ApplicationTypes.odata_type","title":"<code>odata_type</code>  <code>property</code>","text":""},{"location":"reference/objects/application/#TM1py.Objects.Application.ApplicationTypes.suffix","title":"<code>suffix</code>  <code>property</code>","text":""},{"location":"reference/objects/application/#TM1py.Objects.Application.ChoreApplication","title":"<code>ChoreApplication(path, name, chore_name)</code>","text":"<p>               Bases: <code>Application</code></p> Source code in <code>TM1py/Objects/Application.py</code> <pre><code>def __init__(self, path: str, name: str, chore_name: str):\n    super().__init__(path, name, ApplicationTypes.CHORE)\n    self.chore_name = chore_name\n</code></pre>"},{"location":"reference/objects/application/#TM1py.Objects.Application.ChoreApplication.body","title":"<code>body</code>  <code>property</code>","text":""},{"location":"reference/objects/application/#TM1py.Objects.Application.ChoreApplication.chore_name","title":"<code>chore_name = chore_name</code>  <code>instance-attribute</code>","text":""},{"location":"reference/objects/application/#TM1py.Objects.Application.CubeApplication","title":"<code>CubeApplication(path, name, cube_name)</code>","text":"<p>               Bases: <code>Application</code></p> Source code in <code>TM1py/Objects/Application.py</code> <pre><code>def __init__(self, path: str, name: str, cube_name: str):\n    super().__init__(path, name, ApplicationTypes.CUBE)\n    self.cube_name = cube_name\n</code></pre>"},{"location":"reference/objects/application/#TM1py.Objects.Application.CubeApplication.body","title":"<code>body</code>  <code>property</code>","text":""},{"location":"reference/objects/application/#TM1py.Objects.Application.CubeApplication.cube_name","title":"<code>cube_name = cube_name</code>  <code>instance-attribute</code>","text":""},{"location":"reference/objects/application/#TM1py.Objects.Application.DimensionApplication","title":"<code>DimensionApplication(path, name, dimension_name)</code>","text":"<p>               Bases: <code>Application</code></p> Source code in <code>TM1py/Objects/Application.py</code> <pre><code>def __init__(self, path: str, name: str, dimension_name: str):\n    super().__init__(path, name, ApplicationTypes.DIMENSION)\n    self.dimension_name = dimension_name\n</code></pre>"},{"location":"reference/objects/application/#TM1py.Objects.Application.DimensionApplication.body","title":"<code>body</code>  <code>property</code>","text":""},{"location":"reference/objects/application/#TM1py.Objects.Application.DimensionApplication.dimension_name","title":"<code>dimension_name = dimension_name</code>  <code>instance-attribute</code>","text":""},{"location":"reference/objects/application/#TM1py.Objects.Application.DocumentApplication","title":"<code>DocumentApplication(path, name, content, file_id=None, file_name=None, last_updated=None)</code>","text":"<p>               Bases: <code>Application</code></p> Source code in <code>TM1py/Objects/Application.py</code> <pre><code>def __init__(\n    self, path: str, name: str, content: bytes, file_id: str = None, file_name: str = None, last_updated: str = None\n):\n    super().__init__(path, name, ApplicationTypes.DOCUMENT)\n    self.content = content\n    # below fields only populated for retrieved applications\n    self.file_id = file_id\n    self.file_name = file_name\n    self.last_updated = last_updated\n</code></pre>"},{"location":"reference/objects/application/#TM1py.Objects.Application.DocumentApplication.content","title":"<code>content = content</code>  <code>instance-attribute</code>","text":""},{"location":"reference/objects/application/#TM1py.Objects.Application.DocumentApplication.file_id","title":"<code>file_id = file_id</code>  <code>instance-attribute</code>","text":""},{"location":"reference/objects/application/#TM1py.Objects.Application.DocumentApplication.file_name","title":"<code>file_name = file_name</code>  <code>instance-attribute</code>","text":""},{"location":"reference/objects/application/#TM1py.Objects.Application.DocumentApplication.last_updated","title":"<code>last_updated = last_updated</code>  <code>instance-attribute</code>","text":""},{"location":"reference/objects/application/#TM1py.Objects.Application.DocumentApplication.to_file","title":"<code>to_file(path_to_file)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>path_to_file</code> <code>str</code> <p>path to newly to create file including the extension (e.g., xlsx, xlsm)</p> required <p>Returns:</p> Type Description Source code in <code>TM1py/Objects/Application.py</code> <pre><code>def to_file(self, path_to_file: str):\n    \"\"\"\n\n    :param path_to_file: path to newly to create file including the extension (e.g., xlsx, xlsm)\n    :return:\n    \"\"\"\n    with open(path_to_file, \"wb\") as file:\n        file.write(self.content)\n</code></pre>"},{"location":"reference/objects/application/#TM1py.Objects.Application.DocumentApplication.to_xlsx","title":"<code>to_xlsx(path_to_file)</code>","text":"Source code in <code>TM1py/Objects/Application.py</code> <pre><code>def to_xlsx(self, path_to_file: str):\n    warnings.warn(\"Function 'to_xlsx' is deprecated. Use 'to_file' instead\", DeprecationWarning, stacklevel=2)\n    return self.to_file(path_to_file=path_to_file)\n</code></pre>"},{"location":"reference/objects/application/#TM1py.Objects.Application.FolderApplication","title":"<code>FolderApplication(path, name)</code>","text":"<p>               Bases: <code>Application</code></p> Source code in <code>TM1py/Objects/Application.py</code> <pre><code>def __init__(self, path: str, name: str):\n    super().__init__(path, name, ApplicationTypes.FOLDER)\n</code></pre>"},{"location":"reference/objects/application/#TM1py.Objects.Application.LinkApplication","title":"<code>LinkApplication(path, name, url)</code>","text":"<p>               Bases: <code>Application</code></p> Source code in <code>TM1py/Objects/Application.py</code> <pre><code>def __init__(self, path: str, name: str, url: str):\n    super().__init__(path, name, ApplicationTypes.LINK)\n    self.url = url\n</code></pre>"},{"location":"reference/objects/application/#TM1py.Objects.Application.LinkApplication.body","title":"<code>body</code>  <code>property</code>","text":""},{"location":"reference/objects/application/#TM1py.Objects.Application.LinkApplication.url","title":"<code>url = url</code>  <code>instance-attribute</code>","text":""},{"location":"reference/objects/application/#TM1py.Objects.Application.ProcessApplication","title":"<code>ProcessApplication(path, name, process_name)</code>","text":"<p>               Bases: <code>Application</code></p> Source code in <code>TM1py/Objects/Application.py</code> <pre><code>def __init__(self, path: str, name: str, process_name: str):\n    super().__init__(path, name, ApplicationTypes.PROCESS)\n    self.process_name = process_name\n</code></pre>"},{"location":"reference/objects/application/#TM1py.Objects.Application.ProcessApplication.body","title":"<code>body</code>  <code>property</code>","text":""},{"location":"reference/objects/application/#TM1py.Objects.Application.ProcessApplication.process_name","title":"<code>process_name = process_name</code>  <code>instance-attribute</code>","text":""},{"location":"reference/objects/application/#TM1py.Objects.Application.SubsetApplication","title":"<code>SubsetApplication(path, name, dimension_name, hierarchy_name, subset_name)</code>","text":"<p>               Bases: <code>Application</code></p> Source code in <code>TM1py/Objects/Application.py</code> <pre><code>def __init__(self, path: str, name: str, dimension_name: str, hierarchy_name: str, subset_name: str):\n    super().__init__(path, name, ApplicationTypes.SUBSET)\n    self.dimension_name = dimension_name\n    self.hierarchy_name = hierarchy_name\n    self.subset_name = subset_name\n</code></pre>"},{"location":"reference/objects/application/#TM1py.Objects.Application.SubsetApplication.body","title":"<code>body</code>  <code>property</code>","text":""},{"location":"reference/objects/application/#TM1py.Objects.Application.SubsetApplication.dimension_name","title":"<code>dimension_name = dimension_name</code>  <code>instance-attribute</code>","text":""},{"location":"reference/objects/application/#TM1py.Objects.Application.SubsetApplication.hierarchy_name","title":"<code>hierarchy_name = hierarchy_name</code>  <code>instance-attribute</code>","text":""},{"location":"reference/objects/application/#TM1py.Objects.Application.SubsetApplication.subset_name","title":"<code>subset_name = subset_name</code>  <code>instance-attribute</code>","text":""},{"location":"reference/objects/application/#TM1py.Objects.Application.ViewApplication","title":"<code>ViewApplication(path, name, cube_name, view_name)</code>","text":"<p>               Bases: <code>Application</code></p> Source code in <code>TM1py/Objects/Application.py</code> <pre><code>def __init__(self, path: str, name: str, cube_name: str, view_name: str):\n    super().__init__(path, name, ApplicationTypes.VIEW)\n    self.cube_name = cube_name\n    self.view_name = view_name\n</code></pre>"},{"location":"reference/objects/application/#TM1py.Objects.Application.ViewApplication.body","title":"<code>body</code>  <code>property</code>","text":""},{"location":"reference/objects/application/#TM1py.Objects.Application.ViewApplication.cube_name","title":"<code>cube_name = cube_name</code>  <code>instance-attribute</code>","text":""},{"location":"reference/objects/application/#TM1py.Objects.Application.ViewApplication.view_name","title":"<code>view_name = view_name</code>  <code>instance-attribute</code>","text":""},{"location":"reference/objects/axis/","title":"Axis","text":""},{"location":"reference/objects/axis/#TM1py.Objects.Axis.ViewAxisSelection","title":"<code>ViewAxisSelection(dimension_name, subset)</code>","text":"<p>               Bases: <code>TM1Object</code></p> <p>Describes what is selected in a dimension on an axis. Can be a Registered Subset or an Anonymous Subset</p> <p>:Parameters:     <code>dimension_name</code> : String     <code>subset</code> : Subset or AnonymousSubset</p> Source code in <code>TM1py/Objects/Axis.py</code> <pre><code>def __init__(self, dimension_name: str, subset: Union[Subset, AnonymousSubset]):\n    \"\"\"\n    :Parameters:\n        `dimension_name` : String\n        `subset` : Subset or AnonymousSubset\n    \"\"\"\n    self._subset = subset\n    self._dimension_name = dimension_name\n    self._hierarchy_name = dimension_name\n</code></pre>"},{"location":"reference/objects/axis/#TM1py.Objects.Axis.ViewAxisSelection.body","title":"<code>body</code>  <code>property</code>","text":""},{"location":"reference/objects/axis/#TM1py.Objects.Axis.ViewAxisSelection.body_as_dict","title":"<code>body_as_dict</code>  <code>property</code>","text":""},{"location":"reference/objects/axis/#TM1py.Objects.Axis.ViewAxisSelection.dimension_name","title":"<code>dimension_name</code>  <code>property</code>","text":""},{"location":"reference/objects/axis/#TM1py.Objects.Axis.ViewAxisSelection.hierarchy_name","title":"<code>hierarchy_name</code>  <code>property</code>","text":""},{"location":"reference/objects/axis/#TM1py.Objects.Axis.ViewAxisSelection.subset","title":"<code>subset</code>  <code>property</code>","text":""},{"location":"reference/objects/axis/#TM1py.Objects.Axis.ViewTitleSelection","title":"<code>ViewTitleSelection(dimension_name, subset, selected)</code>","text":"<p>Describes what is selected in a dimension on the view title. Can be a Registered Subset or an Anonymous Subset</p> Source code in <code>TM1py/Objects/Axis.py</code> <pre><code>def __init__(self, dimension_name: str, subset: Union[AnonymousSubset, Subset], selected: str):\n    self._dimension_name = dimension_name\n    self._hierarchy_name = dimension_name\n    self._subset = subset\n    self._selected = selected\n</code></pre>"},{"location":"reference/objects/axis/#TM1py.Objects.Axis.ViewTitleSelection.body","title":"<code>body</code>  <code>property</code>","text":""},{"location":"reference/objects/axis/#TM1py.Objects.Axis.ViewTitleSelection.dimension_name","title":"<code>dimension_name</code>  <code>property</code>","text":""},{"location":"reference/objects/axis/#TM1py.Objects.Axis.ViewTitleSelection.hierarchy_name","title":"<code>hierarchy_name</code>  <code>property</code>","text":""},{"location":"reference/objects/axis/#TM1py.Objects.Axis.ViewTitleSelection.selected","title":"<code>selected</code>  <code>property</code>","text":""},{"location":"reference/objects/axis/#TM1py.Objects.Axis.ViewTitleSelection.subset","title":"<code>subset</code>  <code>property</code>","text":""},{"location":"reference/objects/chore/","title":"Chore","text":""},{"location":"reference/objects/chore/#TM1py.Objects.Chore.Chore","title":"<code>Chore(name, start_time, dst_sensitivity, active, execution_mode, frequency, tasks)</code>","text":"<p>               Bases: <code>TM1Object</code></p> <p>Abstraction of TM1 Chore</p> Source code in <code>TM1py/Objects/Chore.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    start_time: ChoreStartTime,\n    dst_sensitivity: bool,\n    active: bool,\n    execution_mode: str,\n    frequency: ChoreFrequency,\n    tasks: Iterable[ChoreTask],\n):\n    self._name = name\n    self._start_time = start_time\n    self._dst_sensitivity = dst_sensitivity\n    self._active = active\n    self._execution_mode = execution_mode\n    self._frequency = frequency\n    self._tasks = list(tasks)\n</code></pre>"},{"location":"reference/objects/chore/#TM1py.Objects.Chore.Chore.MULTIPLE_COMMIT","title":"<code>MULTIPLE_COMMIT = 'MultipleCommit'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/objects/chore/#TM1py.Objects.Chore.Chore.SINGLE_COMMIT","title":"<code>SINGLE_COMMIT = 'SingleCommit'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/objects/chore/#TM1py.Objects.Chore.Chore.active","title":"<code>active</code>  <code>property</code>","text":""},{"location":"reference/objects/chore/#TM1py.Objects.Chore.Chore.body","title":"<code>body</code>  <code>property</code>","text":""},{"location":"reference/objects/chore/#TM1py.Objects.Chore.Chore.body_as_dict","title":"<code>body_as_dict</code>  <code>property</code>","text":""},{"location":"reference/objects/chore/#TM1py.Objects.Chore.Chore.dst_sensitivity","title":"<code>dst_sensitivity</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/chore/#TM1py.Objects.Chore.Chore.execution_mode","title":"<code>execution_mode</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/chore/#TM1py.Objects.Chore.Chore.execution_path","title":"<code>execution_path</code>  <code>property</code>","text":"<p>1 chore together with its executed processes Use case: building out a tree of chores and their processes (and again the processes that are called by the latter (if any)).</p> <p>Returns:</p> Type Description <code>Dict</code> <p>dictionary containing chore name as the key and a list of process names as the value</p>"},{"location":"reference/objects/chore/#TM1py.Objects.Chore.Chore.frequency","title":"<code>frequency</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/chore/#TM1py.Objects.Chore.Chore.name","title":"<code>name</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/chore/#TM1py.Objects.Chore.Chore.start_time","title":"<code>start_time</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/chore/#TM1py.Objects.Chore.Chore.tasks","title":"<code>tasks</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/chore/#TM1py.Objects.Chore.Chore.activate","title":"<code>activate()</code>","text":"Source code in <code>TM1py/Objects/Chore.py</code> <pre><code>def activate(self):\n    self._active = True\n</code></pre>"},{"location":"reference/objects/chore/#TM1py.Objects.Chore.Chore.add_task","title":"<code>add_task(task)</code>","text":"Source code in <code>TM1py/Objects/Chore.py</code> <pre><code>def add_task(self, task: ChoreTask):\n    self._tasks.append(task)\n</code></pre>"},{"location":"reference/objects/chore/#TM1py.Objects.Chore.Chore.construct_body","title":"<code>construct_body()</code>","text":"<p>construct self.body (json) from the class attributes</p> <p>Returns:</p> Type Description <code>str</code> <p>String, TM1 JSON representation of a chore</p> Source code in <code>TM1py/Objects/Chore.py</code> <pre><code>def construct_body(self) -&gt; str:\n    \"\"\"\n    construct self.body (json) from the class attributes\n    :return: String, TM1 JSON representation of a chore\n    \"\"\"\n    body_as_dict = collections.OrderedDict()\n    body_as_dict[\"Name\"] = self._name\n    body_as_dict[\"StartTime\"] = self._start_time.start_time_string\n    body_as_dict[\"DSTSensitive\"] = self._dst_sensitivity\n    body_as_dict[\"Active\"] = self._active\n    body_as_dict[\"ExecutionMode\"] = self._execution_mode\n    body_as_dict[\"Frequency\"] = self._frequency.frequency_string\n    body_as_dict[\"Tasks\"] = [task.body_as_dict for task in self._tasks]\n    return json.dumps(body_as_dict, ensure_ascii=False)\n</code></pre>"},{"location":"reference/objects/chore/#TM1py.Objects.Chore.Chore.deactivate","title":"<code>deactivate()</code>","text":"Source code in <code>TM1py/Objects/Chore.py</code> <pre><code>def deactivate(self):\n    self._active = False\n</code></pre>"},{"location":"reference/objects/chore/#TM1py.Objects.Chore.Chore.from_dict","title":"<code>from_dict(chore_as_dict)</code>  <code>classmethod</code>","text":"<p>Alternative constructor</p> <p>Parameters:</p> Name Type Description Default <code>chore_as_dict</code> <code>Dict</code> <p>Chore as dict</p> required <p>Returns:</p> Type Description <code>Chore</code> <p>Chore, an instance of this class</p> Source code in <code>TM1py/Objects/Chore.py</code> <pre><code>@classmethod\ndef from_dict(cls, chore_as_dict: Dict) -&gt; \"Chore\":\n    \"\"\"Alternative constructor\n\n    :param chore_as_dict: Chore as dict\n    :return: Chore, an instance of this class\n    \"\"\"\n    return cls(\n        name=chore_as_dict[\"Name\"],\n        start_time=ChoreStartTime.from_string(chore_as_dict[\"StartTime\"]),\n        dst_sensitivity=chore_as_dict[\"DSTSensitive\"],\n        active=chore_as_dict[\"Active\"],\n        execution_mode=chore_as_dict[\"ExecutionMode\"],\n        frequency=ChoreFrequency.from_string(chore_as_dict[\"Frequency\"]),\n        tasks=[ChoreTask.from_dict(task, step) for step, task in enumerate(chore_as_dict[\"Tasks\"])],\n    )\n</code></pre>"},{"location":"reference/objects/chore/#TM1py.Objects.Chore.Chore.from_json","title":"<code>from_json(chore_as_json)</code>  <code>classmethod</code>","text":"<p>Alternative constructor</p> <p>Parameters:</p> Name Type Description Default <code>chore_as_json</code> <code>str</code> <p>string, JSON. Response of /Chores('x')/Tasks?$expand=*</p> required <p>Returns:</p> Type Description <code>Chore</code> <p>Chore, an instance of this class</p> Source code in <code>TM1py/Objects/Chore.py</code> <pre><code>@classmethod\ndef from_json(cls, chore_as_json: str) -&gt; \"Chore\":\n    \"\"\"Alternative constructor\n\n    :param chore_as_json: string, JSON. Response of /Chores('x')/Tasks?$expand=*\n    :return: Chore, an instance of this class\n    \"\"\"\n    chore_as_dict = json.loads(chore_as_json)\n    return cls.from_dict(chore_as_dict)\n</code></pre>"},{"location":"reference/objects/chore/#TM1py.Objects.Chore.Chore.insert_task","title":"<code>insert_task(new_task)</code>","text":"Source code in <code>TM1py/Objects/Chore.py</code> <pre><code>def insert_task(self, new_task: ChoreTask):\n    task_list = self.tasks\n    for task in task_list[new_task._step :]:\n        task._step = task._step + 1\n    task_list.insert(new_task._step, new_task)\n    self.tasks = task_list\n</code></pre>"},{"location":"reference/objects/chore/#TM1py.Objects.Chore.Chore.reschedule","title":"<code>reschedule(days=0, hours=0, minutes=0, seconds=0)</code>","text":"Source code in <code>TM1py/Objects/Chore.py</code> <pre><code>def reschedule(self, days: int = 0, hours: int = 0, minutes: int = 0, seconds: int = 0):\n    self._start_time.add(days=days, hours=hours, minutes=minutes, seconds=seconds)\n</code></pre>"},{"location":"reference/objects/chorefrequency/","title":"ChoreFrequency","text":""},{"location":"reference/objects/chorefrequency/#TM1py.Objects.ChoreFrequency.ChoreFrequency","title":"<code>ChoreFrequency(days, hours, minutes, seconds)</code>","text":"<p>               Bases: <code>TM1Object</code></p> <p>Utility class to handle time representation fore Chore Frequency</p> Source code in <code>TM1py/Objects/ChoreFrequency.py</code> <pre><code>def __init__(\n    self, days: Union[str, int], hours: Union[str, int], minutes: Union[str, int], seconds: Union[str, int]\n):\n    self._days = str(days).zfill(2)\n    self._hours = str(hours).zfill(2)\n    self._minutes = str(minutes).zfill(2)\n    self._seconds = str(seconds).zfill(2)\n</code></pre>"},{"location":"reference/objects/chorefrequency/#TM1py.Objects.ChoreFrequency.ChoreFrequency.days","title":"<code>days</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/chorefrequency/#TM1py.Objects.ChoreFrequency.ChoreFrequency.frequency_string","title":"<code>frequency_string</code>  <code>property</code>","text":""},{"location":"reference/objects/chorefrequency/#TM1py.Objects.ChoreFrequency.ChoreFrequency.hours","title":"<code>hours</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/chorefrequency/#TM1py.Objects.ChoreFrequency.ChoreFrequency.minutes","title":"<code>minutes</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/chorefrequency/#TM1py.Objects.ChoreFrequency.ChoreFrequency.seconds","title":"<code>seconds</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/chorefrequency/#TM1py.Objects.ChoreFrequency.ChoreFrequency.__str__","title":"<code>__str__()</code>","text":"Source code in <code>TM1py/Objects/ChoreFrequency.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.frequency_string\n</code></pre>"},{"location":"reference/objects/chorefrequency/#TM1py.Objects.ChoreFrequency.ChoreFrequency.from_string","title":"<code>from_string(frequency_string)</code>  <code>classmethod</code>","text":"Source code in <code>TM1py/Objects/ChoreFrequency.py</code> <pre><code>@classmethod\ndef from_string(cls, frequency_string: str) -&gt; \"ChoreFrequency\":\n    pos_dt = frequency_string.find(\"DT\", 1)\n    pos_h = frequency_string.find(\"H\", pos_dt)\n    pos_m = frequency_string.find(\"M\", pos_h)\n    pos_s = len(frequency_string) - 1\n    return cls(\n        days=frequency_string[1:pos_dt],\n        hours=frequency_string[pos_dt + 2 : pos_h],\n        minutes=frequency_string[pos_h + 1 : pos_m],\n        seconds=frequency_string[pos_m + 1 : pos_s],\n    )\n</code></pre>"},{"location":"reference/objects/chorestarttime/","title":"ChoreStartTime","text":""},{"location":"reference/objects/chorestarttime/#TM1py.Objects.ChoreStartTime.ChoreStartTime","title":"<code>ChoreStartTime(year, month, day, hour, minute, second, tz=None)</code>","text":"<p>Utility class to handle time representation for Chore Start Time</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>year</p> required <code>month</code> <code>int</code> <p>month</p> required <code>day</code> <code>int</code> <p>day</p> required <code>hour</code> <code>int</code> <p>hour or None</p> required <code>minute</code> <code>int</code> <p>minute or None</p> required <code>second</code> <code>int</code> <p>second or None</p> required Source code in <code>TM1py/Objects/ChoreStartTime.py</code> <pre><code>def __init__(self, year: int, month: int, day: int, hour: int, minute: int, second: int, tz: str = None):\n    \"\"\"\n\n    :param year: year\n    :param month: month\n    :param day: day\n    :param hour: hour or None\n    :param minute: minute or None\n    :param second: second or None\n    \"\"\"\n    self._datetime = datetime.datetime.combine(datetime.date(year, month, day), datetime.time(hour, minute, second))\n    self.tz = tz\n</code></pre>"},{"location":"reference/objects/chorestarttime/#TM1py.Objects.ChoreStartTime.ChoreStartTime.datetime","title":"<code>datetime</code>  <code>property</code>","text":""},{"location":"reference/objects/chorestarttime/#TM1py.Objects.ChoreStartTime.ChoreStartTime.start_time_string","title":"<code>start_time_string</code>  <code>property</code>","text":""},{"location":"reference/objects/chorestarttime/#TM1py.Objects.ChoreStartTime.ChoreStartTime.tz","title":"<code>tz = tz</code>  <code>instance-attribute</code>","text":""},{"location":"reference/objects/chorestarttime/#TM1py.Objects.ChoreStartTime.ChoreStartTime.__str__","title":"<code>__str__()</code>","text":"Source code in <code>TM1py/Objects/ChoreStartTime.py</code> <pre><code>def __str__(self):\n    return self.start_time_string\n</code></pre>"},{"location":"reference/objects/chorestarttime/#TM1py.Objects.ChoreStartTime.ChoreStartTime.add","title":"<code>add(days=0, hours=0, minutes=0, seconds=0)</code>","text":"Source code in <code>TM1py/Objects/ChoreStartTime.py</code> <pre><code>def add(self, days: int = 0, hours: int = 0, minutes: int = 0, seconds: int = 0):\n    self._datetime = self._datetime + datetime.timedelta(days=days, hours=hours, minutes=minutes, seconds=seconds)\n</code></pre>"},{"location":"reference/objects/chorestarttime/#TM1py.Objects.ChoreStartTime.ChoreStartTime.from_string","title":"<code>from_string(start_time_string)</code>  <code>classmethod</code>","text":"Source code in <code>TM1py/Objects/ChoreStartTime.py</code> <pre><code>@classmethod\ndef from_string(cls, start_time_string: str) -&gt; \"ChoreStartTime\":\n    # extract optional tz info (e.g., +01:00) from string end\n    if \"+\" in start_time_string:\n        # case \"2020-11-05T08:00:01+01:00\",\n        tz = \"+\" + start_time_string.split(\"+\")[1]\n    elif start_time_string.count(\"-\") == 3:\n        # case: \"2020-11-05T08:00:01-01:00\",\n        tz = \"-\" + start_time_string.split(\"-\")[-1]\n    else:\n        tz = None\n\n    # f to handle strange timestamp 2016-09-25T20:25Z instead of common 2016-09-25T20:25:00Z\n    # second is defaulted to 0 if not specified in the chore schedule\n    def format_time(value: int) -&gt; str:\n        return int(value or 0)\n\n    return cls(\n        year=format_time(start_time_string[0:4]),\n        month=format_time(start_time_string[5:7]),\n        day=format_time(start_time_string[8:10]),\n        hour=format_time(start_time_string[11:13]),\n        minute=format_time(start_time_string[14:16]),\n        second=format_time(0 if start_time_string[16] != \":\" else start_time_string[17:19]),\n        tz=tz,\n    )\n</code></pre>"},{"location":"reference/objects/chorestarttime/#TM1py.Objects.ChoreStartTime.ChoreStartTime.set_time","title":"<code>set_time(year=None, month=None, day=None, hour=None, minute=None, second=None)</code>","text":"Source code in <code>TM1py/Objects/ChoreStartTime.py</code> <pre><code>def set_time(\n    self,\n    year: int = None,\n    month: int = None,\n    day: int = None,\n    hour: int = None,\n    minute: int = None,\n    second: int = None,\n):\n\n    _year = year if year is not None else self._datetime.year\n    _month = month if month is not None else self._datetime.month\n    _day = day if day is not None else self._datetime.day\n    _hour = hour if hour is not None else self._datetime.hour\n    _minute = minute if minute is not None else self._datetime.minute\n    _second = second if second is not None else self._datetime.second\n\n    self._datetime = self._datetime.replace(\n        year=_year, month=_month, day=_day, hour=_hour, minute=_minute, second=_second\n    )\n</code></pre>"},{"location":"reference/objects/chorestarttime/#TM1py.Objects.ChoreStartTime.ChoreStartTime.subtract","title":"<code>subtract(days=0, hours=0, minutes=0, seconds=0)</code>","text":"Source code in <code>TM1py/Objects/ChoreStartTime.py</code> <pre><code>def subtract(self, days: int = 0, hours: int = 0, minutes: int = 0, seconds: int = 0):\n    self._datetime = self._datetime - datetime.timedelta(days=days, hours=hours, minutes=minutes, seconds=seconds)\n</code></pre>"},{"location":"reference/objects/choretask/","title":"ChoreTask","text":""},{"location":"reference/objects/choretask/#TM1py.Objects.ChoreTask.ChoreTask","title":"<code>ChoreTask(step, process_name, parameters)</code>","text":"<p>               Bases: <code>TM1Object</code></p> <p>Abstraction of a Chore Task</p> <p>A Chore task always conistst of - The step integer ID: it's order in the execution plan.   1 to n, where n is the last Process in the Chore - The name of the process to execute - The parameters for the process</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>int</code> <p>step in the execution order of the Chores' processes. 1 to n, where n the number of processes</p> required <code>process_name</code> <code>str</code> <p>name of the process</p> required <code>parameters</code> <code>List[Dict[str, str]]</code> <p>list of dictionaries with 'Name' and 'Value' property: [{ 'Name': '..', 'Value': '..' }, ... ]</p> required Source code in <code>TM1py/Objects/ChoreTask.py</code> <pre><code>def __init__(self, step: int, process_name: str, parameters: List[Dict[str, str]]):\n    \"\"\"\n\n    :param step: step in the execution order of the Chores' processes. 1 to n, where n the number of processes\n    :param process_name: name of the process\n    :param parameters: list of dictionaries with 'Name' and 'Value' property:\n                        [{\n                            'Name': '..',\n                            'Value': '..'\n                        },\n                        ...\n                        ]\n    \"\"\"\n    self._step = step\n    self._process_name = process_name\n    self._parameters = parameters\n</code></pre>"},{"location":"reference/objects/choretask/#TM1py.Objects.ChoreTask.ChoreTask.body","title":"<code>body</code>  <code>property</code>","text":""},{"location":"reference/objects/choretask/#TM1py.Objects.ChoreTask.ChoreTask.body_as_dict","title":"<code>body_as_dict</code>  <code>property</code>","text":""},{"location":"reference/objects/choretask/#TM1py.Objects.ChoreTask.ChoreTask.parameters","title":"<code>parameters</code>  <code>property</code>","text":""},{"location":"reference/objects/choretask/#TM1py.Objects.ChoreTask.ChoreTask.process_name","title":"<code>process_name</code>  <code>property</code>","text":""},{"location":"reference/objects/choretask/#TM1py.Objects.ChoreTask.ChoreTask.step","title":"<code>step</code>  <code>property</code>","text":""},{"location":"reference/objects/choretask/#TM1py.Objects.ChoreTask.ChoreTask.__eq__","title":"<code>__eq__(other)</code>","text":"Source code in <code>TM1py/Objects/ChoreTask.py</code> <pre><code>def __eq__(self, other: \"ChoreTask\") -&gt; bool:\n    return self.process_name == other.process_name and self.parameters == other.parameters\n</code></pre>"},{"location":"reference/objects/choretask/#TM1py.Objects.ChoreTask.ChoreTask.__ne__","title":"<code>__ne__(other)</code>","text":"Source code in <code>TM1py/Objects/ChoreTask.py</code> <pre><code>def __ne__(self, other: \"ChoreTask\") -&gt; bool:\n    return self.process_name != other.process_name or self._parameters != other.parameters\n</code></pre>"},{"location":"reference/objects/choretask/#TM1py.Objects.ChoreTask.ChoreTask.from_dict","title":"<code>from_dict(chore_task_as_dict, step=None)</code>  <code>classmethod</code>","text":"Source code in <code>TM1py/Objects/ChoreTask.py</code> <pre><code>@classmethod\ndef from_dict(cls, chore_task_as_dict: Dict, step: int = None):\n    if \"Process\" in chore_task_as_dict:\n        process_name = chore_task_as_dict[\"Process\"][\"Name\"]\n    else:\n        # Extract \"ProcessName\" from \"Processes('ProcessName')\"\n        process_name = chore_task_as_dict[\"Process@odata.bind\"][11:-2]\n\n    return cls(\n        step=step if step is not None else int(chore_task_as_dict[\"Step\"]),\n        process_name=process_name,\n        parameters=[{\"Name\": p[\"Name\"], \"Value\": p[\"Value\"]} for p in chore_task_as_dict[\"Parameters\"]],\n    )\n</code></pre>"},{"location":"reference/objects/cube/","title":"Cube","text":""},{"location":"reference/objects/cube/#TM1py.Objects.Cube.Cube","title":"<code>Cube(name, dimensions, rules=None)</code>","text":"<p>               Bases: <code>TM1Object</code></p> <p>Abstraction of a TM1 Cube</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the Cube</p> required <code>dimensions</code> <code>Iterable[str]</code> <p>list of (existing) dimension names</p> required <code>rules</code> <code>Optional[Union[str, Rules]]</code> <p>instance of TM1py.Objects.Rules</p> <code>None</code> Source code in <code>TM1py/Objects/Cube.py</code> <pre><code>def __init__(self, name: str, dimensions: Iterable[str], rules: Optional[Union[str, Rules]] = None):\n    \"\"\"\n\n    :param name: name of the Cube\n    :param dimensions: list of (existing) dimension names\n    :param rules: instance of TM1py.Objects.Rules\n    \"\"\"\n    self._name = name\n    self.dimensions = list(dimensions)\n    self.rules = rules\n</code></pre>"},{"location":"reference/objects/cube/#TM1py.Objects.Cube.Cube.body","title":"<code>body</code>  <code>property</code>","text":""},{"location":"reference/objects/cube/#TM1py.Objects.Cube.Cube.dimensions","title":"<code>dimensions</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/cube/#TM1py.Objects.Cube.Cube.feedstrings","title":"<code>feedstrings</code>  <code>property</code>","text":""},{"location":"reference/objects/cube/#TM1py.Objects.Cube.Cube.has_rules","title":"<code>has_rules</code>  <code>property</code>","text":""},{"location":"reference/objects/cube/#TM1py.Objects.Cube.Cube.name","title":"<code>name</code>  <code>property</code>","text":""},{"location":"reference/objects/cube/#TM1py.Objects.Cube.Cube.rules","title":"<code>rules</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/cube/#TM1py.Objects.Cube.Cube.skipcheck","title":"<code>skipcheck</code>  <code>property</code>","text":""},{"location":"reference/objects/cube/#TM1py.Objects.Cube.Cube.undefvals","title":"<code>undefvals</code>  <code>property</code>","text":""},{"location":"reference/objects/cube/#TM1py.Objects.Cube.Cube.from_dict","title":"<code>from_dict(cube_as_dict)</code>  <code>classmethod</code>","text":"<p>Alternative constructor</p> <p>Parameters:</p> Name Type Description Default <code>cube_as_dict</code> <code>Dict</code> <p>user as dict</p> required <p>Returns:</p> Type Description <code>Cube</code> <p>user, an instance of this class</p> Source code in <code>TM1py/Objects/Cube.py</code> <pre><code>@classmethod\ndef from_dict(cls, cube_as_dict: Dict) -&gt; \"Cube\":\n    \"\"\"Alternative constructor\n\n    :param cube_as_dict: user as dict\n    :return: user, an instance of this class\n    \"\"\"\n    return cls(\n        name=cube_as_dict[\"Name\"],\n        dimensions=[dimension[\"Name\"] for dimension in cube_as_dict[\"Dimensions\"]],\n        rules=Rules(cube_as_dict[\"Rules\"]) if cube_as_dict[\"Rules\"] else None,\n    )\n</code></pre>"},{"location":"reference/objects/cube/#TM1py.Objects.Cube.Cube.from_json","title":"<code>from_json(cube_as_json)</code>  <code>classmethod</code>","text":"<p>Alternative constructor</p> <p>Parameters:</p> Name Type Description Default <code>cube_as_json</code> <code>str</code> <p>user as JSON string</p> required <p>Returns:</p> Type Description <code>Cube</code> <p>cube, an instance of this class</p> Source code in <code>TM1py/Objects/Cube.py</code> <pre><code>@classmethod\ndef from_json(cls, cube_as_json: str) -&gt; \"Cube\":\n    \"\"\"Alternative constructor\n\n    :param cube_as_json: user as JSON string\n    :return: cube, an instance of this class\n    \"\"\"\n    cube_as_dict = json.loads(cube_as_json)\n    return cls.from_dict(cube_as_dict)\n</code></pre>"},{"location":"reference/objects/dimension/","title":"Dimension","text":""},{"location":"reference/objects/dimension/#TM1py.Objects.Dimension.Dimension","title":"<code>Dimension(name, hierarchies=None)</code>","text":"<p>               Bases: <code>TM1Object</code></p> <p>Abstraction of TM1 Dimension</p> <p>A Dimension is a container for hierarchies.</p> <p>Abstraction of TM1 Dimension</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the dimension</p> required <code>hierarchies</code> <code>Optional[Iterable[Hierarchy]]</code> <p>List of TM1py.Objects.Hierarchy instances</p> <code>None</code> Source code in <code>TM1py/Objects/Dimension.py</code> <pre><code>def __init__(self, name: str, hierarchies: Optional[Iterable[Hierarchy]] = None):\n    \"\"\"Abstraction of TM1 Dimension\n\n\n    :param name: Name of the dimension\n    :param hierarchies: List of TM1py.Objects.Hierarchy instances\n    \"\"\"\n    self._name = name\n    self._hierarchies = list(hierarchies) if hierarchies else []\n    self._attributes = {\"Caption\": name}\n</code></pre>"},{"location":"reference/objects/dimension/#TM1py.Objects.Dimension.Dimension.body","title":"<code>body</code>  <code>property</code>","text":""},{"location":"reference/objects/dimension/#TM1py.Objects.Dimension.Dimension.body_as_dict","title":"<code>body_as_dict</code>  <code>property</code>","text":""},{"location":"reference/objects/dimension/#TM1py.Objects.Dimension.Dimension.default_hierarchy","title":"<code>default_hierarchy</code>  <code>property</code>","text":""},{"location":"reference/objects/dimension/#TM1py.Objects.Dimension.Dimension.hierarchies","title":"<code>hierarchies</code>  <code>property</code>","text":""},{"location":"reference/objects/dimension/#TM1py.Objects.Dimension.Dimension.hierarchy_names","title":"<code>hierarchy_names</code>  <code>property</code>","text":""},{"location":"reference/objects/dimension/#TM1py.Objects.Dimension.Dimension.name","title":"<code>name</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/dimension/#TM1py.Objects.Dimension.Dimension.unique_name","title":"<code>unique_name</code>  <code>property</code>","text":""},{"location":"reference/objects/dimension/#TM1py.Objects.Dimension.Dimension.__contains__","title":"<code>__contains__(item)</code>","text":"Source code in <code>TM1py/Objects/Dimension.py</code> <pre><code>def __contains__(self, item):\n    return self.contains_hierarchy(item)\n</code></pre>"},{"location":"reference/objects/dimension/#TM1py.Objects.Dimension.Dimension.__getitem__","title":"<code>__getitem__(item)</code>","text":"Source code in <code>TM1py/Objects/Dimension.py</code> <pre><code>def __getitem__(self, item):\n    return self.get_hierarchy(item)\n</code></pre>"},{"location":"reference/objects/dimension/#TM1py.Objects.Dimension.Dimension.__iter__","title":"<code>__iter__()</code>","text":"Source code in <code>TM1py/Objects/Dimension.py</code> <pre><code>def __iter__(self):\n    return iter(self._hierarchies)\n</code></pre>"},{"location":"reference/objects/dimension/#TM1py.Objects.Dimension.Dimension.__len__","title":"<code>__len__()</code>","text":"Source code in <code>TM1py/Objects/Dimension.py</code> <pre><code>def __len__(self):\n    return len(self.hierarchies)\n</code></pre>"},{"location":"reference/objects/dimension/#TM1py.Objects.Dimension.Dimension.add_hierarchy","title":"<code>add_hierarchy(hierarchy)</code>","text":"Source code in <code>TM1py/Objects/Dimension.py</code> <pre><code>def add_hierarchy(self, hierarchy: Hierarchy):\n    if self.contains_hierarchy(hierarchy.name):\n        raise ValueError(\"Hierarchy: {} already exists in dimension: {}\".format(hierarchy.name, self.name))\n    self._hierarchies.append(hierarchy)\n</code></pre>"},{"location":"reference/objects/dimension/#TM1py.Objects.Dimension.Dimension.contains_hierarchy","title":"<code>contains_hierarchy(hierarchy_name)</code>","text":"Source code in <code>TM1py/Objects/Dimension.py</code> <pre><code>def contains_hierarchy(self, hierarchy_name: str) -&gt; bool:\n    for hierarchy in self._hierarchies:\n        if case_and_space_insensitive_equals(hierarchy.name, hierarchy_name):\n            return True\n    return False\n</code></pre>"},{"location":"reference/objects/dimension/#TM1py.Objects.Dimension.Dimension.from_dict","title":"<code>from_dict(dimension_as_dict)</code>  <code>classmethod</code>","text":"Source code in <code>TM1py/Objects/Dimension.py</code> <pre><code>@classmethod\ndef from_dict(cls, dimension_as_dict: Dict) -&gt; \"Dimension\":\n    return cls(\n        name=dimension_as_dict[\"Name\"],\n        hierarchies=[\n            Hierarchy.from_dict(hierarchy, dimension_name=dimension_as_dict[\"Name\"])\n            for hierarchy in dimension_as_dict[\"Hierarchies\"]\n        ],\n    )\n</code></pre>"},{"location":"reference/objects/dimension/#TM1py.Objects.Dimension.Dimension.from_json","title":"<code>from_json(dimension_as_json)</code>  <code>classmethod</code>","text":"Source code in <code>TM1py/Objects/Dimension.py</code> <pre><code>@classmethod\ndef from_json(cls, dimension_as_json: str) -&gt; \"Dimension\":\n    dimension_as_dict = json.loads(dimension_as_json)\n    return cls.from_dict(dimension_as_dict)\n</code></pre>"},{"location":"reference/objects/dimension/#TM1py.Objects.Dimension.Dimension.get_hierarchy","title":"<code>get_hierarchy(hierarchy_name)</code>","text":"Source code in <code>TM1py/Objects/Dimension.py</code> <pre><code>def get_hierarchy(self, hierarchy_name: str) -&gt; Hierarchy:\n    for hierarchy in self._hierarchies:\n        if case_and_space_insensitive_equals(hierarchy.name, hierarchy_name):\n            return hierarchy\n    raise ValueError(\"Hierarchy: {} not found in dimension: {}\".format(hierarchy_name, self.name))\n</code></pre>"},{"location":"reference/objects/dimension/#TM1py.Objects.Dimension.Dimension.remove_hierarchy","title":"<code>remove_hierarchy(hierarchy_name)</code>","text":"Source code in <code>TM1py/Objects/Dimension.py</code> <pre><code>def remove_hierarchy(self, hierarchy_name: str):\n    if case_and_space_insensitive_equals(hierarchy_name, \"leaves\"):\n        raise ValueError(\"'Leaves' hierarchy must not be removed from dimension\")\n\n    for num, hierarchy in enumerate(self._hierarchies):\n        if case_and_space_insensitive_equals(hierarchy.name, hierarchy_name):\n            del self._hierarchies[num]\n            return\n</code></pre>"},{"location":"reference/objects/element/","title":"Element","text":""},{"location":"reference/objects/element/#TM1py.Objects.Element.Element","title":"<code>Element(name, element_type, attributes=None, unique_name=None, index=None)</code>","text":"<p>               Bases: <code>TM1Object</code></p> <p>Abstraction of TM1 Element</p> Source code in <code>TM1py/Objects/Element.py</code> <pre><code>def __init__(\n    self,\n    name,\n    element_type: Union[Types, str],\n    attributes: List[str] = None,\n    unique_name: str = None,\n    index: int = None,\n):\n    self._name = name\n    self._unique_name = unique_name\n    self._index = index\n    self._element_type = None\n    self.element_type = element_type\n    self._attributes = attributes\n</code></pre>"},{"location":"reference/objects/element/#TM1py.Objects.Element.Element.ELEMENT_ATTRIBUTES_PREFIX","title":"<code>ELEMENT_ATTRIBUTES_PREFIX = '}ElementAttributes_'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/objects/element/#TM1py.Objects.Element.Element.body","title":"<code>body</code>  <code>property</code>","text":""},{"location":"reference/objects/element/#TM1py.Objects.Element.Element.body_as_dict","title":"<code>body_as_dict</code>  <code>property</code>","text":""},{"location":"reference/objects/element/#TM1py.Objects.Element.Element.element_attributes","title":"<code>element_attributes</code>  <code>property</code>","text":""},{"location":"reference/objects/element/#TM1py.Objects.Element.Element.element_type","title":"<code>element_type</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/element/#TM1py.Objects.Element.Element.index","title":"<code>index</code>  <code>property</code>","text":""},{"location":"reference/objects/element/#TM1py.Objects.Element.Element.name","title":"<code>name</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/element/#TM1py.Objects.Element.Element.unique_name","title":"<code>unique_name</code>  <code>property</code>","text":""},{"location":"reference/objects/element/#TM1py.Objects.Element.Element.Types","title":"<code>Types</code>","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"reference/objects/element/#TM1py.Objects.Element.Element.Types.CONSOLIDATED","title":"<code>CONSOLIDATED = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/objects/element/#TM1py.Objects.Element.Element.Types.NUMERIC","title":"<code>NUMERIC = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/objects/element/#TM1py.Objects.Element.Element.Types.STRING","title":"<code>STRING = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/objects/element/#TM1py.Objects.Element.Element.Types.__str__","title":"<code>__str__()</code>","text":"Source code in <code>TM1py/Objects/Element.py</code> <pre><code>def __str__(self):\n    return self.name.capitalize()\n</code></pre>"},{"location":"reference/objects/element/#TM1py.Objects.Element.Element.__eq__","title":"<code>__eq__(other)</code>","text":"Source code in <code>TM1py/Objects/Element.py</code> <pre><code>def __eq__(self, other: \"Element\"):\n    return all(\n        [\n            isinstance(other, Element),\n            case_and_space_insensitive_equals(self.name, other.name),\n            self.element_type == other.element_type,\n        ]\n    )\n</code></pre>"},{"location":"reference/objects/element/#TM1py.Objects.Element.Element.__hash__","title":"<code>__hash__()</code>","text":"Source code in <code>TM1py/Objects/Element.py</code> <pre><code>def __hash__(self):\n    return super().__hash__()\n</code></pre>"},{"location":"reference/objects/element/#TM1py.Objects.Element.Element.from_dict","title":"<code>from_dict(element_as_dict)</code>  <code>staticmethod</code>","text":"Source code in <code>TM1py/Objects/Element.py</code> <pre><code>@staticmethod\ndef from_dict(element_as_dict: Dict) -&gt; \"Element\":\n    return Element(\n        name=element_as_dict[\"Name\"],\n        unique_name=element_as_dict.get(\"UniqueName\", None),\n        index=element_as_dict.get(\"Index\", None),\n        element_type=element_as_dict[\"Type\"],\n        attributes=element_as_dict.get(\"Attributes\", None),\n    )\n</code></pre>"},{"location":"reference/objects/elementattribute/","title":"ElementAttribute","text":""},{"location":"reference/objects/elementattribute/#TM1py.Objects.ElementAttribute.ElementAttribute","title":"<code>ElementAttribute(name, attribute_type)</code>","text":"<p>               Bases: <code>TM1Object</code></p> <p>Abstraction of TM1 Element Attributes</p> Source code in <code>TM1py/Objects/ElementAttribute.py</code> <pre><code>def __init__(self, name: str, attribute_type: Union[Types, str]):\n    self.name = name\n    self.attribute_type = attribute_type\n</code></pre>"},{"location":"reference/objects/elementattribute/#TM1py.Objects.ElementAttribute.ElementAttribute.attribute_type","title":"<code>attribute_type</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/elementattribute/#TM1py.Objects.ElementAttribute.ElementAttribute.body","title":"<code>body</code>  <code>property</code>","text":""},{"location":"reference/objects/elementattribute/#TM1py.Objects.ElementAttribute.ElementAttribute.body_as_dict","title":"<code>body_as_dict</code>  <code>property</code>","text":""},{"location":"reference/objects/elementattribute/#TM1py.Objects.ElementAttribute.ElementAttribute.name","title":"<code>name</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/elementattribute/#TM1py.Objects.ElementAttribute.ElementAttribute.Types","title":"<code>Types</code>","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"reference/objects/elementattribute/#TM1py.Objects.ElementAttribute.ElementAttribute.Types.ALIAS","title":"<code>ALIAS = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/objects/elementattribute/#TM1py.Objects.ElementAttribute.ElementAttribute.Types.NUMERIC","title":"<code>NUMERIC = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/objects/elementattribute/#TM1py.Objects.ElementAttribute.ElementAttribute.Types.STRING","title":"<code>STRING = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/objects/elementattribute/#TM1py.Objects.ElementAttribute.ElementAttribute.Types.__str__","title":"<code>__str__()</code>","text":"Source code in <code>TM1py/Objects/ElementAttribute.py</code> <pre><code>def __str__(self):\n    return self.name.capitalize()\n</code></pre>"},{"location":"reference/objects/elementattribute/#TM1py.Objects.ElementAttribute.ElementAttribute.__eq__","title":"<code>__eq__(other)</code>","text":"Source code in <code>TM1py/Objects/ElementAttribute.py</code> <pre><code>def __eq__(self, other: Union[str, \"ElementAttribute\"]):\n    if isinstance(other, str):\n        return case_and_space_insensitive_equals(self.name, other)\n    elif isinstance(other, ElementAttribute):\n        return case_and_space_insensitive_equals(self.name, other.name)\n    else:\n        raise ValueError(\"Argument: 'other' must be of type str or ElementAttribute\")\n</code></pre>"},{"location":"reference/objects/elementattribute/#TM1py.Objects.ElementAttribute.ElementAttribute.__hash__","title":"<code>__hash__()</code>","text":"Source code in <code>TM1py/Objects/ElementAttribute.py</code> <pre><code>def __hash__(self):\n    return super().__hash__()\n</code></pre>"},{"location":"reference/objects/elementattribute/#TM1py.Objects.ElementAttribute.ElementAttribute.from_dict","title":"<code>from_dict(element_attribute_as_dict)</code>  <code>classmethod</code>","text":"Source code in <code>TM1py/Objects/ElementAttribute.py</code> <pre><code>@classmethod\ndef from_dict(cls, element_attribute_as_dict: Dict) -&gt; \"ElementAttribute\":\n    return cls(name=element_attribute_as_dict[\"Name\"], attribute_type=element_attribute_as_dict[\"Type\"])\n</code></pre>"},{"location":"reference/objects/elementattribute/#TM1py.Objects.ElementAttribute.ElementAttribute.from_json","title":"<code>from_json(element_attribute_as_json)</code>  <code>classmethod</code>","text":"Source code in <code>TM1py/Objects/ElementAttribute.py</code> <pre><code>@classmethod\ndef from_json(cls, element_attribute_as_json: str) -&gt; \"ElementAttribute\":\n    return cls.from_dict(json.loads(element_attribute_as_json))\n</code></pre>"},{"location":"reference/objects/git/","title":"Git","text":""},{"location":"reference/objects/git/#TM1py.Objects.Git.Git","title":"<code>Git(url, deployment, force, deployed_commit, remote, config=None)</code>","text":"<p>Abstraction of Git object</p> <p>Initialize GIT object</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>file or http(s) path to GIT repository</p> required <code>deployment</code> <code>str</code> <p>name of selected deployment group</p> required <code>force</code> <code>bool</code> <p>whether or not Git context was forced</p> required <code>deployed_commit</code> <code>GitCommit</code> <p>GitCommit object of the currently deployed commit</p> required <code>remote</code> <code>GitRemote</code> <p>GitRemote object of the current remote</p> required <code>config</code> <code>dict</code> <p>Dictionary containing git configuration parameters</p> <code>None</code> Source code in <code>TM1py/Objects/Git.py</code> <pre><code>def __init__(\n    self, url: str, deployment: str, force: bool, deployed_commit: GitCommit, remote: GitRemote, config: dict = None\n):\n    \"\"\"Initialize GIT object\n    :param url: file or http(s) path to GIT repository\n    :param deployment: name of selected deployment group\n    :param force: whether or not Git context was forced\n    :param deployed_commit: GitCommit object of the currently deployed commit\n    :param remote: GitRemote object of the current remote\n    :param config: Dictionary containing git configuration parameters\n\n    \"\"\"\n    self._url = url\n    self._deployment = deployment\n    self._force = force\n    self._deployed_commit = deployed_commit\n    self._remote = remote\n    self._config = config\n</code></pre>"},{"location":"reference/objects/git/#TM1py.Objects.Git.Git.config","title":"<code>config</code>  <code>property</code>","text":""},{"location":"reference/objects/git/#TM1py.Objects.Git.Git.deployed_commit","title":"<code>deployed_commit</code>  <code>property</code>","text":""},{"location":"reference/objects/git/#TM1py.Objects.Git.Git.deployment","title":"<code>deployment</code>  <code>property</code>","text":""},{"location":"reference/objects/git/#TM1py.Objects.Git.Git.force","title":"<code>force</code>  <code>property</code>","text":""},{"location":"reference/objects/git/#TM1py.Objects.Git.Git.remote","title":"<code>remote</code>  <code>property</code>","text":""},{"location":"reference/objects/git/#TM1py.Objects.Git.Git.url","title":"<code>url</code>  <code>property</code>","text":""},{"location":"reference/objects/git/#TM1py.Objects.Git.Git.from_dict","title":"<code>from_dict(json_response)</code>  <code>classmethod</code>","text":"Source code in <code>TM1py/Objects/Git.py</code> <pre><code>@classmethod\ndef from_dict(cls, json_response: Dict) -&gt; \"Git\":\n    deployed_commit = GitCommit(\n        commit_id=json_response[\"DeployedCommit\"].get(\"ID\"),\n        summary=json_response[\"DeployedCommit\"].get(\"Summary\"),\n        author=json_response[\"DeployedCommit\"].get(\"Author\"),\n    )\n\n    remote = GitRemote(\n        connected=json_response[\"Remote\"].get(\"Connected\"),\n        branches=json_response[\"Remote\"].get(\"Branches\"),\n        tags=json_response[\"Remote\"].get(\"Tags\"),\n    )\n\n    git = Git(\n        url=json_response[\"URL\"],\n        deployment=json_response[\"Deployment\"],\n        force=json_response[\"Deployment\"],\n        deployed_commit=deployed_commit,\n        remote=remote,\n    )\n\n    return git\n</code></pre>"},{"location":"reference/objects/gitcommit/","title":"GitCommit","text":""},{"location":"reference/objects/gitcommit/#TM1py.Objects.GitCommit.GitCommit","title":"<code>GitCommit(commit_id, summary, author)</code>","text":"<p>Abstraction of Git Commit</p> <p>Initialize GitCommit object</p> <p>Parameters:</p> Name Type Description Default <code>commit_id</code> <code>str</code> <p>id of the commit</p> required <code>summary</code> <code>str</code> <p>commit message</p> required <code>author</code> <code>str</code> <p>the author of the commit</p> required Source code in <code>TM1py/Objects/GitCommit.py</code> <pre><code>def __init__(self, commit_id: str, summary: str, author: str):\n    \"\"\"Initialize GitCommit object\n    :param commit_id: id of the commit\n    :param summary: commit message\n    :param author: the author of the commit\n    \"\"\"\n    self._commit_id = commit_id\n    self._summary = summary\n    self._author = author\n</code></pre>"},{"location":"reference/objects/gitcommit/#TM1py.Objects.GitCommit.GitCommit.author","title":"<code>author</code>  <code>property</code>","text":""},{"location":"reference/objects/gitcommit/#TM1py.Objects.GitCommit.GitCommit.commit_id","title":"<code>commit_id</code>  <code>property</code>","text":""},{"location":"reference/objects/gitcommit/#TM1py.Objects.GitCommit.GitCommit.summary","title":"<code>summary</code>  <code>property</code>","text":""},{"location":"reference/objects/gitplan/","title":"GitPlan","text":""},{"location":"reference/objects/gitplan/#TM1py.Objects.GitPlan.GitPlan","title":"<code>GitPlan(plan_id, branch, force)</code>","text":"<p>Base GitPlan abstraction</p> <p>Initialize GitPlan object</p> <p>Parameters:</p> Name Type Description Default <code>plan_id</code> <code>str</code> <p>id of the Plan</p> required <code>branch</code> <code>str</code> <p>current branch</p> required <code>force</code> <code>bool</code> <p>force git context reset</p> required Source code in <code>TM1py/Objects/GitPlan.py</code> <pre><code>def __init__(self, plan_id: str, branch: str, force: bool):\n    \"\"\"Initialize GitPlan object\n    :param plan_id: id of the Plan\n    :param branch: current branch\n    :param force: force git context reset\n    \"\"\"\n    self._plan_id = plan_id\n    self._branch = branch\n    self._force = force\n</code></pre>"},{"location":"reference/objects/gitplan/#TM1py.Objects.GitPlan.GitPlan.branch","title":"<code>branch</code>  <code>property</code>","text":""},{"location":"reference/objects/gitplan/#TM1py.Objects.GitPlan.GitPlan.force","title":"<code>force</code>  <code>property</code>","text":""},{"location":"reference/objects/gitplan/#TM1py.Objects.GitPlan.GitPlan.plan_id","title":"<code>plan_id</code>  <code>property</code>","text":""},{"location":"reference/objects/gitplan/#TM1py.Objects.GitPlan.GitPullPlan","title":"<code>GitPullPlan(plan_id, branch, force, commit, operations)</code>","text":"<p>               Bases: <code>GitPlan</code></p> <p>GitPushPlan abstraction based on GitPlan</p> <p>Initialize GitPushPlan object</p> <p>Parameters:</p> Name Type Description Default <code>plan_id</code> <code>str</code> <p>id of the PullPlan</p> required <code>branch</code> <code>str</code> <p>current branch to base the pullplan on</p> required <code>force</code> <code>bool</code> <p>force git context reset</p> required <code>commit</code> <code>GitCommit</code> <p>GitCommit of the commit to pull</p> required <code>operations</code> <code>List[str]</code> <p>list of changes made upon pulling</p> required Source code in <code>TM1py/Objects/GitPlan.py</code> <pre><code>def __init__(self, plan_id: str, branch: str, force: bool, commit: GitCommit, operations: List[str]):\n    \"\"\"Initialize GitPushPlan object\n    :param plan_id: id of the PullPlan\n    :param branch: current branch to base the pullplan on\n    :param force: force git context reset\n    :param commit: GitCommit of the commit to pull\n    :param operations: list of changes made upon pulling\n    \"\"\"\n    self._commit = commit\n    self._operations = operations\n\n    super().__init__(plan_id=plan_id, branch=branch, force=force)\n</code></pre>"},{"location":"reference/objects/gitplan/#TM1py.Objects.GitPlan.GitPullPlan.commit","title":"<code>commit</code>  <code>property</code>","text":""},{"location":"reference/objects/gitplan/#TM1py.Objects.GitPlan.GitPullPlan.operations","title":"<code>operations</code>  <code>property</code>","text":""},{"location":"reference/objects/gitplan/#TM1py.Objects.GitPlan.GitPushPlan","title":"<code>GitPushPlan(plan_id, branch, force, new_branch, new_commit, parent_commit, source_files)</code>","text":"<p>               Bases: <code>GitPlan</code></p> <p>GitPushPlan abstraction based on GitPlan</p> <p>Initialize GitPushPlan object</p> <p>Parameters:</p> Name Type Description Default <code>plan_id</code> <code>str</code> <p>id of the PushPlan</p> required <code>branch</code> <code>str</code> <p>current branch to base the pushplan on</p> required <code>force</code> <code>bool</code> <p>force git context reset</p> required <code>new_branch</code> <code>str</code> <p>the new branch that will be pushed to</p> required <code>new_commit</code> <code>GitCommit</code> <p>GitCommit of the new commit</p> required <code>parent_commit</code> <code>GitCommit</code> <p>The current commit in the branch</p> required <code>source_files</code> <code>List[str]</code> <p>list of included files in the push</p> required Source code in <code>TM1py/Objects/GitPlan.py</code> <pre><code>def __init__(\n    self,\n    plan_id: str,\n    branch: str,\n    force: bool,\n    new_branch: str,\n    new_commit: GitCommit,\n    parent_commit: GitCommit,\n    source_files: List[str],\n):\n    \"\"\"Initialize GitPushPlan object\n    :param plan_id: id of the PushPlan\n    :param branch: current branch to base the pushplan on\n    :param force: force git context reset\n    :param new_branch: the new branch that will be pushed to\n    :param new_commit: GitCommit of the new commit\n    :param parent_commit: The current commit in the branch\n    :param source_files: list of included files in the push\n    \"\"\"\n    self._new_branch = new_branch\n    self._new_commit = new_commit\n    self._parent_commit = parent_commit\n    self._source_files = source_files\n\n    super().__init__(plan_id=plan_id, branch=branch, force=force)\n</code></pre>"},{"location":"reference/objects/gitplan/#TM1py.Objects.GitPlan.GitPushPlan.new_branch","title":"<code>new_branch</code>  <code>property</code>","text":""},{"location":"reference/objects/gitplan/#TM1py.Objects.GitPlan.GitPushPlan.new_commit","title":"<code>new_commit</code>  <code>property</code>","text":""},{"location":"reference/objects/gitplan/#TM1py.Objects.GitPlan.GitPushPlan.parent_commit","title":"<code>parent_commit</code>  <code>property</code>","text":""},{"location":"reference/objects/gitplan/#TM1py.Objects.GitPlan.GitPushPlan.source_files","title":"<code>source_files</code>  <code>property</code>","text":""},{"location":"reference/objects/gitproject/","title":"GitProject","text":""},{"location":"reference/objects/gitproject/#TM1py.Objects.GitProject.TM1Project","title":"<code>TM1Project(version=1.0, name='', settings=None, tasks=None, objects=None, ignore=None, files=None, deployment=None, pre_push=None, post_push=None, pre_pull=None, post_pull=None)</code>","text":"<p>               Bases: <code>TM1Object</code></p> <p>Abstraction of Git tm1project</p> <p>Args:     version (int): description     settings (dict, optional): description. Defaults to None.     tasks (dict, optional): description. Defaults to None.     objects (dict, optional): description. Defaults to None.     ignore (list, optional): description. Defaults to None.     files (list, optional): description. Defaults to None.     deployment (dict, optional): description. Defaults to None.     pre_push (list, optional): description. Defaults to None.     post_push (list, optional): description. Defaults to None.     pre_pull (list, optional): description. Defaults to None.     post_pull (list, optional): description. Defaults to None.</p> Source code in <code>TM1py/Objects/GitProject.py</code> <pre><code>def __init__(\n    self,\n    version: int = 1.0,\n    name: Optional[str] = \"\",\n    settings: Optional[Dict] = None,\n    tasks: Optional[Dict[str, TM1ProjectTask]] = None,\n    objects: Optional[Dict] = None,\n    ignore: Optional[List] = None,\n    files: Optional[List] = None,\n    deployment: Optional[Dict] = None,\n    pre_push: Optional[List] = None,\n    post_push: Optional[List] = None,\n    pre_pull: Optional[List] = None,\n    post_pull: Optional[List] = None,\n):\n    \"\"\"\n\n    Args:\n        version (int): _description_\n        settings (dict, optional): _description_. Defaults to None.\n        tasks (dict, optional): _description_. Defaults to None.\n        objects (dict, optional): _description_. Defaults to None.\n        ignore (list, optional): _description_. Defaults to None.\n        files (list, optional): _description_. Defaults to None.\n        deployment (dict, optional): _description_. Defaults to None.\n        pre_push (list, optional): _description_. Defaults to None.\n        post_push (list, optional): _description_. Defaults to None.\n        pre_pull (list, optional): _description_. Defaults to None.\n        post_pull (list, optional): _description_. Defaults to None.\n    \"\"\"\n    self._version = version\n    self._name = name\n    self._settings = settings\n    self._tasks = tasks\n    self._objects = objects\n    self._ignore = ignore\n    self._files = files\n    self._deployment = deployment\n    self._pre_push = pre_push\n    self._post_push = post_push\n    self._pre_pull = pre_pull\n    self._post_pull = post_pull\n</code></pre>"},{"location":"reference/objects/gitproject/#TM1py.Objects.GitProject.TM1Project.body","title":"<code>body</code>  <code>property</code>","text":""},{"location":"reference/objects/gitproject/#TM1py.Objects.GitProject.TM1Project.body_as_dict","title":"<code>body_as_dict</code>  <code>property</code>","text":""},{"location":"reference/objects/gitproject/#TM1py.Objects.GitProject.TM1Project.deployment","title":"<code>deployment</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/gitproject/#TM1py.Objects.GitProject.TM1Project.ignore","title":"<code>ignore</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/gitproject/#TM1py.Objects.GitProject.TM1Project.name","title":"<code>name</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/gitproject/#TM1py.Objects.GitProject.TM1Project.objects","title":"<code>objects</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/gitproject/#TM1py.Objects.GitProject.TM1Project.post_pull","title":"<code>post_pull</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/gitproject/#TM1py.Objects.GitProject.TM1Project.post_push","title":"<code>post_push</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/gitproject/#TM1py.Objects.GitProject.TM1Project.pre_pull","title":"<code>pre_pull</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/gitproject/#TM1py.Objects.GitProject.TM1Project.pre_push","title":"<code>pre_push</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/gitproject/#TM1py.Objects.GitProject.TM1Project.settings","title":"<code>settings</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/gitproject/#TM1py.Objects.GitProject.TM1Project.tasks","title":"<code>tasks</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/gitproject/#TM1py.Objects.GitProject.TM1Project.version","title":"<code>version</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/gitproject/#TM1py.Objects.GitProject.TM1Project.add_deployment","title":"<code>add_deployment(deployment)</code>","text":"<p>\"Deployment is an OPTIONAL property. Each of its property defines a named deployment and its specific properties. All the tm1project properties can be redefined for a deployment, except Version. Those properties override the tm1project properties for the specific deployment.</p> <p>Current deployment is set by action GitInit.\"</p> Source code in <code>TM1py/Objects/GitProject.py</code> <pre><code>def add_deployment(self, deployment: \"TM1ProjectDeployment\"):\n    \"\"\"\n    \"Deployment is an OPTIONAL property. Each of its property defines a named deployment and its specific properties.\n    All the tm1project properties can be redefined for a deployment, except Version.\n    Those properties override the tm1project properties for the specific deployment.\n\n    Current deployment is set by action GitInit.\"\n\n    \"\"\"\n    if self._deployment is None:\n        self._deployment = dict()\n\n    if deployment._deployment_name in self._deployment:\n        raise ValueError(\n            f\"Deployment with name '{deployment._deployment_name}' already exists in TM1 project. \"\n            f\"Deployment name must be unique\"\n        )\n\n    self._deployment[deployment._deployment_name] = deployment\n</code></pre>"},{"location":"reference/objects/gitproject/#TM1py.Objects.GitProject.TM1Project.add_ignore","title":"<code>add_ignore(object_class, object_name)</code>","text":"<p>Ignore is an optional property in the tm1project It specifies the objects to be excluded from the source, if the object is newly created.</p> <p>Args:     object_class: class of the object e.g., \"Dimensions\"     object_name: name of the object e.g., \"Product\"</p> <p>For the <code>object_type</code> pass value like <code>Dimensions</code> or <code>Cubes/Views</code></p> <p>Wildcards (<code>*</code>) can be used in the <code>object_name</code>, if the object is not a control object.</p> <p>Example of the <code>ignore</code> property in the tm1project:     Exclude all the new Cubes and Views in the source, except Cube_A;     include control Process }Drill_Drill_A;     and exclude all the new Dimensions which has a name starting with 'Dim'</p> <pre><code>\"Ignore\":\n[\n  \"Cubes/Views\",\n  \"!Cubes('Cube_A')\",\n  \"!Processes('}Drill_Drill_A')\",\n  \"Dimensions('Dim*')\"\n]\n</code></pre> Source code in <code>TM1py/Objects/GitProject.py</code> <pre><code>def add_ignore(self, object_class: str, object_name: str):\n    \"\"\"\n    Ignore is an optional property in the tm1project\n    It specifies the objects to be excluded from the source, if the object is newly created.\n\n    Args:\n        object_class: class of the object e.g., \"Dimensions\"\n        object_name: name of the object e.g., \"Product\"\n\n    For the `object_type` pass value like `Dimensions` or `Cubes/Views`\n\n    Wildcards (`*`) can be used in the `object_name`, if the object is not a control object.\n\n    Example of the `ignore` property in the tm1project:\n        Exclude all the new Cubes and Views in the source, except Cube_A;\n        include control Process }Drill_Drill_A;\n        and exclude all the new Dimensions which has a name starting with 'Dim'\n\n        \"Ignore\":\n        [\n          \"Cubes/Views\",\n          \"!Cubes('Cube_A')\",\n          \"!Processes('}Drill_Drill_A')\",\n          \"Dimensions('Dim*')\"\n        ]\n    \"\"\"\n\n    if object_name.startswith(\"}\") and \"*\" in object_name:\n        raise ValueError(\"'*' character must not be used in object_name for control objects\")\n\n    if self.ignore is None:\n        self.ignore = []\n\n    ignore_entry = object_class\n    if object_name:\n        ignore_entry += f\"('{object_name}')\"\n\n    if ignore_entry not in self.ignore:\n        self.ignore.append(ignore_entry)\n</code></pre>"},{"location":"reference/objects/gitproject/#TM1py.Objects.GitProject.TM1Project.add_ignore_exceptions","title":"<code>add_ignore_exceptions(object_class, object_names)</code>","text":"<p>Specify exceptions to ignore policy. Wildcards (<code>*</code>) can not be used in the <code>object_name</code></p> <p>Args:     object_class: class of the object e.g., \"Dimensions\"     object_names: names of the objects e.g., [\"Product\", \"Customer\", \"Region\"]</p> <p>Example of the ignore property in the tm1project:     Exclude all Dimensions that start with 'Dim', except for dimension 'DimB', 'DimA'</p> <pre><code>\"Ignore\":\n[\n  \"Dimensions('Dim*')\",\n  \"!Dimensions('DimA')\",\n  \"!Dimensions('DimB')\"\n]\n</code></pre> Source code in <code>TM1py/Objects/GitProject.py</code> <pre><code>def add_ignore_exceptions(self, object_class: str, object_names: List[str]):\n    \"\"\"\n    Specify exceptions to ignore policy.\n    Wildcards (`*`) can not be used in the `object_name`\n\n    Args:\n        object_class: class of the object e.g., \"Dimensions\"\n        object_names: names of the objects e.g., [\"Product\", \"Customer\", \"Region\"]\n\n    Example of the ignore property in the tm1project:\n        Exclude all Dimensions that start with 'Dim', except for dimension 'DimB', 'DimA'\n\n        \"Ignore\":\n        [\n          \"Dimensions('Dim*')\",\n          \"!Dimensions('DimA')\",\n          \"!Dimensions('DimB')\"\n        ]\n    \"\"\"\n\n    for object_name in object_names:\n        if \"*\" in object_name:\n            raise ValueError(\"'*' character must not be used in object_name\")\n\n        ignore_entry = \"!\" + object_class\n        if object_name:\n            ignore_entry += f\"('{object_name}')\"\n\n        if self.ignore is None:\n            self.ignore = []\n\n        if ignore_entry not in self.ignore:\n            self.ignore.append(ignore_entry)\n</code></pre>"},{"location":"reference/objects/gitproject/#TM1py.Objects.GitProject.TM1Project.add_task","title":"<code>add_task(project_task)</code>","text":"Source code in <code>TM1py/Objects/GitProject.py</code> <pre><code>def add_task(self, project_task: TM1ProjectTask):\n    if self._tasks is None:\n        self._tasks = dict()\n\n    if project_task.task_name in self._tasks:\n        raise ValueError(\n            f\"Task with name '{project_task.task_name}' already exists in TM1 project. \" f\"Task name must be unique\"\n        )\n\n    self._tasks[project_task.task_name] = project_task\n</code></pre>"},{"location":"reference/objects/gitproject/#TM1py.Objects.GitProject.TM1Project.from_dict","title":"<code>from_dict(tm1project_as_dict)</code>  <code>classmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>tm1project_as_dict</code> <code>Dict</code> <p>Dictionary, tm1project as dictionary</p> required <p>Returns:</p> Type Description <code>TM1Project</code> <p>an instance of this class</p> Source code in <code>TM1py/Objects/GitProject.py</code> <pre><code>@classmethod\ndef from_dict(cls, tm1project_as_dict: Dict) -&gt; \"TM1Project\":\n    \"\"\"\n    :param tm1project_as_dict: Dictionary, tm1project as dictionary\n    :return: an instance of this class\n    \"\"\"\n    return cls(\n        version=tm1project_as_dict[\"Version\"],\n        name=tm1project_as_dict.get(\"Name\"),\n        settings=tm1project_as_dict.get(\"Settings\"),\n        tasks=(\n            {\n                task_name: TM1ProjectTask.from_dict(task_name, task)\n                for task_name, task in tm1project_as_dict.get(\"Tasks\").items()\n            }\n            if \"Tasks\" in tm1project_as_dict\n            else {}\n        ),\n        objects=tm1project_as_dict.get(\"Objects\"),\n        ignore=tm1project_as_dict.get(\"Ignore\"),\n        files=tm1project_as_dict.get(\"Files\"),\n        deployment=(\n            {\n                deployment_name: TM1ProjectDeployment.from_dict(deployment_name, deployment)\n                for deployment_name, deployment in tm1project_as_dict.get(\"Deployment\").items()\n            }\n            if \"Deployment\" in tm1project_as_dict\n            else {}\n        ),\n        pre_push=tm1project_as_dict.get(\"PrePush\"),\n        post_push=tm1project_as_dict.get(\"PostPush\"),\n        pre_pull=tm1project_as_dict.get(\"PrePull\"),\n        post_pull=tm1project_as_dict.get(\"PostPull\"),\n    )\n</code></pre>"},{"location":"reference/objects/gitproject/#TM1py.Objects.GitProject.TM1Project.from_file","title":"<code>from_file(filename)</code>  <code>classmethod</code>","text":"Source code in <code>TM1py/Objects/GitProject.py</code> <pre><code>@classmethod\ndef from_file(cls, filename: str) -&gt; \"TM1Project\":\n    with open(filename, \"r\") as file_object:\n        json_file = json.load(file_object)\n\n    return cls.from_dict(json_file)\n</code></pre>"},{"location":"reference/objects/gitproject/#TM1py.Objects.GitProject.TM1Project.from_json","title":"<code>from_json(tm1project_as_json)</code>  <code>classmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>tm1project_as_json</code> <code>str</code> <p>response of /!tm1project</p> required <p>Returns:</p> Type Description <code>TM1Project</code> <p>an instance of this class</p> Source code in <code>TM1py/Objects/GitProject.py</code> <pre><code>@classmethod\ndef from_json(cls, tm1project_as_json: str) -&gt; \"TM1Project\":\n    \"\"\"\n    :param tm1project_as_json: response of /!tm1project\n    :return: an instance of this class\n    \"\"\"\n    tm1project_as_dict = json.loads(tm1project_as_json)\n    return cls.from_dict(tm1project_as_dict=tm1project_as_dict)\n</code></pre>"},{"location":"reference/objects/gitproject/#TM1py.Objects.GitProject.TM1Project.include_all_attribute_dimensions","title":"<code>include_all_attribute_dimensions(tm1)</code>","text":"<p>Add an ignore-exception for each attribute dimension</p> Source code in <code>TM1py/Objects/GitProject.py</code> <pre><code>def include_all_attribute_dimensions(self, tm1):\n    \"\"\"\n    Add an ignore-exception for each attribute dimension\n\n    \"\"\"\n    attribute_dimensions = [\n        dimension\n        for dimension in tm1.dimensions.get_all_names()\n        if dimension.lower().startswith(\"}elementattributes_\")\n    ]\n\n    self.add_ignore_exceptions(\"Dimensions\", attribute_dimensions)\n</code></pre>"},{"location":"reference/objects/gitproject/#TM1py.Objects.GitProject.TM1Project.remove_deployment","title":"<code>remove_deployment(deployment_name)</code>","text":"Source code in <code>TM1py/Objects/GitProject.py</code> <pre><code>def remove_deployment(self, deployment_name: str):\n    if deployment_name in self._deployment:\n        self._deployment.pop(deployment_name, None)\n</code></pre>"},{"location":"reference/objects/gitproject/#TM1py.Objects.GitProject.TM1Project.remove_ignore","title":"<code>remove_ignore(ignore_entry)</code>","text":"Source code in <code>TM1py/Objects/GitProject.py</code> <pre><code>def remove_ignore(self, ignore_entry: str):\n    if ignore_entry in self.ignore:\n        self.ignore.remove(ignore_entry)\n</code></pre>"},{"location":"reference/objects/gitproject/#TM1py.Objects.GitProject.TM1Project.remove_task","title":"<code>remove_task(task_name)</code>","text":"Source code in <code>TM1py/Objects/GitProject.py</code> <pre><code>def remove_task(self, task_name: str):\n    if task_name in self._tasks:\n        self._tasks.pop(task_name, None)\n</code></pre>"},{"location":"reference/objects/gitproject/#TM1py.Objects.GitProject.TM1ProjectDeployment","title":"<code>TM1ProjectDeployment(deployment_name, settings=None, tasks=None, objects=None, ignore=None, files=None, pre_push=None, post_push=None, pre_pull=None, post_pull=None)</code>","text":"<p>               Bases: <code>TM1Project</code></p> Source code in <code>TM1py/Objects/GitProject.py</code> <pre><code>def __init__(\n    self,\n    deployment_name: str,\n    settings: Optional[Dict] = None,\n    tasks: Optional[Dict[str, TM1ProjectTask]] = None,\n    objects: Optional[Dict] = None,\n    ignore: Optional[List] = None,\n    files: Optional[List] = None,\n    pre_push: Optional[List] = None,\n    post_push: Optional[List] = None,\n    pre_pull: Optional[List] = None,\n    post_pull: Optional[List] = None,\n):\n    super().__init__(\n        version=None,\n        name=deployment_name,\n        settings=settings,\n        tasks=tasks,\n        objects=objects,\n        ignore=ignore,\n        files=files,\n        pre_push=pre_push,\n        post_push=post_push,\n        pre_pull=pre_pull,\n        post_pull=post_pull,\n    )\n\n    self._deployment_name = deployment_name\n</code></pre>"},{"location":"reference/objects/gitproject/#TM1py.Objects.GitProject.TM1ProjectDeployment.body","title":"<code>body</code>  <code>property</code>","text":""},{"location":"reference/objects/gitproject/#TM1py.Objects.GitProject.TM1ProjectDeployment.body_as_dict","title":"<code>body_as_dict</code>  <code>property</code>","text":""},{"location":"reference/objects/gitproject/#TM1py.Objects.GitProject.TM1ProjectDeployment.construct_body","title":"<code>construct_body()</code>","text":"Source code in <code>TM1py/Objects/GitProject.py</code> <pre><code>def construct_body(self) -&gt; Dict:\n    body_as_dict = {\n        \"Settings\": self._settings,\n        \"Tasks\": {name: task.construct_body() for name, task in self.tasks.items()} if self._tasks else None,\n        \"Objects\": self._objects,\n        \"Ignore\": self._ignore,\n        \"Files\": self._files,\n        \"PrePush\": self._pre_push,\n        \"PostPush\": self._post_push,\n        \"PrePull\": self._pre_pull,\n        \"PostPull\": self._post_pull,\n    }\n    return clean_null_terms(body_as_dict)\n</code></pre>"},{"location":"reference/objects/gitproject/#TM1py.Objects.GitProject.TM1ProjectDeployment.from_dict","title":"<code>from_dict(deployment_name, deployment)</code>  <code>classmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>deployment</code> <code>Dict</code> <p>Deployment as dictionary</p> required <p>Returns:</p> Type Description <code>TM1ProjectDeployment</code> <p>an instance of this class</p> Source code in <code>TM1py/Objects/GitProject.py</code> <pre><code>@classmethod\ndef from_dict(cls, deployment_name: str, deployment: Dict) -&gt; \"TM1ProjectDeployment\":\n    \"\"\"\n    :param deployment: Deployment as dictionary\n    :return: an instance of this class\n    \"\"\"\n    return cls(\n        deployment_name=deployment_name,\n        settings=deployment.get(\"Settings\"),\n        tasks={\n            task_name: TM1ProjectTask.from_dict(task_name, task)\n            for task_name, task in deployment.get(\"Tasks\").items()\n        },\n        objects=deployment.get(\"Objects\"),\n        ignore=deployment.get(\"Ignore\"),\n        files=deployment.get(\"Files\"),\n        pre_push=deployment.get(\"PrePush\"),\n        post_push=deployment.get(\"PostPush\"),\n        pre_pull=deployment.get(\"PrePull\"),\n        post_pull=deployment.get(\"PostPull\"),\n    )\n</code></pre>"},{"location":"reference/objects/gitproject/#TM1py.Objects.GitProject.TM1ProjectTask","title":"<code>TM1ProjectTask(task_name, chore=None, process=None, parameters=None, dependencies=None, precondition=None)</code>","text":"<p>Defines an action that executes a Process or a Chore with certain parameters.</p> <p>A Task MUST either have a Process or a Chore property. The property specifies the reference of the Process or Chore to be executed. The Process or Chore MUST be visible.</p> <p>A Task MAY have a Parameters property. The property specifies the parameters to be passed to the Process. This property MUST NOT be specified if the task is to execute a Chore.</p> <p>A Task MAY have a Dependencies property. The property specifies an array of URIs of tasks or objects, which will be executed or loaded, respectively, before executing the current task. E.g.: [\"Cubes('Cube_A')\", \"Dimensions('Dimension_C')\"]</p> <p>A Task MAY have a Precondition property. The server only executes a Task when either the precondition is not specified, or it is evaluated to TRUE.</p> <p>The server only executes a Task one time during a deployment.</p> Source code in <code>TM1py/Objects/GitProject.py</code> <pre><code>def __init__(\n    self,\n    task_name: str,\n    chore: str = None,\n    process: str = None,\n    parameters: List[Dict[str, str]] = None,\n    dependencies: List[str] = None,\n    precondition: str = None,\n):\n    \"\"\"\n    Defines an action that executes a Process or a Chore with certain parameters.\n\n    A Task MUST either have a Process or a Chore property.\n    The property specifies the reference of the Process or Chore to be executed.\n    The Process or Chore MUST be visible.\n\n    A Task MAY have a Parameters property.\n    The property specifies the parameters to be passed to the Process.\n    This property MUST NOT be specified if the task is to execute a Chore.\n\n    A Task MAY have a Dependencies property.\n    The property specifies an array of URIs of tasks or objects,\n    which will be executed or loaded, respectively, before executing the current task.\n    E.g.: [\"Cubes('Cube_A')\", \"Dimensions('Dimension_C')\"]\n\n    A Task MAY have a Precondition property.\n    The server only executes a Task when either the precondition is not specified, or it is evaluated to TRUE.\n\n    The server only executes a Task one time during a deployment.\n    \"\"\"\n\n    if not any([chore, process]):\n        raise ValueError(\"TM1ProjectTask must either have a 'Process' or a 'Chore' property\")\n\n    if all([chore, process]):\n        raise ValueError(\"TM1ProjectTask must not have a 'Chore' and 'Process' property\")\n\n    if all([chore, parameters]):\n        raise ValueError(\"TM1ProjectTask must not have a 'Chore' and 'Parameters' property\")\n\n    self.task_name = task_name\n    self.chore = chore\n    self.process = process\n    self.parameters = parameters\n    self.dependencies = dependencies\n    self.precondition = precondition\n</code></pre>"},{"location":"reference/objects/gitproject/#TM1py.Objects.GitProject.TM1ProjectTask.chore","title":"<code>chore = chore</code>  <code>instance-attribute</code>","text":""},{"location":"reference/objects/gitproject/#TM1py.Objects.GitProject.TM1ProjectTask.dependencies","title":"<code>dependencies = dependencies</code>  <code>instance-attribute</code>","text":""},{"location":"reference/objects/gitproject/#TM1py.Objects.GitProject.TM1ProjectTask.parameters","title":"<code>parameters = parameters</code>  <code>instance-attribute</code>","text":""},{"location":"reference/objects/gitproject/#TM1py.Objects.GitProject.TM1ProjectTask.precondition","title":"<code>precondition = precondition</code>  <code>instance-attribute</code>","text":""},{"location":"reference/objects/gitproject/#TM1py.Objects.GitProject.TM1ProjectTask.process","title":"<code>process = process</code>  <code>instance-attribute</code>","text":""},{"location":"reference/objects/gitproject/#TM1py.Objects.GitProject.TM1ProjectTask.task_name","title":"<code>task_name = task_name</code>  <code>instance-attribute</code>","text":""},{"location":"reference/objects/gitproject/#TM1py.Objects.GitProject.TM1ProjectTask.construct_body","title":"<code>construct_body()</code>","text":"Source code in <code>TM1py/Objects/GitProject.py</code> <pre><code>def construct_body(self) -&gt; Dict:\n    body = dict()\n\n    if self.chore:\n        if not self.chore.startswith(\"Chores('\"):\n            body = {\"Chore\": f\"Chores('{self.chore}')\"}\n        else:\n            body[\"Chore\"] = self.chore\n    else:\n        if not self.process.startswith(\"Processes('\"):\n            body = {\n                \"Process\": f\"Processes('{self.process}')\",\n            }\n        else:\n            body[\"Process\"] = self.process\n        body.update({\"Parameters\": self.parameters})\n\n    if self.dependencies:\n        body[\"Dependencies\"] = self.dependencies\n\n    return body\n</code></pre>"},{"location":"reference/objects/gitproject/#TM1py.Objects.GitProject.TM1ProjectTask.from_dict","title":"<code>from_dict(task_name, task)</code>  <code>classmethod</code>","text":"Source code in <code>TM1py/Objects/GitProject.py</code> <pre><code>@classmethod\ndef from_dict(cls, task_name: str, task: Dict):\n    return cls(\n        task_name=task_name,\n        chore=task.get(\"Chore\"),\n        process=task.get(\"Process\"),\n        parameters=task.get(\"Parameters\"),\n        dependencies=task.get(\"Dependencies\"),\n        precondition=task.get(\"Precondition\"),\n    )\n</code></pre>"},{"location":"reference/objects/gitproject/#TM1py.Objects.GitProject.clean_null_terms","title":"<code>clean_null_terms(d)</code>","text":"Source code in <code>TM1py/Objects/GitProject.py</code> <pre><code>def clean_null_terms(d: Dict):\n    clean = {}\n    for k, v in d.items():\n        if isinstance(v, dict):\n            nested = clean_null_terms(v)\n            if len(nested.keys()) &gt; 0:\n                clean[k] = nested\n        elif isinstance(v, list) and not d[k]:\n            continue\n        elif v is not None:\n            clean[k] = v\n    return clean\n</code></pre>"},{"location":"reference/objects/gitremote/","title":"GitRemote","text":""},{"location":"reference/objects/gitremote/#TM1py.Objects.GitRemote.GitRemote","title":"<code>GitRemote(connected, branches, tags)</code>","text":"<p>Abstraction of GitRemote</p> <p>Initialize GitRemote object</p> <p>Parameters:</p> Name Type Description Default <code>connected</code> <code>bool</code> <p>is Git connected to remote</p> required <code>branches</code> <code>List[str]</code> <p>list of remote branches</p> required <code>tags</code> <code>List[str]</code> <p>list of remote tags</p> required Source code in <code>TM1py/Objects/GitRemote.py</code> <pre><code>def __init__(self, connected: bool, branches: List[str], tags: List[str]):\n    \"\"\"Initialize GitRemote object\n    :param connected: is Git connected to remote\n    :param branches: list of remote branches\n    :param tags: list of remote tags\n    \"\"\"\n    self._connected = connected\n    self._branches = branches\n    self._tags = tags\n</code></pre>"},{"location":"reference/objects/gitremote/#TM1py.Objects.GitRemote.GitRemote.branches","title":"<code>branches</code>  <code>property</code>","text":""},{"location":"reference/objects/gitremote/#TM1py.Objects.GitRemote.GitRemote.connected","title":"<code>connected</code>  <code>property</code>","text":""},{"location":"reference/objects/gitremote/#TM1py.Objects.GitRemote.GitRemote.tags","title":"<code>tags</code>  <code>property</code>","text":""},{"location":"reference/objects/hierarchy/","title":"Hierarchy","text":""},{"location":"reference/objects/hierarchy/#TM1py.Objects.Hierarchy.Hierarchy","title":"<code>Hierarchy(name, dimension_name, elements=None, element_attributes=None, edges=None, subsets=None, structure=None, default_member=None)</code>","text":"<p>               Bases: <code>TM1Object</code></p> <p>Abstraction of TM1 Hierarchy Requires reference to a Dimension</p> <p>Elements modeled as a Dictionary where key is the element name and value an instance of TM1py.Element {     'US': instance of TM1py.Element,     'CN': instance of TM1py.Element,     'AU': instance of TM1py.Element }</p> <p>ElementAttributes of type TM1py.Objects.ElementAttribute</p> <p>Edges are represented as a TM1py.Utils.CaseAndSpaceInsensitiveTupleDict: {     (parent1, component1) : 10,     (parent1, component2) : 30 }</p> <p>Subsets is list of type TM1py.Subset</p> Source code in <code>TM1py/Objects/Hierarchy.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    dimension_name: str,\n    elements: Optional[Iterable[\"Element\"]] = None,\n    element_attributes: Optional[Iterable[\"ElementAttribute\"]] = None,\n    edges: Optional[\"Dict\"] = None,\n    subsets: Optional[Iterable[str]] = None,\n    structure: Optional[int] = None,\n    default_member: Optional[str] = None,\n):\n\n    self._name = name\n    self._dimension_name = None\n    self.dimension_name = dimension_name\n    self._elements: Dict[str, Element] = CaseAndSpaceInsensitiveDict()\n    if elements:\n        for elem in elements:\n            self._elements[elem.name] = elem\n    self._element_attributes = list(element_attributes) if element_attributes else []\n    self._edges = CaseAndSpaceInsensitiveTuplesDict(edges) if edges else CaseAndSpaceInsensitiveTuplesDict()\n    self._subsets = list(subsets) if subsets else []\n    # balanced is true, false or None (in versions &lt; TM1 11)\n    self._balanced = False if not structure else structure == 0\n    self._default_member = default_member\n</code></pre>"},{"location":"reference/objects/hierarchy/#TM1py.Objects.Hierarchy.Hierarchy.balanced","title":"<code>balanced</code>  <code>property</code>","text":""},{"location":"reference/objects/hierarchy/#TM1py.Objects.Hierarchy.Hierarchy.body","title":"<code>body</code>  <code>property</code>","text":""},{"location":"reference/objects/hierarchy/#TM1py.Objects.Hierarchy.Hierarchy.body_as_dict","title":"<code>body_as_dict</code>  <code>property</code>","text":""},{"location":"reference/objects/hierarchy/#TM1py.Objects.Hierarchy.Hierarchy.default_member","title":"<code>default_member</code>  <code>property</code>","text":""},{"location":"reference/objects/hierarchy/#TM1py.Objects.Hierarchy.Hierarchy.dimension_name","title":"<code>dimension_name</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/hierarchy/#TM1py.Objects.Hierarchy.Hierarchy.edges","title":"<code>edges</code>  <code>property</code>","text":""},{"location":"reference/objects/hierarchy/#TM1py.Objects.Hierarchy.Hierarchy.element_attributes","title":"<code>element_attributes</code>  <code>property</code>","text":""},{"location":"reference/objects/hierarchy/#TM1py.Objects.Hierarchy.Hierarchy.elements","title":"<code>elements</code>  <code>property</code>","text":""},{"location":"reference/objects/hierarchy/#TM1py.Objects.Hierarchy.Hierarchy.name","title":"<code>name</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/hierarchy/#TM1py.Objects.Hierarchy.Hierarchy.subsets","title":"<code>subsets</code>  <code>property</code>","text":""},{"location":"reference/objects/hierarchy/#TM1py.Objects.Hierarchy.Hierarchy.__contains__","title":"<code>__contains__(item)</code>","text":"Source code in <code>TM1py/Objects/Hierarchy.py</code> <pre><code>def __contains__(self, item):\n    return self.contains_element(item)\n</code></pre>"},{"location":"reference/objects/hierarchy/#TM1py.Objects.Hierarchy.Hierarchy.__getitem__","title":"<code>__getitem__(item)</code>","text":"Source code in <code>TM1py/Objects/Hierarchy.py</code> <pre><code>def __getitem__(self, item):\n    return self.get_element(item)\n</code></pre>"},{"location":"reference/objects/hierarchy/#TM1py.Objects.Hierarchy.Hierarchy.__iter__","title":"<code>__iter__()</code>","text":"Source code in <code>TM1py/Objects/Hierarchy.py</code> <pre><code>def __iter__(self):\n    return iter(self._elements.values())\n</code></pre>"},{"location":"reference/objects/hierarchy/#TM1py.Objects.Hierarchy.Hierarchy.__len__","title":"<code>__len__()</code>","text":"Source code in <code>TM1py/Objects/Hierarchy.py</code> <pre><code>def __len__(self):\n    return len(self._elements)\n</code></pre>"},{"location":"reference/objects/hierarchy/#TM1py.Objects.Hierarchy.Hierarchy.add_component","title":"<code>add_component(parent_name, component_name, weight)</code>","text":"Source code in <code>TM1py/Objects/Hierarchy.py</code> <pre><code>def add_component(self, parent_name: str, component_name: str, weight: int):\n    if parent_name not in self._elements:\n        raise ValueError(f\"Parent '{parent_name}' does not exist in hierarchy\")\n    if self._elements[parent_name].element_type != Element.Types.CONSOLIDATED:\n        raise ValueError(f\"Parent '{parent_name}' is not of type 'Consolidated'\")\n\n    if component_name not in self.elements:\n        self.add_element(component_name, \"Numeric\")\n    elif self._elements[component_name].element_type == Element.Types.STRING:\n        raise ValueError(f\"Component '{component_name}' must not be of type 'String'\")\n\n    self.add_edge(parent_name, component_name, weight)\n</code></pre>"},{"location":"reference/objects/hierarchy/#TM1py.Objects.Hierarchy.Hierarchy.add_edge","title":"<code>add_edge(parent, component, weight)</code>","text":"Source code in <code>TM1py/Objects/Hierarchy.py</code> <pre><code>def add_edge(self, parent: str, component: str, weight: float):\n    self._edges[(parent, component)] = weight\n</code></pre>"},{"location":"reference/objects/hierarchy/#TM1py.Objects.Hierarchy.Hierarchy.add_element","title":"<code>add_element(element_name, element_type)</code>","text":"Source code in <code>TM1py/Objects/Hierarchy.py</code> <pre><code>def add_element(self, element_name: str, element_type: Union[str, Element.Types]):\n    if element_name in self._elements:\n        raise ValueError(\"Element name must be unique\")\n\n    self._elements[element_name] = Element(name=element_name, element_type=element_type)\n</code></pre>"},{"location":"reference/objects/hierarchy/#TM1py.Objects.Hierarchy.Hierarchy.add_element_attribute","title":"<code>add_element_attribute(name, attribute_type)</code>","text":"Source code in <code>TM1py/Objects/Hierarchy.py</code> <pre><code>def add_element_attribute(self, name: str, attribute_type: str):\n    attribute = ElementAttribute(name, attribute_type)\n    if attribute not in self.element_attributes:\n        self.element_attributes.append(attribute)\n</code></pre>"},{"location":"reference/objects/hierarchy/#TM1py.Objects.Hierarchy.Hierarchy.contains_element","title":"<code>contains_element(element_name)</code>","text":"Source code in <code>TM1py/Objects/Hierarchy.py</code> <pre><code>def contains_element(self, element_name: str) -&gt; bool:\n    return element_name in self._elements\n</code></pre>"},{"location":"reference/objects/hierarchy/#TM1py.Objects.Hierarchy.Hierarchy.from_dict","title":"<code>from_dict(hierarchy_as_dict, dimension_name=None)</code>  <code>classmethod</code>","text":"Source code in <code>TM1py/Objects/Hierarchy.py</code> <pre><code>@classmethod\ndef from_dict(cls, hierarchy_as_dict: Dict, dimension_name: str = None) -&gt; \"Hierarchy\":\n    # Build the Dictionary for the edges\n    edges = CaseAndSpaceInsensitiveTuplesDict(\n        {(edge[\"ParentName\"], edge[\"ComponentName\"]): edge[\"Weight\"] for edge in hierarchy_as_dict[\"Edges\"]}\n    )\n\n    if not dimension_name:\n        dimension_name = hierarchy_as_dict[\"UniqueName\"][1 : hierarchy_as_dict[\"UniqueName\"].find(\"].[\")]\n\n    return cls(\n        name=hierarchy_as_dict[\"Name\"],\n        dimension_name=dimension_name,\n        elements=[Element.from_dict(elem) for elem in hierarchy_as_dict[\"Elements\"]],\n        element_attributes=[\n            ElementAttribute(ea[\"Name\"], ea[\"Type\"]) for ea in hierarchy_as_dict.get(\"ElementAttributes\", [])\n        ],\n        edges=edges,\n        subsets=[subset[\"Name\"] for subset in hierarchy_as_dict.get(\"Subsets\", [])],\n        structure=hierarchy_as_dict[\"Structure\"] if \"Structure\" in hierarchy_as_dict else None,\n        default_member=(\n            hierarchy_as_dict[\"DefaultMember\"][\"Name\"] if hierarchy_as_dict.get(\"DefaultMember\", None) else None\n        ),\n    )\n</code></pre>"},{"location":"reference/objects/hierarchy/#TM1py.Objects.Hierarchy.Hierarchy.get_ancestor_edges","title":"<code>get_ancestor_edges(element_name, recursive=False)</code>","text":"Source code in <code>TM1py/Objects/Hierarchy.py</code> <pre><code>def get_ancestor_edges(self, element_name: str, recursive: bool = False) -&gt; Dict:\n    ancestor_edges = dict()\n\n    for (parent, component), weight in self._edges.items():\n        if not case_and_space_insensitive_equals(component, element_name):\n            continue\n\n        ancestor_edges[parent, component] = weight\n        ancestor: Element = self.elements[component]\n\n        if recursive:\n            ancestor_edges.update(self.get_ancestor_edges(ancestor.name, True))\n\n    return ancestor_edges\n</code></pre>"},{"location":"reference/objects/hierarchy/#TM1py.Objects.Hierarchy.Hierarchy.get_ancestors","title":"<code>get_ancestors(element_name, recursive=False)</code>","text":"Source code in <code>TM1py/Objects/Hierarchy.py</code> <pre><code>def get_ancestors(self, element_name: str, recursive: bool = False) -&gt; Set[Element]:\n    ancestors = set()\n\n    for parent, component in self._edges:\n        if not case_and_space_insensitive_equals(component, element_name):\n            continue\n\n        ancestor: Element = self.elements[parent]\n        ancestors.add(ancestor)\n\n        if recursive:\n            ancestors = ancestors.union(self.get_ancestors(ancestor.name, True))\n    return ancestors\n</code></pre>"},{"location":"reference/objects/hierarchy/#TM1py.Objects.Hierarchy.Hierarchy.get_descendant_edges","title":"<code>get_descendant_edges(element_name, recursive=False)</code>","text":"Source code in <code>TM1py/Objects/Hierarchy.py</code> <pre><code>def get_descendant_edges(self, element_name: str, recursive: bool = False) -&gt; Dict:\n    descendant_edges = dict()\n\n    for (parent, component), weight in self._edges.items():\n        if not case_and_space_insensitive_equals(parent, element_name):\n            continue\n\n        descendant_edges[parent, component] = weight\n        descendant: Element = self.elements[component]\n\n        if recursive and descendant.element_type == Element.Types.CONSOLIDATED:\n            descendant_edges.update(self.get_descendant_edges(descendant.name, True))\n\n    return descendant_edges\n</code></pre>"},{"location":"reference/objects/hierarchy/#TM1py.Objects.Hierarchy.Hierarchy.get_descendants","title":"<code>get_descendants(element_name, recursive=False, leaves_only=False)</code>","text":"Source code in <code>TM1py/Objects/Hierarchy.py</code> <pre><code>def get_descendants(self, element_name: str, recursive: bool = False, leaves_only=False) -&gt; Set[Element]:\n    descendants = set()\n\n    for parent, component in self._edges:\n        if not case_and_space_insensitive_equals(parent, element_name):\n            continue\n\n        descendant: Element = self.elements[component]\n        if not leaves_only:\n            descendants.add(descendant)\n        else:\n            if descendant.element_type == Element.Types.NUMERIC:\n                descendants.add(descendant)\n\n        if recursive and descendant.element_type == Element.Types.CONSOLIDATED:\n            descendants = descendants.union(self.get_descendants(descendant.name, True, leaves_only=leaves_only))\n    return descendants\n</code></pre>"},{"location":"reference/objects/hierarchy/#TM1py.Objects.Hierarchy.Hierarchy.get_element","title":"<code>get_element(element_name)</code>","text":"Source code in <code>TM1py/Objects/Hierarchy.py</code> <pre><code>def get_element(self, element_name: str) -&gt; Element:\n    if element_name in self._elements:\n        return self._elements[element_name]\n    else:\n        raise ValueError(\"Element: {} not found in Hierarchy: {}\".format(element_name, self.name))\n</code></pre>"},{"location":"reference/objects/hierarchy/#TM1py.Objects.Hierarchy.Hierarchy.remove_all_edges","title":"<code>remove_all_edges()</code>","text":"Source code in <code>TM1py/Objects/Hierarchy.py</code> <pre><code>def remove_all_edges(self):\n    self._edges = CaseAndSpaceInsensitiveTuplesDict()\n</code></pre>"},{"location":"reference/objects/hierarchy/#TM1py.Objects.Hierarchy.Hierarchy.remove_all_elements","title":"<code>remove_all_elements()</code>","text":"Source code in <code>TM1py/Objects/Hierarchy.py</code> <pre><code>def remove_all_elements(self):\n    self._elements = CaseAndSpaceInsensitiveDict()\n    self.remove_all_edges()\n</code></pre>"},{"location":"reference/objects/hierarchy/#TM1py.Objects.Hierarchy.Hierarchy.remove_edge","title":"<code>remove_edge(parent, component)</code>","text":"Source code in <code>TM1py/Objects/Hierarchy.py</code> <pre><code>def remove_edge(self, parent: str, component: str):\n    if (parent, component) in self.edges:\n        del self.edges[(parent, component)]\n</code></pre>"},{"location":"reference/objects/hierarchy/#TM1py.Objects.Hierarchy.Hierarchy.remove_edges","title":"<code>remove_edges(edges)</code>","text":"Source code in <code>TM1py/Objects/Hierarchy.py</code> <pre><code>def remove_edges(self, edges: Iterable[Tuple[str, str]]):\n    for edge in edges:\n        self.remove_edge(*edge)\n</code></pre>"},{"location":"reference/objects/hierarchy/#TM1py.Objects.Hierarchy.Hierarchy.remove_edges_related_to_element","title":"<code>remove_edges_related_to_element(element_name)</code>","text":"Source code in <code>TM1py/Objects/Hierarchy.py</code> <pre><code>def remove_edges_related_to_element(self, element_name: str):\n    element_name_adjusted = lower_and_drop_spaces(element_name)\n    edges_to_remove = set()\n    for edge in self._edges.adjusted_keys():\n        if element_name_adjusted in edge:\n            edges_to_remove.add(edge)\n    self.remove_edges(edges=edges_to_remove)\n</code></pre>"},{"location":"reference/objects/hierarchy/#TM1py.Objects.Hierarchy.Hierarchy.remove_element","title":"<code>remove_element(element_name)</code>","text":"Source code in <code>TM1py/Objects/Hierarchy.py</code> <pre><code>def remove_element(self, element_name: str):\n    if element_name not in self._elements:\n        return\n    del self._elements[element_name]\n    self.remove_edges_related_to_element(element_name=element_name)\n</code></pre>"},{"location":"reference/objects/hierarchy/#TM1py.Objects.Hierarchy.Hierarchy.remove_element_attribute","title":"<code>remove_element_attribute(name)</code>","text":"Source code in <code>TM1py/Objects/Hierarchy.py</code> <pre><code>def remove_element_attribute(self, name: str):\n    self._element_attributes = [\n        element_attribute\n        for element_attribute in self.element_attributes\n        if not case_and_space_insensitive_equals(element_attribute.name, name)\n    ]\n</code></pre>"},{"location":"reference/objects/hierarchy/#TM1py.Objects.Hierarchy.Hierarchy.replace_element","title":"<code>replace_element(old_element_name, new_element_name)</code>","text":"<p>Substitute one element in the hierarchy structure, so that all edges are moved from the old element to the new element.</p> Source code in <code>TM1py/Objects/Hierarchy.py</code> <pre><code>def replace_element(self, old_element_name: str, new_element_name: str):\n    \"\"\"\n    Substitute one element in the hierarchy structure,\n    so that all edges are moved from the old element to the new element.\n    \"\"\"\n    if old_element_name not in self.elements:\n        raise ValueError(f\"Element '{old_element_name}' does not exist in hierarchy\")\n\n    if new_element_name in self.elements:\n        raise ValueError(f\"Element '{new_element_name}' already exists in hierarchy\")\n\n    element = self.get_element(old_element_name)\n    ancestor_edges = self.get_ancestor_edges(old_element_name, recursive=False)\n    descendant_edges = self.get_descendant_edges(element_name=old_element_name, recursive=False)\n\n    self.remove_element(element_name=old_element_name)\n\n    self.add_element(element_name=new_element_name, element_type=element.element_type)\n\n    for (ancestor, _), weight in ancestor_edges.items():\n        self.add_edge(parent=ancestor, component=new_element_name, weight=weight)\n    for (_, descendant), weight in descendant_edges.items():\n        self.add_edge(parent=new_element_name, component=descendant, weight=weight)\n</code></pre>"},{"location":"reference/objects/hierarchy/#TM1py.Objects.Hierarchy.Hierarchy.update_edge","title":"<code>update_edge(parent, component, weight)</code>","text":"Source code in <code>TM1py/Objects/Hierarchy.py</code> <pre><code>def update_edge(self, parent: str, component: str, weight: float):\n    self._edges[(parent, component)] = weight\n</code></pre>"},{"location":"reference/objects/hierarchy/#TM1py.Objects.Hierarchy.Hierarchy.update_element","title":"<code>update_element(element_name, element_type)</code>","text":"Source code in <code>TM1py/Objects/Hierarchy.py</code> <pre><code>def update_element(self, element_name: str, element_type: Union[str, Element.Types]):\n    self._elements[element_name].element_type = element_type\n</code></pre>"},{"location":"reference/objects/mdxview/","title":"MDXView","text":""},{"location":"reference/objects/mdxview/#TM1py.Objects.MDXView.MDXView","title":"<code>MDXView(cube_name, view_name, MDX)</code>","text":"<p>               Bases: <code>View</code></p> <p>Abstraction on TM1 MDX view</p> <p>IMPORTANT. MDXViews can't be seen through the old TM1 clients (Archict, Perspectives). They do exist though!</p> Source code in <code>TM1py/Objects/MDXView.py</code> <pre><code>def __init__(self, cube_name: str, view_name: str, MDX: str):\n    View.__init__(self, cube_name, view_name)\n    self._mdx = MDX\n</code></pre>"},{"location":"reference/objects/mdxview/#TM1py.Objects.MDXView.MDXView.MDX","title":"<code>MDX</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/mdxview/#TM1py.Objects.MDXView.MDXView.body","title":"<code>body</code>  <code>property</code>","text":""},{"location":"reference/objects/mdxview/#TM1py.Objects.MDXView.MDXView.mdx","title":"<code>mdx</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/mdxview/#TM1py.Objects.MDXView.MDXView.construct_body","title":"<code>construct_body()</code>","text":"Source code in <code>TM1py/Objects/MDXView.py</code> <pre><code>def construct_body(self) -&gt; str:\n    mdx_view_as_dict = collections.OrderedDict()\n    mdx_view_as_dict[\"@odata.type\"] = \"ibm.tm1.api.v1.MDXView\"\n    mdx_view_as_dict[\"Name\"] = self._name\n    mdx_view_as_dict[\"MDX\"] = self._mdx\n    return json.dumps(mdx_view_as_dict, ensure_ascii=False)\n</code></pre>"},{"location":"reference/objects/mdxview/#TM1py.Objects.MDXView.MDXView.from_dict","title":"<code>from_dict(view_as_dict, cube_name=None)</code>  <code>classmethod</code>","text":"Source code in <code>TM1py/Objects/MDXView.py</code> <pre><code>@classmethod\ndef from_dict(cls, view_as_dict: Dict, cube_name: str = None) -&gt; \"MDXView\":\n    return cls(\n        cube_name=view_as_dict[\"Cube\"][\"Name\"] if not cube_name else cube_name,\n        view_name=view_as_dict[\"Name\"],\n        MDX=view_as_dict[\"MDX\"],\n    )\n</code></pre>"},{"location":"reference/objects/mdxview/#TM1py.Objects.MDXView.MDXView.from_json","title":"<code>from_json(view_as_json, cube_name=None)</code>  <code>classmethod</code>","text":"Source code in <code>TM1py/Objects/MDXView.py</code> <pre><code>@classmethod\ndef from_json(cls, view_as_json: str, cube_name: Optional[str] = None) -&gt; \"MDXView\":\n    view_as_dict = json.loads(view_as_json)\n    return cls.from_dict(view_as_dict, cube_name)\n</code></pre>"},{"location":"reference/objects/mdxview/#TM1py.Objects.MDXView.MDXView.substitute_title","title":"<code>substitute_title(dimension, hierarchy, element)</code>","text":"<p>dimension and hierarchy name are space sensitive!</p> <p>Parameters:</p> Name Type Description Default <code>dimension</code> <code>str</code> required <code>hierarchy</code> <code>str</code> required <code>element</code> <code>str</code> required <p>Returns:</p> Type Description Source code in <code>TM1py/Objects/MDXView.py</code> <pre><code>def substitute_title(self, dimension: str, hierarchy: str, element: str):\n    \"\"\"dimension and hierarchy name are space sensitive!\n\n    :param dimension:\n    :param hierarchy:\n    :param element:\n    :return:\n    \"\"\"\n    pattern = re.compile(r\"\\[\" + dimension + r\"\\].\\[\" + hierarchy + r\"\\].\\[(.*?)\\]\", re.IGNORECASE)\n    findings = re.findall(pattern, self._mdx)\n\n    if findings:\n        self._mdx = re.sub(pattern=pattern, repl=f\"[{dimension}].[{hierarchy}].[{element}]\", string=self._mdx)\n        return\n\n    if hierarchy is None or case_and_space_insensitive_equals(dimension, hierarchy):\n        pattern = re.compile(r\"\\[\" + dimension + r\"\\].\\[(.*?)\\]\", re.IGNORECASE)\n        findings = re.findall(pattern, self._mdx)\n        if findings:\n            self._mdx = re.sub(pattern=pattern, repl=f\"[{dimension}].[{element}]\", string=self._mdx)\n            return\n\n    raise ValueError(f\"No selection in title with dimension: '{dimension}' and hierarchy: '{hierarchy}'\")\n</code></pre>"},{"location":"reference/objects/nativeview/","title":"NativeView","text":""},{"location":"reference/objects/nativeview/#TM1py.Objects.NativeView.NativeView","title":"<code>NativeView(cube_name, view_name, suppress_empty_columns=False, suppress_empty_rows=False, format_string='0.#########', titles=None, columns=None, rows=None)</code>","text":"<p>               Bases: <code>View</code></p> <p>Abstraction of TM1 NativeView (classic cube view)</p> <p>:Notes:     Complete, functional and tested</p> Source code in <code>TM1py/Objects/NativeView.py</code> <pre><code>def __init__(\n    self,\n    cube_name: str,\n    view_name: str,\n    suppress_empty_columns: Optional[bool] = False,\n    suppress_empty_rows: Optional[bool] = False,\n    format_string: Optional[str] = \"0.#########\",\n    titles: Optional[Iterable[ViewTitleSelection]] = None,\n    columns: Optional[Iterable[ViewAxisSelection]] = None,\n    rows: Optional[Iterable[ViewAxisSelection]] = None,\n):\n    super().__init__(cube_name, view_name)\n    self._suppress_empty_columns = suppress_empty_columns\n    self._suppress_empty_rows = suppress_empty_rows\n    self._format_string = format_string\n    self._titles = list(titles) if titles else []\n    self._columns = list(columns) if columns else []\n    self._rows = list(rows) if rows else []\n</code></pre>"},{"location":"reference/objects/nativeview/#TM1py.Objects.NativeView.NativeView.MDX","title":"<code>MDX</code>  <code>property</code>","text":""},{"location":"reference/objects/nativeview/#TM1py.Objects.NativeView.NativeView.as_MDX","title":"<code>as_MDX</code>  <code>property</code>","text":"<p>Build a valid MDX Query from an Existing cubeview. Takes Zero suppression into account. Throws an Exception when no elements are place on the columns. Subsets are referenced in the result-MDX through the TM1SubsetToSet Function</p> <p>Returns:</p> Type Description <code>str</code> <p>String, the MDX Query</p>"},{"location":"reference/objects/nativeview/#TM1py.Objects.NativeView.NativeView.body","title":"<code>body</code>  <code>property</code>","text":""},{"location":"reference/objects/nativeview/#TM1py.Objects.NativeView.NativeView.columns","title":"<code>columns</code>  <code>property</code>","text":""},{"location":"reference/objects/nativeview/#TM1py.Objects.NativeView.NativeView.format_string","title":"<code>format_string</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/nativeview/#TM1py.Objects.NativeView.NativeView.mdx","title":"<code>mdx</code>  <code>property</code>","text":""},{"location":"reference/objects/nativeview/#TM1py.Objects.NativeView.NativeView.rows","title":"<code>rows</code>  <code>property</code>","text":""},{"location":"reference/objects/nativeview/#TM1py.Objects.NativeView.NativeView.suppress_empty_cells","title":"<code>suppress_empty_cells</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/nativeview/#TM1py.Objects.NativeView.NativeView.suppress_empty_columns","title":"<code>suppress_empty_columns</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/nativeview/#TM1py.Objects.NativeView.NativeView.suppress_empty_rows","title":"<code>suppress_empty_rows</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/nativeview/#TM1py.Objects.NativeView.NativeView.titles","title":"<code>titles</code>  <code>property</code>","text":""},{"location":"reference/objects/nativeview/#TM1py.Objects.NativeView.NativeView.add_column","title":"<code>add_column(dimension_name, subset=None)</code>","text":"<p>Add Dimension or Subset to the column-axis</p> <p>Parameters:</p> Name Type Description Default <code>dimension_name</code> <code>str</code> <p>name of the dimension</p> required <code>subset</code> <code>Union[Subset, AnonymousSubset]</code> <p>instance of TM1py.Subset. Can be None</p> <code>None</code> <p>Returns:</p> Type Description Source code in <code>TM1py/Objects/NativeView.py</code> <pre><code>def add_column(self, dimension_name: str, subset: Union[Subset, AnonymousSubset] = None):\n    \"\"\"Add Dimension or Subset to the column-axis\n\n    :param dimension_name: name of the dimension\n    :param subset: instance of TM1py.Subset. Can be None\n    :return:\n    \"\"\"\n    view_axis_selection = ViewAxisSelection(dimension_name=dimension_name, subset=subset)\n    self._columns.append(view_axis_selection)\n</code></pre>"},{"location":"reference/objects/nativeview/#TM1py.Objects.NativeView.NativeView.add_row","title":"<code>add_row(dimension_name, subset=None)</code>","text":"<p>Add Dimension or Subset to the row-axis</p> <p>Parameters:</p> Name Type Description Default <code>dimension_name</code> <code>str</code> required <code>subset</code> <code>Subset</code> <p>instance of TM1py.Subset. Can be None instead.</p> <code>None</code> <p>Returns:</p> Type Description Source code in <code>TM1py/Objects/NativeView.py</code> <pre><code>def add_row(self, dimension_name: str, subset: Subset = None):\n    \"\"\"Add Dimension or Subset to the row-axis\n\n    :param dimension_name:\n    :param subset: instance of TM1py.Subset. Can be None instead.\n    :return:\n    \"\"\"\n    view_axis_selection = ViewAxisSelection(dimension_name=dimension_name, subset=subset)\n    self._rows.append(view_axis_selection)\n</code></pre>"},{"location":"reference/objects/nativeview/#TM1py.Objects.NativeView.NativeView.add_title","title":"<code>add_title(dimension_name, selection, subset=None)</code>","text":"<p>Add subset and element to the titles-axis</p> <p>Parameters:</p> Name Type Description Default <code>dimension_name</code> <code>str</code> <p>name of the dimension.</p> required <code>selection</code> <code>str</code> <p>name of an element.</p> required <code>subset</code> <code>Union[Subset, AnonymousSubset]</code> <p>instance of TM1py.Subset. Can be None instead.</p> <code>None</code> <p>Returns:</p> Type Description Source code in <code>TM1py/Objects/NativeView.py</code> <pre><code>def add_title(self, dimension_name: str, selection: str, subset: Union[Subset, AnonymousSubset] = None):\n    \"\"\"Add subset and element to the titles-axis\n\n    :param dimension_name: name of the dimension.\n    :param selection: name of an element.\n    :param subset:  instance of TM1py.Subset. Can be None instead.\n    :return:\n    \"\"\"\n    view_title_selection = ViewTitleSelection(dimension_name, subset, selection)\n    self._titles.append(view_title_selection)\n</code></pre>"},{"location":"reference/objects/nativeview/#TM1py.Objects.NativeView.NativeView.from_dict","title":"<code>from_dict(view_as_dict, cube_name=None)</code>  <code>classmethod</code>","text":"Source code in <code>TM1py/Objects/NativeView.py</code> <pre><code>@classmethod\ndef from_dict(cls, view_as_dict: Dict, cube_name: str = None) -&gt; \"NativeView\":\n    titles, columns, rows = [], [], []\n\n    for axis_selection in view_as_dict[\"Titles\"]:\n        subset = cls._build_subset_from_axis_selection(axis_selection)\n\n        if \"Selected\" in axis_selection:\n            selected = axis_selection[\"Selected\"][\"Name\"]\n\n        elif \"Selected@odata.bind\" in axis_selection:\n            selected = read_object_name_from_url(\n                url=axis_selection[\"Selected@odata.bind\"],\n                pattern=r\"Dimensions\\('.*?'\\)/Hierarchies\\('.*?'\\)/Elements\\('(.+?)'\\)\",\n            )\n\n            if not selected:\n                raise ValueError(\n                    f\"Unexpected value for 'Selected@odata.bind' property \" f\"in view title dict: '{selected}'\"\n                )\n\n        else:\n            raise ValueError(\"View Title dict must contain 'Selected' or 'Selected@odata.bind' as key\")\n\n        titles.append(ViewTitleSelection(dimension_name=subset.dimension_name, subset=subset, selected=selected))\n\n    for i, axis in enumerate([view_as_dict[\"Columns\"], view_as_dict[\"Rows\"]]):\n        for axis_selection in axis:\n            subset = cls._build_subset_from_axis_selection(axis_selection)\n\n            axis_selection = ViewAxisSelection(dimension_name=subset.dimension_name, subset=subset)\n            columns.append(axis_selection) if i == 0 else rows.append(axis_selection)\n\n    if not cube_name:\n        cube_name = view_as_dict[\"@odata.context\"][20 : view_as_dict[\"@odata.context\"].find(\"')/\")]\n    return cls(\n        cube_name=cube_name,\n        view_name=view_as_dict[\"Name\"],\n        suppress_empty_columns=view_as_dict[\"SuppressEmptyColumns\"],\n        suppress_empty_rows=view_as_dict[\"SuppressEmptyRows\"],\n        format_string=view_as_dict[\"FormatString\"],\n        titles=titles,\n        columns=columns,\n        rows=rows,\n    )\n</code></pre>"},{"location":"reference/objects/nativeview/#TM1py.Objects.NativeView.NativeView.from_json","title":"<code>from_json(view_as_json, cube_name=None)</code>  <code>classmethod</code>","text":"<p>Alternative constructor :Parameters:     <code>view_as_json</code> : string, JSON</p> <p>:Returns:     <code>View</code> : an instance of this class</p> Source code in <code>TM1py/Objects/NativeView.py</code> <pre><code>@classmethod\ndef from_json(cls, view_as_json: str, cube_name: Optional[str] = None) -&gt; \"NativeView\":\n    \"\"\"Alternative constructor\n    :Parameters:\n        `view_as_json` : string, JSON\n\n    :Returns:\n        `View` : an instance of this class\n    \"\"\"\n    view_as_dict = json.loads(view_as_json)\n    return NativeView.from_dict(view_as_dict, cube_name)\n</code></pre>"},{"location":"reference/objects/nativeview/#TM1py.Objects.NativeView.NativeView.remove_column","title":"<code>remove_column(dimension_name)</code>","text":"<p>remove dimension from the column axis</p> <p>Parameters:</p> Name Type Description Default <code>dimension_name</code> <code>str</code> required <p>Returns:</p> Type Description Source code in <code>TM1py/Objects/NativeView.py</code> <pre><code>def remove_column(self, dimension_name: str):\n    \"\"\"remove dimension from the column axis\n\n    :param dimension_name:\n    :return:\n    \"\"\"\n    for column in self._columns[:]:\n        if case_and_space_insensitive_equals(column.dimension_name, dimension_name):\n            self._columns.remove(column)\n</code></pre>"},{"location":"reference/objects/nativeview/#TM1py.Objects.NativeView.NativeView.remove_row","title":"<code>remove_row(dimension_name)</code>","text":"<p>remove dimension from the row axis</p> <p>Parameters:</p> Name Type Description Default <code>dimension_name</code> <code>str</code> required <p>Returns:</p> Type Description Source code in <code>TM1py/Objects/NativeView.py</code> <pre><code>def remove_row(self, dimension_name: str):\n    \"\"\"remove dimension from the row axis\n\n    :param dimension_name:\n    :return:\n    \"\"\"\n    for row in self._rows[:]:\n        if case_and_space_insensitive_equals(row.dimension_name, dimension_name):\n            self._rows.remove(row)\n</code></pre>"},{"location":"reference/objects/nativeview/#TM1py.Objects.NativeView.NativeView.remove_title","title":"<code>remove_title(dimension_name)</code>","text":"<p>Remove dimension from the titles-axis</p> <p>Parameters:</p> Name Type Description Default <code>dimension_name</code> <code>str</code> <p>name of the dimension.</p> required <p>Returns:</p> Type Description Source code in <code>TM1py/Objects/NativeView.py</code> <pre><code>def remove_title(self, dimension_name: str):\n    \"\"\"Remove dimension from the titles-axis\n\n    :param dimension_name: name of the dimension.\n    :return:\n    \"\"\"\n    for title in self._titles[:]:\n        if case_and_space_insensitive_equals(title.dimension_name, dimension_name):\n            self._titles.remove(title)\n</code></pre>"},{"location":"reference/objects/nativeview/#TM1py.Objects.NativeView.NativeView.substitute_title","title":"<code>substitute_title(dimension, element)</code>","text":"Source code in <code>TM1py/Objects/NativeView.py</code> <pre><code>def substitute_title(self, dimension: str, element: str):\n    for title in self._titles:\n        if case_and_space_insensitive_equals(title.dimension_name, dimension):\n            title._subset = AnonymousSubset(dimension, dimension, elements=[element])\n            title._selected = element\n            return\n\n    raise ValueError(f\"Dimension '{dimension}' not found in titles\")\n</code></pre>"},{"location":"reference/objects/process/","title":"Process","text":""},{"location":"reference/objects/process/#TM1py.Objects.Process.Process","title":"<code>Process(name, has_security_access=False, ui_data='CubeAction=1511\\x0cDataAction=1503\\x0cCubeLogChanges=0\\x0c', parameters=None, variables=None, variables_ui_data=None, prolog_procedure='', metadata_procedure='', data_procedure='', epilog_procedure='', datasource_type='None', datasource_ascii_decimal_separator='.', datasource_ascii_delimiter_char=';', datasource_ascii_delimiter_type='Character', datasource_ascii_header_records=1, datasource_ascii_quote_character='', datasource_ascii_thousand_separator=',', datasource_data_source_name_for_client='', datasource_data_source_name_for_server='', datasource_password='', datasource_user_name='', datasource_query='', datasource_uses_unicode=True, datasource_view='', datasource_subset='', datasource_json_root_pointer='', datasource_json_variable_mapping='')</code>","text":"<p>               Bases: <code>TM1Object</code></p> <p>Abstraction of a TM1 Process.</p> <p>IMPORTANT. doesn't work with Processes that were generated through the Wizard</p> <p>Default construcor</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the process - mandatory</p> required <code>has_security_access</code> <code>Optional[bool]</code> <code>False</code> <code>ui_data</code> <code>str</code> <code>'CubeAction=1511\\x0cDataAction=1503\\x0cCubeLogChanges=0\\x0c'</code> <code>parameters</code> <code>Iterable</code> <code>None</code> <code>variables</code> <code>Iterable</code> <code>None</code> <code>variables_ui_data</code> <code>Iterable</code> <code>None</code> <code>prolog_procedure</code> <code>str</code> <code>''</code> <code>metadata_procedure</code> <code>str</code> <code>''</code> <code>data_procedure</code> <code>str</code> <code>''</code> <code>epilog_procedure</code> <code>str</code> <code>''</code> <code>datasource_type</code> <code>str</code> <code>'None'</code> <code>datasource_ascii_decimal_separator</code> <code>str</code> <code>'.'</code> <code>datasource_ascii_delimiter_char</code> <code>str</code> <code>';'</code> <code>datasource_ascii_delimiter_type</code> <code>str</code> <code>'Character'</code> <code>datasource_ascii_header_records</code> <code>int</code> <code>1</code> <code>datasource_ascii_quote_character</code> <code>str</code> <code>''</code> <code>datasource_ascii_thousand_separator</code> <code>str</code> <code>','</code> <code>datasource_data_source_name_for_client</code> <code>str</code> <code>''</code> <code>datasource_data_source_name_for_server</code> <code>str</code> <code>''</code> <code>datasource_password</code> <code>str</code> <code>''</code> <code>datasource_user_name</code> <code>str</code> <code>''</code> <code>datasource_query</code> <code>str</code> <code>''</code> <code>datasource_uses_unicode</code> <code>bool</code> <code>True</code> <code>datasource_view</code> <code>str</code> <code>''</code> <code>datasource_subset</code> <code>str</code> <code>''</code> <code>datasource_json_root_pointer</code> <code>str</code> <code>''</code> <code>datasource_json_variable_mapping</code> <code>str</code> <code>''</code> Source code in <code>TM1py/Objects/Process.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    has_security_access: Optional[bool] = False,\n    ui_data: str = \"CubeAction=1511\\fDataAction=1503\\fCubeLogChanges=0\\f\",\n    parameters: Iterable = None,\n    variables: Iterable = None,\n    variables_ui_data: Iterable = None,\n    prolog_procedure: str = \"\",\n    metadata_procedure: str = \"\",\n    data_procedure: str = \"\",\n    epilog_procedure: str = \"\",\n    datasource_type: str = \"None\",\n    datasource_ascii_decimal_separator: str = \".\",\n    datasource_ascii_delimiter_char: str = \";\",\n    datasource_ascii_delimiter_type: str = \"Character\",\n    datasource_ascii_header_records: int = 1,\n    datasource_ascii_quote_character: str = \"\",\n    datasource_ascii_thousand_separator: str = \",\",\n    datasource_data_source_name_for_client: str = \"\",\n    datasource_data_source_name_for_server: str = \"\",\n    datasource_password: str = \"\",\n    datasource_user_name: str = \"\",\n    datasource_query: str = \"\",\n    datasource_uses_unicode: bool = True,\n    datasource_view: str = \"\",\n    datasource_subset: str = \"\",\n    datasource_json_root_pointer: str = \"\",\n    datasource_json_variable_mapping: str = \"\",\n):\n    \"\"\"Default construcor\n\n    :param name: name of the process - mandatory\n    :param has_security_access:\n    :param ui_data:\n    :param parameters:\n    :param variables:\n    :param variables_ui_data:\n    :param prolog_procedure:\n    :param metadata_procedure:\n    :param data_procedure:\n    :param epilog_procedure:\n    :param datasource_type:\n    :param datasource_ascii_decimal_separator:\n    :param datasource_ascii_delimiter_char:\n    :param datasource_ascii_delimiter_type:\n    :param datasource_ascii_header_records:\n    :param datasource_ascii_quote_character:\n    :param datasource_ascii_thousand_separator:\n    :param datasource_data_source_name_for_client:\n    :param datasource_data_source_name_for_server:\n    :param datasource_password:\n    :param datasource_user_name:\n    :param datasource_query:\n    :param datasource_uses_unicode:\n    :param datasource_view:\n    :param datasource_subset:\n    :param datasource_json_root_pointer:\n    :param datasource_json_variable_mapping:\n    \"\"\"\n    self._name = name\n    self._has_security_access = has_security_access\n    self._ui_data = ui_data\n    self._parameters = list(parameters) if parameters else []\n    self._variables = list(variables) if variables else []\n    if variables_ui_data:\n        # Handle encoding issue in variable_ui_data for async requests\n        self._variables_ui_data = [entry.replace(\"\u20ac\", \"\\f\") for entry in variables_ui_data]\n    else:\n        self._variables_ui_data = []\n    self._prolog_procedure = Process.add_generated_string_to_code(prolog_procedure)\n    self._metadata_procedure = Process.add_generated_string_to_code(metadata_procedure)\n    self._data_procedure = Process.add_generated_string_to_code(data_procedure)\n    self._epilog_procedure = Process.add_generated_string_to_code(epilog_procedure)\n    self._datasource_type = datasource_type\n    self._datasource_ascii_decimal_separator = datasource_ascii_decimal_separator\n    self._datasource_ascii_delimiter_char = datasource_ascii_delimiter_char\n    self._datasource_ascii_delimiter_type = datasource_ascii_delimiter_type\n    self._datasource_ascii_header_records = datasource_ascii_header_records\n    self._datasource_ascii_quote_character = datasource_ascii_quote_character\n    self._datasource_ascii_thousand_separator = datasource_ascii_thousand_separator\n    self._datasource_data_source_name_for_client = datasource_data_source_name_for_client\n    self._datasource_data_source_name_for_server = datasource_data_source_name_for_server\n    self._datasource_password = datasource_password\n    self._datasource_user_name = datasource_user_name\n    self._datasource_query = datasource_query\n    self._datasource_uses_unicode = datasource_uses_unicode\n    self._datasource_view = datasource_view\n    self._datasource_subset = datasource_subset\n    self._datasource_json_root_pointer = datasource_json_root_pointer\n    self._datasource_json_variable_mapping = datasource_json_variable_mapping\n</code></pre>"},{"location":"reference/objects/process/#TM1py.Objects.Process.Process.AUTO_GENERATED_STATEMENTS","title":"<code>AUTO_GENERATED_STATEMENTS = '{}\\r\\n{}\\r\\n'.format(BEGIN_GENERATED_STATEMENTS, END_GENERATED_STATEMENTS)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/objects/process/#TM1py.Objects.Process.Process.BEGIN_GENERATED_STATEMENTS","title":"<code>BEGIN_GENERATED_STATEMENTS = '#****Begin: Generated Statements***'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/objects/process/#TM1py.Objects.Process.Process.END_GENERATED_STATEMENTS","title":"<code>END_GENERATED_STATEMENTS = '#****End: Generated Statements****'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/objects/process/#TM1py.Objects.Process.Process.MAX_STATEMENTS","title":"<code>MAX_STATEMENTS = 16380</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/objects/process/#TM1py.Objects.Process.Process.MAX_STATEMENTS_POST_11_8_015","title":"<code>MAX_STATEMENTS_POST_11_8_015 = 100000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/objects/process/#TM1py.Objects.Process.Process.all_procedures","title":"<code>all_procedures</code>  <code>property</code>","text":""},{"location":"reference/objects/process/#TM1py.Objects.Process.Process.body","title":"<code>body</code>  <code>property</code>","text":""},{"location":"reference/objects/process/#TM1py.Objects.Process.Process.body_as_dict","title":"<code>body_as_dict</code>  <code>property</code>","text":""},{"location":"reference/objects/process/#TM1py.Objects.Process.Process.data_procedure","title":"<code>data_procedure</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/process/#TM1py.Objects.Process.Process.datasource_ascii_decimal_separator","title":"<code>datasource_ascii_decimal_separator</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/process/#TM1py.Objects.Process.Process.datasource_ascii_delimiter_char","title":"<code>datasource_ascii_delimiter_char</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/process/#TM1py.Objects.Process.Process.datasource_ascii_delimiter_type","title":"<code>datasource_ascii_delimiter_type</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/process/#TM1py.Objects.Process.Process.datasource_ascii_header_records","title":"<code>datasource_ascii_header_records</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/process/#TM1py.Objects.Process.Process.datasource_ascii_quote_character","title":"<code>datasource_ascii_quote_character</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/process/#TM1py.Objects.Process.Process.datasource_ascii_thousand_separator","title":"<code>datasource_ascii_thousand_separator</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/process/#TM1py.Objects.Process.Process.datasource_data_source_name_for_client","title":"<code>datasource_data_source_name_for_client</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/process/#TM1py.Objects.Process.Process.datasource_data_source_name_for_server","title":"<code>datasource_data_source_name_for_server</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/process/#TM1py.Objects.Process.Process.datasource_json_root_pointer","title":"<code>datasource_json_root_pointer</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/process/#TM1py.Objects.Process.Process.datasource_json_variable_mapping","title":"<code>datasource_json_variable_mapping</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/process/#TM1py.Objects.Process.Process.datasource_password","title":"<code>datasource_password</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/process/#TM1py.Objects.Process.Process.datasource_query","title":"<code>datasource_query</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/process/#TM1py.Objects.Process.Process.datasource_subset","title":"<code>datasource_subset</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/process/#TM1py.Objects.Process.Process.datasource_type","title":"<code>datasource_type</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/process/#TM1py.Objects.Process.Process.datasource_user_name","title":"<code>datasource_user_name</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/process/#TM1py.Objects.Process.Process.datasource_uses_unicode","title":"<code>datasource_uses_unicode</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/process/#TM1py.Objects.Process.Process.datasource_view","title":"<code>datasource_view</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/process/#TM1py.Objects.Process.Process.epilog_procedure","title":"<code>epilog_procedure</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/process/#TM1py.Objects.Process.Process.has_security_access","title":"<code>has_security_access</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/process/#TM1py.Objects.Process.Process.metadata_procedure","title":"<code>metadata_procedure</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/process/#TM1py.Objects.Process.Process.name","title":"<code>name</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/process/#TM1py.Objects.Process.Process.parameters","title":"<code>parameters</code>  <code>property</code>","text":""},{"location":"reference/objects/process/#TM1py.Objects.Process.Process.prolog_procedure","title":"<code>prolog_procedure</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/process/#TM1py.Objects.Process.Process.variables","title":"<code>variables</code>  <code>property</code>","text":""},{"location":"reference/objects/process/#TM1py.Objects.Process.Process.add_generated_string_to_code","title":"<code>add_generated_string_to_code(code)</code>  <code>staticmethod</code>","text":"Source code in <code>TM1py/Objects/Process.py</code> <pre><code>@staticmethod\ndef add_generated_string_to_code(code: str) -&gt; str:\n    pattern = r\"(?s)#\\*\\*\\*\\*Begin: Generated Statements(.*)#\\*\\*\\*\\*End: Generated Statements\\*\\*\\*\\*\"\n    if re.search(pattern=pattern, string=code):\n        return code\n    else:\n        return Process.AUTO_GENERATED_STATEMENTS + code\n</code></pre>"},{"location":"reference/objects/process/#TM1py.Objects.Process.Process.add_parameter","title":"<code>add_parameter(name, prompt, value, parameter_type=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> required <code>prompt</code> <code>str</code> required <code>value</code> <code>Union[str, int, float]</code> required <code>parameter_type</code> <code>Optional[str]</code> <p>introduced in TM1 11 REST API, therefor optional. if Not given type is derived from value</p> <code>None</code> <p>Returns:</p> Type Description Source code in <code>TM1py/Objects/Process.py</code> <pre><code>def add_parameter(\n    self, name: str, prompt: str, value: Union[str, int, float], parameter_type: Optional[str] = None\n):\n    \"\"\"\n\n    :param name:\n    :param prompt:\n    :param value:\n    :param parameter_type: introduced in TM1 11 REST API, therefor optional. if Not given type is derived from value\n    :return:\n    \"\"\"\n    if not parameter_type:\n        parameter_type = \"String\" if isinstance(value, str) else \"Numeric\"\n    parameter = {\"Name\": name, \"Prompt\": prompt, \"Value\": value, \"Type\": parameter_type}\n    self._parameters.append(parameter)\n</code></pre>"},{"location":"reference/objects/process/#TM1py.Objects.Process.Process.add_variable","title":"<code>add_variable(name, variable_type)</code>","text":"<p>add variable to the process</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>-</p> required <code>variable_type</code> <code>str</code> <p>'String' or 'Numeric'</p> required <p>Returns:</p> Type Description Source code in <code>TM1py/Objects/Process.py</code> <pre><code>def add_variable(self, name: str, variable_type: str):\n    \"\"\"add variable to the process\n\n    :param name: -\n    :param variable_type: 'String' or 'Numeric'\n    :return:\n    \"\"\"\n    # variable consists of actual variable and UI-Information ('ignore','other', etc.)\n    # 1. handle Variable info\n    variable = {\n        \"Name\": name,\n        \"Type\": variable_type,\n        \"Position\": len(self._variables) + 1,\n        \"StartByte\": 0,\n        \"EndByte\": 0,\n    }\n    self._variables.append(variable)\n    # 2. handle UI info\n    var_type = 33 if variable_type == \"Numeric\" else 32\n    # '\\f' !\n    variable_ui_data = \"VarType=\" + str(var_type) + \"\\f\" + \"ColType=\" + str(827) + \"\\f\"\n    \"\"\"\n    mapping VariableUIData:\n        VarType 33 -&gt; Numeric\n        VarType 32 -&gt; String\n        ColType 827 -&gt; Other\n    \"\"\"\n    self._variables_ui_data.append(variable_ui_data)\n</code></pre>"},{"location":"reference/objects/process/#TM1py.Objects.Process.Process.drop_parameter_types","title":"<code>drop_parameter_types()</code>","text":"Source code in <code>TM1py/Objects/Process.py</code> <pre><code>def drop_parameter_types(self):\n    for p in range(len(self.parameters)):\n        if \"Type\" in self.parameters[p]:\n            del self.parameters[p][\"Type\"]\n</code></pre>"},{"location":"reference/objects/process/#TM1py.Objects.Process.Process.from_dict","title":"<code>from_dict(process_as_dict)</code>  <code>classmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>process_as_dict</code> <code>Dict</code> <p>Dictionary, process as dictionary</p> required <p>Returns:</p> Type Description <code>Process</code> <p>an instance of this class</p> Source code in <code>TM1py/Objects/Process.py</code> <pre><code>@classmethod\ndef from_dict(cls, process_as_dict: Dict) -&gt; \"Process\":\n    \"\"\"\n    :param process_as_dict: Dictionary, process as dictionary\n    :return: an instance of this class\n    \"\"\"\n    return cls(\n        name=process_as_dict[\"Name\"],\n        has_security_access=process_as_dict[\"HasSecurityAccess\"],\n        ui_data=process_as_dict.get(\"UIData\", \"\"),\n        parameters=process_as_dict[\"Parameters\"],\n        variables=process_as_dict[\"Variables\"],\n        variables_ui_data=process_as_dict.get(\"VariablesUIData\", \"\"),\n        prolog_procedure=process_as_dict[\"PrologProcedure\"],\n        metadata_procedure=process_as_dict[\"MetadataProcedure\"],\n        data_procedure=process_as_dict[\"DataProcedure\"],\n        epilog_procedure=process_as_dict[\"EpilogProcedure\"],\n        datasource_type=process_as_dict[\"DataSource\"].get(\"Type\", \"\"),\n        datasource_ascii_decimal_separator=process_as_dict[\"DataSource\"].get(\"asciiDecimalSeparator\", \"\"),\n        datasource_ascii_delimiter_char=process_as_dict[\"DataSource\"].get(\"asciiDelimiterChar\", \"\"),\n        datasource_ascii_delimiter_type=process_as_dict[\"DataSource\"].get(\"asciiDelimiterType\", \"\"),\n        datasource_ascii_header_records=process_as_dict[\"DataSource\"].get(\"asciiHeaderRecords\", \"\"),\n        datasource_ascii_quote_character=process_as_dict[\"DataSource\"].get(\"asciiQuoteCharacter\", \"\"),\n        datasource_ascii_thousand_separator=process_as_dict[\"DataSource\"].get(\"asciiThousandSeparator\", \"\"),\n        datasource_data_source_name_for_client=process_as_dict[\"DataSource\"].get(\"dataSourceNameForClient\", \"\"),\n        datasource_data_source_name_for_server=process_as_dict[\"DataSource\"].get(\"dataSourceNameForServer\", \"\"),\n        datasource_password=process_as_dict[\"DataSource\"].get(\"password\", \"\"),\n        datasource_user_name=process_as_dict[\"DataSource\"].get(\"userName\", \"\"),\n        datasource_query=process_as_dict[\"DataSource\"].get(\"query\", \"\"),\n        datasource_uses_unicode=process_as_dict[\"DataSource\"].get(\"usesUnicode\", \"\"),\n        datasource_view=process_as_dict[\"DataSource\"].get(\"view\", \"\"),\n        datasource_subset=process_as_dict[\"DataSource\"].get(\"subset\", \"\"),\n        datasource_json_root_pointer=process_as_dict[\"DataSource\"].get(\"jsonRootPointer\", \"\"),\n        datasource_json_variable_mapping=process_as_dict[\"DataSource\"].get(\"jsonVariableMapping\", \"\"),\n    )\n</code></pre>"},{"location":"reference/objects/process/#TM1py.Objects.Process.Process.from_json","title":"<code>from_json(process_as_json)</code>  <code>classmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>process_as_json</code> <code>str</code> <p>response of /Processes('x')?$expand=*</p> required <p>Returns:</p> Type Description <code>Process</code> <p>an instance of this class</p> Source code in <code>TM1py/Objects/Process.py</code> <pre><code>@classmethod\ndef from_json(cls, process_as_json: str) -&gt; \"Process\":\n    \"\"\"\n    :param process_as_json: response of /Processes('x')?$expand=*\n    :return: an instance of this class\n    \"\"\"\n    process_as_dict = json.loads(process_as_json)\n    return cls.from_dict(process_as_dict)\n</code></pre>"},{"location":"reference/objects/process/#TM1py.Objects.Process.Process.max_statements","title":"<code>max_statements(version)</code>  <code>staticmethod</code>","text":"Source code in <code>TM1py/Objects/Process.py</code> <pre><code>@staticmethod\ndef max_statements(version: str):\n    if verify_version(required_version=\"11.8.015\", version=version):\n        return Process.MAX_STATEMENTS_POST_11_8_015\n\n    return Process.MAX_STATEMENTS\n</code></pre>"},{"location":"reference/objects/process/#TM1py.Objects.Process.Process.remove_parameter","title":"<code>remove_parameter(name)</code>","text":"Source code in <code>TM1py/Objects/Process.py</code> <pre><code>def remove_parameter(self, name: str):\n    for parameter in self.parameters[:]:\n        if parameter[\"Name\"] == name:\n            self._parameters.remove(parameter)\n</code></pre>"},{"location":"reference/objects/process/#TM1py.Objects.Process.Process.remove_variable","title":"<code>remove_variable(name)</code>","text":"Source code in <code>TM1py/Objects/Process.py</code> <pre><code>def remove_variable(self, name: str):\n    for variable in self.variables[:]:\n        if variable[\"Name\"] == name:\n            vuid = self._variables_ui_data[self._variables.index(variable)]\n            self._variables_ui_data.remove(vuid)\n            self._variables.remove(variable)\n</code></pre>"},{"location":"reference/objects/processdebugbreakpoint/","title":"ProcessDebugBreakpoint","text":""},{"location":"reference/objects/processdebugbreakpoint/#TM1py.Objects.ProcessDebugBreakpoint.BreakPointType","title":"<code>BreakPointType</code>","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"reference/objects/processdebugbreakpoint/#TM1py.Objects.ProcessDebugBreakpoint.BreakPointType.PROCESS_DEBUG_CONTEXT_DATA_BREAK_POINT","title":"<code>PROCESS_DEBUG_CONTEXT_DATA_BREAK_POINT = 'ProcessDebugContextDataBreakpoint'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/objects/processdebugbreakpoint/#TM1py.Objects.ProcessDebugBreakpoint.BreakPointType.PROCESS_DEBUG_CONTEXT_LINE_BREAK_POINT","title":"<code>PROCESS_DEBUG_CONTEXT_LINE_BREAK_POINT = 'ProcessDebugContextLineBreakpoint'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/objects/processdebugbreakpoint/#TM1py.Objects.ProcessDebugBreakpoint.BreakPointType.PROCESS_DEBUG_CONTEXT_LOCK_BREAK_POINT","title":"<code>PROCESS_DEBUG_CONTEXT_LOCK_BREAK_POINT = 'ProcessDebugContextLockBreakpoint'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/objects/processdebugbreakpoint/#TM1py.Objects.ProcessDebugBreakpoint.BreakPointType.__str__","title":"<code>__str__()</code>","text":"Source code in <code>TM1py/Objects/ProcessDebugBreakpoint.py</code> <pre><code>def __str__(self):\n    return self.value\n</code></pre>"},{"location":"reference/objects/processdebugbreakpoint/#TM1py.Objects.ProcessDebugBreakpoint.HitMode","title":"<code>HitMode</code>","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"reference/objects/processdebugbreakpoint/#TM1py.Objects.ProcessDebugBreakpoint.HitMode.BREAK_ALWAYS","title":"<code>BREAK_ALWAYS = 'BreakAlways'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/objects/processdebugbreakpoint/#TM1py.Objects.ProcessDebugBreakpoint.HitMode.BREAK_EQUAL","title":"<code>BREAK_EQUAL = 'BreakEqual'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/objects/processdebugbreakpoint/#TM1py.Objects.ProcessDebugBreakpoint.HitMode.BREAK_GREATER_OR_EQUAL","title":"<code>BREAK_GREATER_OR_EQUAL = 'BreakGreaterOrEqual'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/objects/processdebugbreakpoint/#TM1py.Objects.ProcessDebugBreakpoint.HitMode.__str__","title":"<code>__str__()</code>","text":"Source code in <code>TM1py/Objects/ProcessDebugBreakpoint.py</code> <pre><code>def __str__(self):\n    return self.value\n</code></pre>"},{"location":"reference/objects/processdebugbreakpoint/#TM1py.Objects.ProcessDebugBreakpoint.ProcessDebugBreakpoint","title":"<code>ProcessDebugBreakpoint(breakpoint_id, breakpoint_type=BreakPointType.PROCESS_DEBUG_CONTEXT_LINE_BREAK_POINT, enabled=True, hit_mode=HitMode.BREAK_ALWAYS, hit_count=0, expression='', variable_name='', process_name='', procedure='', line_number=0, object_name='', object_type='', lock_mode='')</code>","text":"<p>               Bases: <code>TM1Object</code></p> <p>Abstraction of a TM1 Process Debug Breakpoint.</p> Source code in <code>TM1py/Objects/ProcessDebugBreakpoint.py</code> <pre><code>def __init__(\n    self,\n    breakpoint_id: int,\n    breakpoint_type: Union[BreakPointType, str] = BreakPointType.PROCESS_DEBUG_CONTEXT_LINE_BREAK_POINT,\n    enabled: bool = True,\n    hit_mode: Union[HitMode, str] = HitMode.BREAK_ALWAYS,\n    hit_count: int = 0,\n    expression: str = \"\",\n    variable_name: str = \"\",\n    process_name: str = \"\",\n    procedure: str = \"\",\n    line_number: int = 0,\n    object_name: str = \"\",\n    object_type: str = \"\",\n    lock_mode: str = \"\",\n):\n    self._type = BreakPointType(breakpoint_type)\n    self._id = breakpoint_id\n    self._enabled = enabled\n    self._hit_mode = HitMode(hit_mode)\n    self._hit_count = hit_count\n    self._expression = expression\n    self._variable_name = variable_name\n    self._process_name = process_name\n    self._procedure = procedure\n    self._line_number = line_number\n    self._object_name = object_name\n    self._object_type = object_type\n    self._lock_mode = lock_mode\n</code></pre>"},{"location":"reference/objects/processdebugbreakpoint/#TM1py.Objects.ProcessDebugBreakpoint.ProcessDebugBreakpoint.body","title":"<code>body</code>  <code>property</code>","text":""},{"location":"reference/objects/processdebugbreakpoint/#TM1py.Objects.ProcessDebugBreakpoint.ProcessDebugBreakpoint.body_as_dict","title":"<code>body_as_dict</code>  <code>property</code>","text":""},{"location":"reference/objects/processdebugbreakpoint/#TM1py.Objects.ProcessDebugBreakpoint.ProcessDebugBreakpoint.breakpoint_id","title":"<code>breakpoint_id</code>  <code>property</code>","text":""},{"location":"reference/objects/processdebugbreakpoint/#TM1py.Objects.ProcessDebugBreakpoint.ProcessDebugBreakpoint.breakpoint_type","title":"<code>breakpoint_type</code>  <code>property</code>","text":""},{"location":"reference/objects/processdebugbreakpoint/#TM1py.Objects.ProcessDebugBreakpoint.ProcessDebugBreakpoint.enabled","title":"<code>enabled</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/processdebugbreakpoint/#TM1py.Objects.ProcessDebugBreakpoint.ProcessDebugBreakpoint.expression","title":"<code>expression</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/processdebugbreakpoint/#TM1py.Objects.ProcessDebugBreakpoint.ProcessDebugBreakpoint.hit_count","title":"<code>hit_count</code>  <code>property</code>","text":""},{"location":"reference/objects/processdebugbreakpoint/#TM1py.Objects.ProcessDebugBreakpoint.ProcessDebugBreakpoint.hit_mode","title":"<code>hit_mode</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/processdebugbreakpoint/#TM1py.Objects.ProcessDebugBreakpoint.ProcessDebugBreakpoint.line_number","title":"<code>line_number</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/processdebugbreakpoint/#TM1py.Objects.ProcessDebugBreakpoint.ProcessDebugBreakpoint.lock_mode","title":"<code>lock_mode</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/processdebugbreakpoint/#TM1py.Objects.ProcessDebugBreakpoint.ProcessDebugBreakpoint.object_name","title":"<code>object_name</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/processdebugbreakpoint/#TM1py.Objects.ProcessDebugBreakpoint.ProcessDebugBreakpoint.object_type","title":"<code>object_type</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/processdebugbreakpoint/#TM1py.Objects.ProcessDebugBreakpoint.ProcessDebugBreakpoint.procedure","title":"<code>procedure</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/processdebugbreakpoint/#TM1py.Objects.ProcessDebugBreakpoint.ProcessDebugBreakpoint.process_name","title":"<code>process_name</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/processdebugbreakpoint/#TM1py.Objects.ProcessDebugBreakpoint.ProcessDebugBreakpoint.variable_name","title":"<code>variable_name</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/processdebugbreakpoint/#TM1py.Objects.ProcessDebugBreakpoint.ProcessDebugBreakpoint.from_dict","title":"<code>from_dict(breakpoint_as_dict)</code>  <code>classmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>breakpoint_as_dict</code> <code>Dict</code> required <p>Returns:</p> Type Description <code>ProcessDebugBreakpoint</code> <p>an instance of this class</p> Source code in <code>TM1py/Objects/ProcessDebugBreakpoint.py</code> <pre><code>@classmethod\ndef from_dict(cls, breakpoint_as_dict: Dict) -&gt; \"ProcessDebugBreakpoint\":\n    \"\"\"\n    :param breakpoint_as_dict:\n    :return: an instance of this class\n    \"\"\"\n    breakpoint_type = breakpoint_as_dict[\"@odata.type\"][16:]\n    return cls(\n        breakpoint_type=breakpoint_type,\n        breakpoint_id=breakpoint_as_dict[\"ID\"],\n        enabled=breakpoint_as_dict[\"Enabled\"],\n        hit_mode=breakpoint_as_dict[\"HitMode\"],\n        hit_count=breakpoint_as_dict[\"HitCount\"],\n        expression=breakpoint_as_dict[\"Expression\"],\n        variable_name=(\n            breakpoint_as_dict[\"VariableName\"] if breakpoint_type == \"ProcessDebugContextDataBreakpoint\" else \"\"\n        ),\n        process_name=(\n            breakpoint_as_dict[\"ProcessName\"] if breakpoint_type == \"ProcessDebugContextLineBreakpoint\" else \"\"\n        ),\n        procedure=breakpoint_as_dict[\"Procedure\"] if breakpoint_type == \"ProcessDebugContextLineBreakpoint\" else \"\",\n        line_number=(\n            breakpoint_as_dict[\"LineNumber\"] if breakpoint_type == \"ProcessDebugContextLineBreakpoint\" else \"\"\n        ),\n        object_name=(\n            breakpoint_as_dict[\"ObjectName\"] if breakpoint_type == \"ProcessDebugContextLockBreakpoint\" else \"\"\n        ),\n        object_type=(\n            breakpoint_as_dict[\"ObjectType\"] if breakpoint_type == \"ProcessDebugContextLockBreakpoint\" else \"\"\n        ),\n        lock_mode=breakpoint_as_dict[\"LockMode\"] if breakpoint_type == \"ProcessDebugContextLockBreakpoint\" else \"\",\n    )\n</code></pre>"},{"location":"reference/objects/rules/","title":"Rules","text":""},{"location":"reference/objects/rules/#TM1py.Objects.Rules.Rules","title":"<code>Rules(rules)</code>","text":"<p>               Bases: <code>TM1Object</code></p> <p>Abstraction of Rules on a cube.</p> <p>rules_analytics     A collection of rulestatements, where each statement is stored in uppercase without linebreaks.     comments are not included.</p> Source code in <code>TM1py/Objects/Rules.py</code> <pre><code>def __init__(self, rules: str):\n    self._text = rules\n    self._rules_analytics = []\n    self.init_analytics()\n</code></pre>"},{"location":"reference/objects/rules/#TM1py.Objects.Rules.Rules.KEYWORDS","title":"<code>KEYWORDS = ['SKIPCHECK', 'FEEDSTRINGS', 'UNDEFVALS', 'FEEDERS']</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/objects/rules/#TM1py.Objects.Rules.Rules.body","title":"<code>body</code>  <code>property</code>","text":""},{"location":"reference/objects/rules/#TM1py.Objects.Rules.Rules.body_as_dict","title":"<code>body_as_dict</code>  <code>property</code>","text":""},{"location":"reference/objects/rules/#TM1py.Objects.Rules.Rules.feeder_statements","title":"<code>feeder_statements</code>  <code>property</code>","text":""},{"location":"reference/objects/rules/#TM1py.Objects.Rules.Rules.feedstrings","title":"<code>feedstrings</code>  <code>property</code>","text":""},{"location":"reference/objects/rules/#TM1py.Objects.Rules.Rules.has_feeders","title":"<code>has_feeders</code>  <code>property</code>","text":""},{"location":"reference/objects/rules/#TM1py.Objects.Rules.Rules.rule_statements","title":"<code>rule_statements</code>  <code>property</code>","text":""},{"location":"reference/objects/rules/#TM1py.Objects.Rules.Rules.rules_analytics","title":"<code>rules_analytics</code>  <code>property</code>","text":""},{"location":"reference/objects/rules/#TM1py.Objects.Rules.Rules.skipcheck","title":"<code>skipcheck</code>  <code>property</code>","text":""},{"location":"reference/objects/rules/#TM1py.Objects.Rules.Rules.text","title":"<code>text</code>  <code>property</code>","text":""},{"location":"reference/objects/rules/#TM1py.Objects.Rules.Rules.undefvals","title":"<code>undefvals</code>  <code>property</code>","text":""},{"location":"reference/objects/rules/#TM1py.Objects.Rules.Rules.__iter__","title":"<code>__iter__()</code>","text":"Source code in <code>TM1py/Objects/Rules.py</code> <pre><code>def __iter__(self):\n    return iter(self.rules_analytics)\n</code></pre>"},{"location":"reference/objects/rules/#TM1py.Objects.Rules.Rules.__len__","title":"<code>__len__()</code>","text":"Source code in <code>TM1py/Objects/Rules.py</code> <pre><code>def __len__(self):\n    return len(self.rules_analytics)\n</code></pre>"},{"location":"reference/objects/rules/#TM1py.Objects.Rules.Rules.__str__","title":"<code>__str__()</code>","text":"Source code in <code>TM1py/Objects/Rules.py</code> <pre><code>def __str__(self):\n    return self.text\n</code></pre>"},{"location":"reference/objects/rules/#TM1py.Objects.Rules.Rules.init_analytics","title":"<code>init_analytics()</code>","text":"Source code in <code>TM1py/Objects/Rules.py</code> <pre><code>def init_analytics(self):\n    text_without_comments = \"\\n\".join(\n        [rule for rule in self._text.split(\"\\n\") if rule.strip() and rule.strip()[0] != \"#\"]\n    )\n    for statement in text_without_comments.split(\";\"):\n        if len(statement.strip()) &gt; 0:\n            self._rules_analytics.append(statement.replace(\"\\n\", \"\").upper())\n</code></pre>"},{"location":"reference/objects/sandbox/","title":"Sandbox","text":""},{"location":"reference/objects/sandbox/#TM1py.Objects.Sandbox.Sandbox","title":"<code>Sandbox(name, include_in_sandbox_dimension=True, loaded=False, active=False, queued=False)</code>","text":"<p>               Bases: <code>TM1Object</code></p> <p>Abstraction of a TM1 Sandbox</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the Sandbox</p> required <code>include_in_sandbox_dimension</code> <code>bool</code> <code>True</code> <code>loaded</code> <code>bool</code> <p>use default false when creating sandbox</p> <code>False</code> <code>active</code> <code>bool</code> <p>use default false when creating sandbox</p> <code>False</code> <code>queued</code> <code>bool</code> <p>use default false when creating sandbox</p> <code>False</code> Source code in <code>TM1py/Objects/Sandbox.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    include_in_sandbox_dimension: bool = True,\n    loaded: bool = False,\n    active: bool = False,\n    queued: bool = False,\n):\n    \"\"\"\n    :param name: name of the Sandbox\n    :param include_in_sandbox_dimension:\n    :param loaded: use default false when creating sandbox\n    :param active: use default false when creating sandbox\n    :param queued: use default false when creating sandbox\n    \"\"\"\n    self.name = name\n    self.include_in_sandbox_dimension = include_in_sandbox_dimension\n    self.loaded = loaded\n    self.active = active\n    self.queued = queued\n</code></pre>"},{"location":"reference/objects/sandbox/#TM1py.Objects.Sandbox.Sandbox.active","title":"<code>active = active</code>  <code>instance-attribute</code>","text":""},{"location":"reference/objects/sandbox/#TM1py.Objects.Sandbox.Sandbox.body","title":"<code>body</code>  <code>property</code>","text":""},{"location":"reference/objects/sandbox/#TM1py.Objects.Sandbox.Sandbox.include_in_sandbox_dimension","title":"<code>include_in_sandbox_dimension</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/sandbox/#TM1py.Objects.Sandbox.Sandbox.loaded","title":"<code>loaded = loaded</code>  <code>instance-attribute</code>","text":""},{"location":"reference/objects/sandbox/#TM1py.Objects.Sandbox.Sandbox.name","title":"<code>name</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/sandbox/#TM1py.Objects.Sandbox.Sandbox.queued","title":"<code>queued = queued</code>  <code>instance-attribute</code>","text":""},{"location":"reference/objects/sandbox/#TM1py.Objects.Sandbox.Sandbox.from_dict","title":"<code>from_dict(sandbox_as_dict)</code>  <code>classmethod</code>","text":"<p>Alternative constructor</p> <p>Parameters:</p> Name Type Description Default <code>sandbox_as_dict</code> <code>Dict</code> <p>user as dict</p> required <p>Returns:</p> Type Description <code>Sandbox</code> <p>an instance of this class</p> Source code in <code>TM1py/Objects/Sandbox.py</code> <pre><code>@classmethod\ndef from_dict(cls, sandbox_as_dict: Dict) -&gt; \"Sandbox\":\n    \"\"\"Alternative constructor\n\n    :param sandbox_as_dict: user as dict\n    :return: an instance of this class\n    \"\"\"\n    return cls(\n        name=sandbox_as_dict[\"Name\"],\n        include_in_sandbox_dimension=sandbox_as_dict[\"IncludeInSandboxDimension\"],\n        loaded=sandbox_as_dict[\"IsLoaded\"],\n        active=sandbox_as_dict[\"IsActive\"],\n        queued=sandbox_as_dict[\"IsQueued\"],\n    )\n</code></pre>"},{"location":"reference/objects/sandbox/#TM1py.Objects.Sandbox.Sandbox.from_json","title":"<code>from_json(sandbox_as_json)</code>  <code>classmethod</code>","text":"<p>Alternative constructor</p> <p>Parameters:</p> Name Type Description Default <code>sandbox_as_json</code> <code>str</code> <p>user as JSON string</p> required <p>Returns:</p> Type Description <code>Sandbox</code> <p>sandbox, an instance of this class</p> Source code in <code>TM1py/Objects/Sandbox.py</code> <pre><code>@classmethod\ndef from_json(cls, sandbox_as_json: str) -&gt; \"Sandbox\":\n    \"\"\"Alternative constructor\n\n    :param sandbox_as_json: user as JSON string\n    :return: sandbox, an instance of this class\n    \"\"\"\n    sandbox_as_dict = json.loads(sandbox_as_json)\n    return cls.from_dict(sandbox_as_dict)\n</code></pre>"},{"location":"reference/objects/server/","title":"Server","text":""},{"location":"reference/objects/server/#TM1py.Objects.Server.Server","title":"<code>Server(server_as_dict)</code>","text":"<p>Abstraction of the TM1 Server</p> <p>:Notes:     contains the information you get from http://localhost:5895/Servers     no methods so far</p> Source code in <code>TM1py/Objects/Server.py</code> <pre><code>def __init__(self, server_as_dict: Dict):\n    self.name = server_as_dict[\"Name\"]\n    self.ip_address = server_as_dict[\"IPAddress\"]\n    self.ip_v6_address = server_as_dict[\"IPv6Address\"]\n    self.port_number = server_as_dict[\"PortNumber\"]\n    self.client_message_port_number = server_as_dict[\"ClientMessagePortNumber\"]\n    self.http_port_number = server_as_dict[\"HTTPPortNumber\"]\n    self.using_ssl = server_as_dict[\"UsingSSL\"]\n    self.accepting_clients = server_as_dict[\"AcceptingClients\"]\n    self.self_registered = server_as_dict[\"SelfRegistered\"]\n    self.host = server_as_dict[\"Host\"]\n    self.is_local = server_as_dict[\"IsLocal\"]\n    self.ssl_certificate_id = server_as_dict[\"SSLCertificateID\"]\n    self.ssl_certificate_authority = server_as_dict[\"SSLCertificateAuthority\"]\n    self.ssl_certificate_revocation_list = server_as_dict[\"SSLCertificateRevocationList\"]\n    self.client_export_ssl_server_keyid = server_as_dict[\"ClientExportSSLSvrKeyID\"]\n    self.client_export_ssl_server_cert = server_as_dict[\"ClientExportSSLSvrCert\"]\n    self.last_updated = server_as_dict[\"LastUpdated\"]\n</code></pre>"},{"location":"reference/objects/server/#TM1py.Objects.Server.Server.accepting_clients","title":"<code>accepting_clients = server_as_dict['AcceptingClients']</code>  <code>instance-attribute</code>","text":""},{"location":"reference/objects/server/#TM1py.Objects.Server.Server.client_export_ssl_server_cert","title":"<code>client_export_ssl_server_cert = server_as_dict['ClientExportSSLSvrCert']</code>  <code>instance-attribute</code>","text":""},{"location":"reference/objects/server/#TM1py.Objects.Server.Server.client_export_ssl_server_keyid","title":"<code>client_export_ssl_server_keyid = server_as_dict['ClientExportSSLSvrKeyID']</code>  <code>instance-attribute</code>","text":""},{"location":"reference/objects/server/#TM1py.Objects.Server.Server.client_message_port_number","title":"<code>client_message_port_number = server_as_dict['ClientMessagePortNumber']</code>  <code>instance-attribute</code>","text":""},{"location":"reference/objects/server/#TM1py.Objects.Server.Server.host","title":"<code>host = server_as_dict['Host']</code>  <code>instance-attribute</code>","text":""},{"location":"reference/objects/server/#TM1py.Objects.Server.Server.http_port_number","title":"<code>http_port_number = server_as_dict['HTTPPortNumber']</code>  <code>instance-attribute</code>","text":""},{"location":"reference/objects/server/#TM1py.Objects.Server.Server.ip_address","title":"<code>ip_address = server_as_dict['IPAddress']</code>  <code>instance-attribute</code>","text":""},{"location":"reference/objects/server/#TM1py.Objects.Server.Server.ip_v6_address","title":"<code>ip_v6_address = server_as_dict['IPv6Address']</code>  <code>instance-attribute</code>","text":""},{"location":"reference/objects/server/#TM1py.Objects.Server.Server.is_local","title":"<code>is_local = server_as_dict['IsLocal']</code>  <code>instance-attribute</code>","text":""},{"location":"reference/objects/server/#TM1py.Objects.Server.Server.last_updated","title":"<code>last_updated = server_as_dict['LastUpdated']</code>  <code>instance-attribute</code>","text":""},{"location":"reference/objects/server/#TM1py.Objects.Server.Server.name","title":"<code>name = server_as_dict['Name']</code>  <code>instance-attribute</code>","text":""},{"location":"reference/objects/server/#TM1py.Objects.Server.Server.port_number","title":"<code>port_number = server_as_dict['PortNumber']</code>  <code>instance-attribute</code>","text":""},{"location":"reference/objects/server/#TM1py.Objects.Server.Server.self_registered","title":"<code>self_registered = server_as_dict['SelfRegistered']</code>  <code>instance-attribute</code>","text":""},{"location":"reference/objects/server/#TM1py.Objects.Server.Server.ssl_certificate_authority","title":"<code>ssl_certificate_authority = server_as_dict['SSLCertificateAuthority']</code>  <code>instance-attribute</code>","text":""},{"location":"reference/objects/server/#TM1py.Objects.Server.Server.ssl_certificate_id","title":"<code>ssl_certificate_id = server_as_dict['SSLCertificateID']</code>  <code>instance-attribute</code>","text":""},{"location":"reference/objects/server/#TM1py.Objects.Server.Server.ssl_certificate_revocation_list","title":"<code>ssl_certificate_revocation_list = server_as_dict['SSLCertificateRevocationList']</code>  <code>instance-attribute</code>","text":""},{"location":"reference/objects/server/#TM1py.Objects.Server.Server.using_ssl","title":"<code>using_ssl = server_as_dict['UsingSSL']</code>  <code>instance-attribute</code>","text":""},{"location":"reference/objects/subset/","title":"Subset","text":""},{"location":"reference/objects/subset/#TM1py.Objects.Subset.AnonymousSubset","title":"<code>AnonymousSubset(dimension_name, hierarchy_name=None, expression=None, elements=None, alias='')</code>","text":"<p>               Bases: <code>Subset</code></p> <p>Abstraction of unregistered Subsets used in NativeViews (Check TM1py.ViewAxisSelection)</p> Source code in <code>TM1py/Objects/Subset.py</code> <pre><code>def __init__(\n    self,\n    dimension_name: str,\n    hierarchy_name: Optional[str] = None,\n    expression: Optional[str] = None,\n    elements: Optional[Iterable[str]] = None,\n    alias: str = \"\",\n):\n    Subset.__init__(\n        self,\n        dimension_name=dimension_name,\n        hierarchy_name=hierarchy_name if hierarchy_name else dimension_name,\n        subset_name=\"\",\n        alias=alias,\n        expression=expression,\n        elements=elements,\n    )\n</code></pre>"},{"location":"reference/objects/subset/#TM1py.Objects.Subset.AnonymousSubset.from_dict","title":"<code>from_dict(subset_as_dict)</code>  <code>classmethod</code>","text":"<p>Alternative constructor</p> <p>Parameters:</p> Name Type Description Default <code>subset_as_dict</code> <code>Dict</code> <p>dictionary, representation of Subset as specified in CSDL</p> required <p>Returns:</p> Type Description <code>Subset</code> <p>an instance of this class</p> Source code in <code>TM1py/Objects/Subset.py</code> <pre><code>@classmethod\ndef from_dict(cls, subset_as_dict: Dict) -&gt; \"Subset\":\n    \"\"\"Alternative constructor\n\n    :param subset_as_dict: dictionary, representation of Subset as specified in CSDL\n    :return: an instance of this class\n    \"\"\"\n    if \"Hierarchy\" in subset_as_dict:\n        dimension_name = subset_as_dict[\"Hierarchy\"][\"Dimension\"][\"Name\"]\n        hierarchy_name = subset_as_dict[\"Hierarchy\"][\"Name\"]\n\n    elif \"Hierarchy@odata.bind\" in subset_as_dict:\n        hierarchy_odata = subset_as_dict[\"Hierarchy@odata.bind\"]\n\n        dimension_name = read_object_name_from_url(\n            url=hierarchy_odata, pattern=r\"Dimensions\\('(.*?)'\\)/Hierarchies\\('(.+?)'\\)\"\n        )\n\n        hierarchy_name = read_object_name_from_url(\n            url=hierarchy_odata, pattern=r\"Dimensions\\('(.+?)'\\)/Hierarchies\\('(.*?)'\\)\"\n        )\n\n        if not all([dimension_name, hierarchy_name]):\n            raise ValueError(\n                f\"Unexpected value for 'Hierarchy@odata.bind' property in subset dict: '{hierarchy_odata}'\"\n            )\n\n    else:\n        raise ValueError(\"Subset dict must contain 'Hierarchy' or 'Hierarchy@odata.bind' as key\")\n\n    if \"Elements\" in subset_as_dict:\n        elements = [element[\"Name\"] for element in subset_as_dict[\"Elements\"]]\n    elif \"Elements@odata.bind\" in subset_as_dict:\n        elements = list()\n\n        elements_odata = subset_as_dict[\"Elements@odata.bind\"]\n        pattern = r\"Dimensions\\('.*?'\\)/Hierarchies\\('.*?'\\)/Elements\\('(.+?)'\\)\"\n        for element_odata in elements_odata:\n            element = read_object_name_from_url(element_odata, pattern)\n            if not element:\n                raise ValueError(\n                    f\"Unexpected entry '{element_odata}' for 'Elements@odata.bind' property in subset dict\"\n                )\n\n            elements.append(element)\n    else:\n        elements = None\n\n    return cls(\n        dimension_name=dimension_name,\n        hierarchy_name=hierarchy_name,\n        expression=subset_as_dict.get(\"Expression\", None),\n        alias=subset_as_dict.get(\"Alias\", None),\n        elements=elements if not subset_as_dict.get(\"Expression\", None) else None,\n    )\n</code></pre>"},{"location":"reference/objects/subset/#TM1py.Objects.Subset.AnonymousSubset.from_json","title":"<code>from_json(subset_as_json)</code>  <code>classmethod</code>","text":"<p>Alternative constructor :Parameters:     <code>subset_as_json</code> : string, JSON         representation of Subset as specified in CSDL</p> <p>:Returns:     <code>Subset</code> : an instance of this class</p> Source code in <code>TM1py/Objects/Subset.py</code> <pre><code>@classmethod\ndef from_json(cls, subset_as_json: str) -&gt; \"Subset\":\n    \"\"\"Alternative constructor\n    :Parameters:\n        `subset_as_json` : string, JSON\n            representation of Subset as specified in CSDL\n\n    :Returns:\n        `Subset` : an instance of this class\n    \"\"\"\n    subset_as_dict = json.loads(subset_as_json)\n    return cls.from_dict(subset_as_dict=subset_as_dict)\n</code></pre>"},{"location":"reference/objects/subset/#TM1py.Objects.Subset.Subset","title":"<code>Subset(subset_name, dimension_name, hierarchy_name=None, alias=None, expression=None, elements=None)</code>","text":"<p>               Bases: <code>TM1Object</code></p> <p>Abstraction of the TM1 Subset (dynamic and static)</p> <p>Parameters:</p> Name Type Description Default <code>subset_name</code> <code>str</code> <p>String</p> required <code>dimension_name</code> <code>str</code> <p>String</p> required <code>hierarchy_name</code> <code>str</code> <p>String</p> <code>None</code> <code>alias</code> <code>str</code> <p>String, alias that is active in this subset.</p> <code>None</code> <code>expression</code> <code>str</code> <p>String</p> <code>None</code> <code>elements</code> <code>Iterable[str]</code> <p>List, element names</p> <code>None</code> Source code in <code>TM1py/Objects/Subset.py</code> <pre><code>def __init__(\n    self,\n    subset_name: str,\n    dimension_name: str,\n    hierarchy_name: str = None,\n    alias: str = None,\n    expression: str = None,\n    elements: Iterable[str] = None,\n):\n    \"\"\"\n\n    :param subset_name: String\n    :param dimension_name: String\n    :param hierarchy_name: String\n    :param alias: String, alias that is active in this subset.\n    :param expression: String\n    :param elements: List, element names\n    \"\"\"\n    self._dimension_name = dimension_name\n    self._hierarchy_name = hierarchy_name if hierarchy_name else dimension_name\n    self._subset_name = subset_name\n    self._alias = alias\n    self._expression = expression\n    self._elements = list(elements) if elements else []\n</code></pre>"},{"location":"reference/objects/subset/#TM1py.Objects.Subset.Subset.alias","title":"<code>alias</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/subset/#TM1py.Objects.Subset.Subset.body","title":"<code>body</code>  <code>property</code>","text":"<p>same logic here as in TM1 : when subset has expression its dynamic, otherwise static</p>"},{"location":"reference/objects/subset/#TM1py.Objects.Subset.Subset.body_as_dict","title":"<code>body_as_dict</code>  <code>property</code>","text":"<p>same logic here as in TM1 : when subset has expression its dynamic, otherwise static</p>"},{"location":"reference/objects/subset/#TM1py.Objects.Subset.Subset.dimension_name","title":"<code>dimension_name</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/subset/#TM1py.Objects.Subset.Subset.elements","title":"<code>elements</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/subset/#TM1py.Objects.Subset.Subset.expression","title":"<code>expression</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/subset/#TM1py.Objects.Subset.Subset.hierarchy_name","title":"<code>hierarchy_name</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/subset/#TM1py.Objects.Subset.Subset.is_dynamic","title":"<code>is_dynamic</code>  <code>property</code>","text":""},{"location":"reference/objects/subset/#TM1py.Objects.Subset.Subset.is_static","title":"<code>is_static</code>  <code>property</code>","text":""},{"location":"reference/objects/subset/#TM1py.Objects.Subset.Subset.name","title":"<code>name</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/subset/#TM1py.Objects.Subset.Subset.type","title":"<code>type</code>  <code>property</code>","text":""},{"location":"reference/objects/subset/#TM1py.Objects.Subset.Subset.add_elements","title":"<code>add_elements(elements)</code>","text":"<p>add Elements to static subsets :Parameters:     <code>elements</code> : list of element names</p> Source code in <code>TM1py/Objects/Subset.py</code> <pre><code>def add_elements(self, elements: Iterable[str]):\n    \"\"\"add Elements to static subsets\n    :Parameters:\n        `elements` : list of element names\n    \"\"\"\n    self._elements = self._elements + list(elements)\n</code></pre>"},{"location":"reference/objects/subset/#TM1py.Objects.Subset.Subset.from_dict","title":"<code>from_dict(subset_as_dict)</code>  <code>classmethod</code>","text":"Source code in <code>TM1py/Objects/Subset.py</code> <pre><code>@classmethod\ndef from_dict(cls, subset_as_dict: Dict) -&gt; \"Subset\":\n    return cls(\n        dimension_name=subset_as_dict[\"UniqueName\"][1 : subset_as_dict[\"UniqueName\"].find(\"].[\")],\n        hierarchy_name=subset_as_dict.get(\"Hierarchy\", {}).get(\"Name\"),\n        subset_name=subset_as_dict[\"Name\"],\n        alias=subset_as_dict.get(\"Alias\"),\n        expression=subset_as_dict.get(\"Expression\"),\n        elements=(\n            [element[\"Name\"] for element in subset_as_dict.get(\"Elements\", [])]\n            if not subset_as_dict.get(\"Expression\")\n            else None\n        ),\n    )\n</code></pre>"},{"location":"reference/objects/subset/#TM1py.Objects.Subset.Subset.from_json","title":"<code>from_json(subset_as_json)</code>  <code>classmethod</code>","text":"<p>Alternative constructor :Parameters:     <code>subset_as_json</code> : string, JSON         representation of Subset as specified in CSDL</p> <p>:Returns:     <code>Subset</code> : an instance of this class</p> Source code in <code>TM1py/Objects/Subset.py</code> <pre><code>@classmethod\ndef from_json(cls, subset_as_json: str) -&gt; \"Subset\":\n    \"\"\"Alternative constructor\n    :Parameters:\n        `subset_as_json` : string, JSON\n            representation of Subset as specified in CSDL\n\n    :Returns:\n        `Subset` : an instance of this class\n    \"\"\"\n\n    subset_as_dict = json.loads(subset_as_json)\n    return cls.from_dict(subset_as_dict=subset_as_dict)\n</code></pre>"},{"location":"reference/objects/tm1object/","title":"TM1Object","text":""},{"location":"reference/objects/tm1object/#TM1py.Objects.TM1Object.TM1Object","title":"<code>TM1Object</code>","text":"<p>Parent Class for all TM1 Objects e.g. Cube, Process, Dimension.</p>"},{"location":"reference/objects/tm1object/#TM1py.Objects.TM1Object.TM1Object.SANDBOX_DIMENSION","title":"<code>SANDBOX_DIMENSION = 'Sandboxes'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/objects/tm1object/#TM1py.Objects.TM1Object.TM1Object.body","title":"<code>body</code>  <code>abstractmethod</code> <code>property</code>","text":""},{"location":"reference/objects/tm1object/#TM1py.Objects.TM1Object.TM1Object.__eq__","title":"<code>__eq__(other)</code>","text":"Source code in <code>TM1py/Objects/TM1Object.py</code> <pre><code>def __eq__(self, other):\n    return self.body == other.body\n</code></pre>"},{"location":"reference/objects/tm1object/#TM1py.Objects.TM1Object.TM1Object.__hash__","title":"<code>__hash__()</code>","text":"Source code in <code>TM1py/Objects/TM1Object.py</code> <pre><code>def __hash__(self):\n    return hash(self.body)\n</code></pre>"},{"location":"reference/objects/tm1object/#TM1py.Objects.TM1Object.TM1Object.__ne__","title":"<code>__ne__(other)</code>","text":"Source code in <code>TM1py/Objects/TM1Object.py</code> <pre><code>def __ne__(self, other):\n    return self.body != other.body\n</code></pre>"},{"location":"reference/objects/tm1object/#TM1py.Objects.TM1Object.TM1Object.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>TM1py/Objects/TM1Object.py</code> <pre><code>def __repr__(self):\n    return \"{}:{}\".format(self.__class__.__name__, self.body)\n</code></pre>"},{"location":"reference/objects/tm1object/#TM1py.Objects.TM1Object.TM1Object.__str__","title":"<code>__str__()</code>","text":"Source code in <code>TM1py/Objects/TM1Object.py</code> <pre><code>def __str__(self):\n    return self.body\n</code></pre>"},{"location":"reference/objects/user/","title":"User","text":""},{"location":"reference/objects/user/#TM1py.Objects.User.User","title":"<code>User(name, groups, friendly_name=None, password=None, user_type=None, enabled=None)</code>","text":"<p>               Bases: <code>TM1Object</code></p> <p>Abstraction of a TM1 User</p> Source code in <code>TM1py/Objects/User.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    groups: Iterable[str],\n    friendly_name: Optional[str] = None,\n    password: Optional[str] = None,\n    user_type: Union[UserType, str] = None,\n    enabled: bool = None,\n):\n    self._name = name\n    self._groups = CaseAndSpaceInsensitiveSet(*groups)\n    self._friendly_name = friendly_name\n    self._password = password\n    self._enabled = enabled\n    self._user_type = user_type\n    # determine user_type\n    if user_type is None:\n        if str(UserType.Admin) in self._groups:\n            self.user_type = UserType.Admin\n        elif str(UserType.SecurityAdmin) in self._groups:\n            self.user_type = UserType.SecurityAdmin\n        elif str(UserType.DataAdmin) in self._groups:\n            self.user_type = UserType.DataAdmin\n        elif str(UserType.OperationsAdmin) in self._groups:\n            self.user_type = UserType.OperationsAdmin\n        else:\n            self.user_type = UserType.User\n    else:\n        self.user_type = user_type\n</code></pre>"},{"location":"reference/objects/user/#TM1py.Objects.User.User.body","title":"<code>body</code>  <code>property</code>","text":""},{"location":"reference/objects/user/#TM1py.Objects.User.User.enabled","title":"<code>enabled</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/user/#TM1py.Objects.User.User.friendly_name","title":"<code>friendly_name</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/user/#TM1py.Objects.User.User.groups","title":"<code>groups</code>  <code>property</code>","text":""},{"location":"reference/objects/user/#TM1py.Objects.User.User.is_admin","title":"<code>is_admin</code>  <code>property</code>","text":""},{"location":"reference/objects/user/#TM1py.Objects.User.User.is_data_admin","title":"<code>is_data_admin</code>  <code>property</code>","text":""},{"location":"reference/objects/user/#TM1py.Objects.User.User.is_ops_admin","title":"<code>is_ops_admin</code>  <code>property</code>","text":""},{"location":"reference/objects/user/#TM1py.Objects.User.User.is_security_admin","title":"<code>is_security_admin</code>  <code>property</code>","text":""},{"location":"reference/objects/user/#TM1py.Objects.User.User.name","title":"<code>name</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/user/#TM1py.Objects.User.User.password","title":"<code>password</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/user/#TM1py.Objects.User.User.user_type","title":"<code>user_type</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/user/#TM1py.Objects.User.User.add_group","title":"<code>add_group(group_name)</code>","text":"Source code in <code>TM1py/Objects/User.py</code> <pre><code>def add_group(self, group_name: str):\n    self._groups.add(group_name)\n</code></pre>"},{"location":"reference/objects/user/#TM1py.Objects.User.User.construct_body","title":"<code>construct_body()</code>","text":"<p>construct body (json) from the class attributes</p> <p>Returns:</p> Type Description <code>str</code> <p>String, TM1 JSON representation of a user</p> Source code in <code>TM1py/Objects/User.py</code> <pre><code>def construct_body(self) -&gt; str:\n    \"\"\"\n    construct body (json) from the class attributes\n    :return: String, TM1 JSON representation of a user\n    \"\"\"\n    body_as_dict = collections.OrderedDict()\n    body_as_dict[\"Name\"] = self.name\n    body_as_dict[\"FriendlyName\"] = self.friendly_name or self.name\n    body_as_dict[\"Enabled\"] = self._enabled\n    body_as_dict[\"Type\"] = str(self._user_type)\n    if self.password:\n        body_as_dict[\"Password\"] = self._password\n    body_as_dict[\"Groups@odata.bind\"] = [format_url(\"Groups('{}')\", group) for group in self.groups]\n    return json.dumps(body_as_dict, ensure_ascii=False)\n</code></pre>"},{"location":"reference/objects/user/#TM1py.Objects.User.User.from_dict","title":"<code>from_dict(user_as_dict)</code>  <code>classmethod</code>","text":"<p>Alternative constructor</p> <p>Parameters:</p> Name Type Description Default <code>user_as_dict</code> <code>Dict</code> <p>user as dict</p> required <p>Returns:</p> Type Description <code>User</code> <p>user, an instance of this class</p> Source code in <code>TM1py/Objects/User.py</code> <pre><code>@classmethod\ndef from_dict(cls, user_as_dict: Dict) -&gt; \"User\":\n    \"\"\"Alternative constructor\n\n    :param user_as_dict: user as dict\n    :return: user, an instance of this class\n    \"\"\"\n    return cls(\n        name=user_as_dict[\"Name\"],\n        friendly_name=user_as_dict[\"FriendlyName\"],\n        enabled=user_as_dict.get(\"Enabled\", None),\n        user_type=user_as_dict[\"Type\"],\n        groups=[group[\"Name\"] for group in user_as_dict[\"Groups\"]],\n    )\n</code></pre>"},{"location":"reference/objects/user/#TM1py.Objects.User.User.from_json","title":"<code>from_json(user_as_json)</code>  <code>classmethod</code>","text":"<p>Alternative constructor</p> <p>Parameters:</p> Name Type Description Default <code>user_as_json</code> <code>str</code> <p>user as JSON string</p> required <p>Returns:</p> Type Description <p>user, an instance of this class</p> Source code in <code>TM1py/Objects/User.py</code> <pre><code>@classmethod\ndef from_json(cls, user_as_json: str):\n    \"\"\"Alternative constructor\n\n    :param user_as_json: user as JSON string\n    :return: user, an instance of this class\n    \"\"\"\n    user_as_dict = json.loads(user_as_json)\n    return cls.from_dict(user_as_dict)\n</code></pre>"},{"location":"reference/objects/user/#TM1py.Objects.User.User.remove_group","title":"<code>remove_group(group_name)</code>","text":"Source code in <code>TM1py/Objects/User.py</code> <pre><code>def remove_group(self, group_name: str):\n    self._groups.discard(group_name)\n</code></pre>"},{"location":"reference/objects/user/#TM1py.Objects.User.UserType","title":"<code>UserType</code>","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"reference/objects/user/#TM1py.Objects.User.UserType.Admin","title":"<code>Admin = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/objects/user/#TM1py.Objects.User.UserType.DataAdmin","title":"<code>DataAdmin = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/objects/user/#TM1py.Objects.User.UserType.OperationsAdmin","title":"<code>OperationsAdmin = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/objects/user/#TM1py.Objects.User.UserType.SecurityAdmin","title":"<code>SecurityAdmin = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/objects/user/#TM1py.Objects.User.UserType.User","title":"<code>User = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/objects/user/#TM1py.Objects.User.UserType.__str__","title":"<code>__str__()</code>","text":"Source code in <code>TM1py/Objects/User.py</code> <pre><code>def __str__(self):\n    return self.name\n</code></pre>"},{"location":"reference/objects/view/","title":"View","text":""},{"location":"reference/objects/view/#TM1py.Objects.View.View","title":"<code>View(cube, name)</code>","text":"<p>               Bases: <code>TM1Object</code></p> <p>Abstraction of TM1 View serves as a parentclass for TM1py.Objects.MDXView and TM1py.Objects.NativeView</p> Source code in <code>TM1py/Objects/View.py</code> <pre><code>def __init__(self, cube: str, name: str):\n    self._cube = cube\n    self._name = name\n</code></pre>"},{"location":"reference/objects/view/#TM1py.Objects.View.View.cube","title":"<code>cube</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/view/#TM1py.Objects.View.View.mdx","title":"<code>mdx</code>  <code>property</code>","text":""},{"location":"reference/objects/view/#TM1py.Objects.View.View.name","title":"<code>name</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/objects/view/#TM1py.Objects.View.View.body","title":"<code>body()</code>  <code>abstractmethod</code>","text":"Source code in <code>TM1py/Objects/View.py</code> <pre><code>@abstractmethod\ndef body(self) -&gt; str:\n    pass\n</code></pre>"},{"location":"reference/services/annotationservice/","title":"AnnotationService","text":""},{"location":"reference/services/annotationservice/#TM1py.Services.AnnotationService.AnnotationService","title":"<code>AnnotationService(rest)</code>","text":"<p>               Bases: <code>ObjectService</code></p> <p>Service to handle Object Updates for TM1 CellAnnotations</p> Source code in <code>TM1py/Services/AnnotationService.py</code> <pre><code>def __init__(self, rest: RestService):\n    super().__init__(rest)\n</code></pre>"},{"location":"reference/services/annotationservice/#TM1py.Services.AnnotationService.AnnotationService.create","title":"<code>create(annotation, **kwargs)</code>","text":"<p>create an Annotation</p> <p>Parameters:</p> Name Type Description Default <code>annotation</code> <code>Annotation</code> <p>instance of TM1py.Annotation</p> required Source code in <code>TM1py/Services/AnnotationService.py</code> <pre><code>def create(self, annotation: Annotation, **kwargs) -&gt; Response:\n    \"\"\"create an Annotation\n\n    :param annotation: instance of TM1py.Annotation\n    \"\"\"\n    url = \"/Annotations\"\n\n    from TM1py import CubeService\n\n    cube_dimensions = CubeService(self._rest).get_dimension_names(\n        cube_name=annotation.object_name, skip_sandbox_dimension=True\n    )\n\n    response = self._rest.POST(url, json.dumps(annotation.construct_body_for_post(cube_dimensions)), **kwargs)\n    return response\n</code></pre>"},{"location":"reference/services/annotationservice/#TM1py.Services.AnnotationService.AnnotationService.create_many","title":"<code>create_many(annotations, **kwargs)</code>","text":"<p>create an Annotation</p> <p>Parameters:</p> Name Type Description Default <code>annotations</code> <code>Iterable[Annotation]</code> <p>instances of TM1py.Annotation</p> required Source code in <code>TM1py/Services/AnnotationService.py</code> <pre><code>def create_many(self, annotations: Iterable[Annotation], **kwargs) -&gt; Response:\n    \"\"\"create an Annotation\n\n    :param annotations: instances of TM1py.Annotation\n    \"\"\"\n    payload = list()\n    cube_dimensions = CaseAndSpaceInsensitiveDict()\n\n    for annotation in annotations:\n        dimension_names = cube_dimensions.get(annotation.object_name, None)\n        if not dimension_names:\n            from TM1py import CubeService\n\n            dimension_names = CubeService(self._rest).get_dimension_names(\n                cube_name=annotation.object_name, skip_sandbox_dimension=True\n            )\n\n            cube_dimensions[annotation.object_name] = dimension_names\n        payload.append(annotation.construct_body_for_post(dimension_names))\n\n    response = self._rest.POST(\"/Annotations\", json.dumps(payload), **kwargs)\n\n    return response\n</code></pre>"},{"location":"reference/services/annotationservice/#TM1py.Services.AnnotationService.AnnotationService.delete","title":"<code>delete(annotation_id, **kwargs)</code>","text":"<p>delete Annotation</p> <p>Parameters:</p> Name Type Description Default <code>annotation_id</code> <code>str</code> <p>string, the id of the annotation</p> required Source code in <code>TM1py/Services/AnnotationService.py</code> <pre><code>def delete(self, annotation_id: str, **kwargs) -&gt; Response:\n    \"\"\"delete Annotation\n\n    :param annotation_id: string, the id of the annotation\n    \"\"\"\n    url = format_url(\"/Annotations('{}')\", annotation_id)\n    return self._rest.DELETE(url=url, **kwargs)\n</code></pre>"},{"location":"reference/services/annotationservice/#TM1py.Services.AnnotationService.AnnotationService.get","title":"<code>get(annotation_id, **kwargs)</code>","text":"<p>get an annotation from any cube through its unique id</p> <p>Parameters:</p> Name Type Description Default <code>annotation_id</code> <code>str</code> <p>String, the id of the annotation</p> required Source code in <code>TM1py/Services/AnnotationService.py</code> <pre><code>def get(self, annotation_id: str, **kwargs) -&gt; Annotation:\n    \"\"\"get an annotation from any cube through its unique id\n\n    :param annotation_id: String, the id of the annotation\n    \"\"\"\n    request = format_url(\"/Annotations('{}')?$expand=DimensionalContext($select=Name)\", annotation_id)\n    response = self._rest.GET(url=request, **kwargs)\n    return Annotation.from_json(response.text)\n</code></pre>"},{"location":"reference/services/annotationservice/#TM1py.Services.AnnotationService.AnnotationService.get_all","title":"<code>get_all(cube_name, **kwargs)</code>","text":"<p>get all annotations from given cube as a List.</p> <p>Parameters:</p> Name Type Description Default <code>cube_name</code> <code>str</code> required Source code in <code>TM1py/Services/AnnotationService.py</code> <pre><code>def get_all(self, cube_name: str, **kwargs) -&gt; List[Annotation]:\n    \"\"\"get all annotations from given cube as a List.\n\n    :param cube_name:\n    \"\"\"\n    url = format_url(\"/Cubes('{}')/Annotations?$expand=DimensionalContext($select=Name)\", cube_name)\n    response = self._rest.GET(url, **kwargs)\n\n    annotations_as_dict = response.json()[\"value\"]\n    annotations = [Annotation.from_json(json.dumps(element)) for element in annotations_as_dict]\n    return annotations\n</code></pre>"},{"location":"reference/services/annotationservice/#TM1py.Services.AnnotationService.AnnotationService.update","title":"<code>update(annotation, **kwargs)</code>","text":"<p>update Annotation. updateable attributes: commentValue</p> <p>Parameters:</p> Name Type Description Default <code>annotation</code> <code>Annotation</code> <p>instance of TM1py.Annotation</p> required Source code in <code>TM1py/Services/AnnotationService.py</code> <pre><code>def update(self, annotation: Annotation, **kwargs) -&gt; Response:\n    \"\"\"update Annotation.\n    updateable attributes: commentValue\n\n    :param annotation: instance of TM1py.Annotation\n    \"\"\"\n    url = format_url(\"/Annotations('{}')\", annotation.id)\n    return self._rest.PATCH(url=url, data=annotation.body, **kwargs)\n</code></pre>"},{"location":"reference/services/applicationservice/","title":"ApplicationService","text":""},{"location":"reference/services/applicationservice/#TM1py.Services.ApplicationService.ApplicationService","title":"<code>ApplicationService(tm1_rest)</code>","text":"<p>               Bases: <code>ObjectService</code></p> <p>Service to Read and Write TM1 Applications</p> <p>Parameters:</p> Name Type Description Default <code>tm1_rest</code> <code>RestService</code> required Source code in <code>TM1py/Services/ApplicationService.py</code> <pre><code>def __init__(self, tm1_rest: RestService):\n    \"\"\"\n\n    :param tm1_rest:\n    \"\"\"\n    super().__init__(tm1_rest)\n    self._rest = tm1_rest\n    self._private_path_cache: Dict[str, int] = {}\n</code></pre>"},{"location":"reference/services/applicationservice/#TM1py.Services.ApplicationService.ApplicationService.create","title":"<code>create(application, private=False, use_cache=False, **kwargs)</code>","text":"<p>Create Planning Analytics application</p> <p>Automatically handles mixed public/private folder hierarchies.</p> <p>Parameters:</p> Name Type Description Default <code>application</code> <code>Union[Application, DocumentApplication]</code> <p>instance of Application</p> required <code>private</code> <code>bool</code> <p>boolean</p> <code>False</code> <code>use_cache</code> <code>bool</code> <p>boolean - whether to cache discovered private boundaries</p> <code>False</code> <p>Returns:</p> Type Description <code>Response</code> Source code in <code>TM1py/Services/ApplicationService.py</code> <pre><code>def create(self, application: Union[Application, DocumentApplication], private: bool = False,\n           use_cache: bool = False, **kwargs) -&gt; Response:\n    \"\"\"Create Planning Analytics application\n\n    Automatically handles mixed public/private folder hierarchies.\n\n    :param application: instance of Application\n    :param private: boolean\n    :param use_cache: boolean - whether to cache discovered private boundaries\n    :return:\n    \"\"\"\n    base_url, in_private_context = self._resolve_path(application.path, private, use_cache, **kwargs)\n\n    # Use PrivateContents if we're in a private context OR if private=True\n    contents = \"PrivateContents\" if (private or in_private_context) else \"Contents\"\n    url = base_url + \"/\" + contents\n\n    response = self._rest.POST(url, application.body, **kwargs)\n\n    if application.application_type == ApplicationTypes.DOCUMENT:\n        url = format_url(\n            base_url + \"/\" + contents + \"('{name}{suffix}')/Document/Content\",\n            name=application.name,\n            suffix=\".blob\" if not verify_version(required_version=\"12\", version=self.version) else \"\",\n        )\n        response = self._rest.PUT(url, application.content, headers=self.binary_http_header, **kwargs)\n\n    return response\n</code></pre>"},{"location":"reference/services/applicationservice/#TM1py.Services.ApplicationService.ApplicationService.create_document_from_file","title":"<code>create_document_from_file(path_to_file, application_path, application_name, private=False, use_cache=False, **kwargs)</code>","text":"<p>Create DocumentApplication in TM1 from local file</p> <p>Automatically handles mixed public/private folder hierarchies.</p> <p>Parameters:</p> Name Type Description Default <code>path_to_file</code> <code>str</code> required <code>application_path</code> <code>str</code> required <code>application_name</code> <code>str</code> required <code>private</code> <code>bool</code> <code>False</code> <code>use_cache</code> <code>bool</code> <p>boolean - whether to cache discovered private boundaries</p> <code>False</code> <p>Returns:</p> Type Description <code>Response</code> Source code in <code>TM1py/Services/ApplicationService.py</code> <pre><code>def create_document_from_file(\n    self, path_to_file: str, application_path: str, application_name: str, private: bool = False,\n    use_cache: bool = False, **kwargs\n) -&gt; Response:\n    \"\"\"Create DocumentApplication in TM1 from local file\n\n    Automatically handles mixed public/private folder hierarchies.\n\n    :param path_to_file:\n    :param application_path:\n    :param application_name:\n    :param private:\n    :param use_cache: boolean - whether to cache discovered private boundaries\n    :return:\n    \"\"\"\n    with open(path_to_file, \"rb\") as file:\n        application = DocumentApplication(path=application_path, name=application_name, content=file.read())\n        return self.create(application=application, private=private, use_cache=use_cache, **kwargs)\n</code></pre>"},{"location":"reference/services/applicationservice/#TM1py.Services.ApplicationService.ApplicationService.delete","title":"<code>delete(path, application_type, application_name, private=False, use_cache=False, **kwargs)</code>","text":"<p>Delete Planning Analytics application reference</p> <p>Automatically handles mixed public/private folder hierarchies.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>path through folder structure to delete the applications entry. For instance: \"Finance/Reports\"</p> required <code>application_type</code> <code>Union[str, ApplicationTypes]</code> <p>type of the to be deleted application entry</p> required <code>application_name</code> <code>str</code> <p>name of the to be deleted application entry</p> required <code>private</code> <code>bool</code> <p>Access level of the to be deleted object</p> <code>False</code> <code>use_cache</code> <code>bool</code> <p>boolean - whether to cache discovered private boundaries</p> <code>False</code> <p>Returns:</p> Type Description <code>Response</code> Source code in <code>TM1py/Services/ApplicationService.py</code> <pre><code>def delete(\n    self,\n    path: str,\n    application_type: Union[str, ApplicationTypes],\n    application_name: str,\n    private: bool = False,\n    use_cache: bool = False,\n    **kwargs,\n) -&gt; Response:\n    \"\"\"Delete Planning Analytics application reference\n\n    Automatically handles mixed public/private folder hierarchies.\n\n    :param path: path through folder structure to delete the applications entry. For instance: \"Finance/Reports\"\n    :param application_type: type of the to be deleted application entry\n    :param application_name: name of the to be deleted application entry\n    :param private: Access level of the to be deleted object\n    :param use_cache: boolean - whether to cache discovered private boundaries\n    :return:\n    \"\"\"\n    # raise ValueError if not a valid ApplicationType\n    application_type = ApplicationTypes(application_type)\n\n    if not application_type == ApplicationTypes.FOLDER and not verify_version(\n        required_version=\"12\", version=self.version\n    ):\n        application_name += application_type.suffix\n\n    base_url, in_private_context = self._resolve_path(path, private, use_cache, **kwargs)\n\n    # Use PrivateContents if we're in a private context OR if private=True\n    contents = \"PrivateContents\" if (private or in_private_context) else \"Contents\"\n    url = format_url(base_url + \"/\" + contents + \"('{}')\", application_name)\n\n    return self._rest.DELETE(url, **kwargs)\n</code></pre>"},{"location":"reference/services/applicationservice/#TM1py.Services.ApplicationService.ApplicationService.discover","title":"<code>discover(path='', include_private=False, recursive=False, flat=False, **kwargs)</code>","text":"<p>Discover applications in the Applications folder.</p> <p>Traverses the application hierarchy and returns information about all discovered items including folders, documents, views, and other references.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>starting path (empty string = root 'Applications' folder)</p> <code>''</code> <code>include_private</code> <code>bool</code> <p>whether to include private assets in the results</p> <code>False</code> <code>recursive</code> <code>bool</code> <p>whether to recurse into subfolders</p> <code>False</code> <code>flat</code> <code>bool</code> <p>if True, returns a flat list; if False (default), returns nested structure</p> <code>False</code> <p>Returns:</p> Type Description <code>List[Dict]</code> <p>list of dictionaries with keys: @odata.type, type, id, name, path, is_private - @odata.type: full OData type (e.g., '#ibm.tm1.api.v1.Folder') - type: simplified type name (e.g., 'Folder') For nested mode, folders also have a 'children' key when recursive=True</p> Source code in <code>TM1py/Services/ApplicationService.py</code> <pre><code>def discover(\n    self,\n    path: str = \"\",\n    include_private: bool = False,\n    recursive: bool = False,\n    flat: bool = False,\n    **kwargs\n) -&gt; List[Dict]:\n    \"\"\"Discover applications in the Applications folder.\n\n    Traverses the application hierarchy and returns information about all\n    discovered items including folders, documents, views, and other references.\n\n    :param path: starting path (empty string = root 'Applications' folder)\n    :param include_private: whether to include private assets in the results\n    :param recursive: whether to recurse into subfolders\n    :param flat: if True, returns a flat list; if False (default), returns nested structure\n    :return: list of dictionaries with keys: @odata.type, type, id, name, path, is_private\n             - @odata.type: full OData type (e.g., '#ibm.tm1.api.v1.Folder')\n             - type: simplified type name (e.g., 'Folder')\n             For nested mode, folders also have a 'children' key when recursive=True\n    \"\"\"\n    results = []  # Accumulator for flat mode\n\n    # Determine if we're starting in a private context (path contains private folders)\n    in_private_context = False\n    if path.strip() and include_private:\n        _, in_private_context = self._resolve_path(path, private=True, use_cache=False, **kwargs)\n\n    # Use the unified discovery method\n    items = self._discover_at_path(\n        path=path,\n        include_private=include_private,\n        recursive=recursive,\n        flat=flat,\n        in_private_context=in_private_context,\n        results=results,\n        **kwargs\n    )\n\n    return results if flat else items\n</code></pre>"},{"location":"reference/services/applicationservice/#TM1py.Services.ApplicationService.ApplicationService.exists","title":"<code>exists(path, application_type, name, private=False, use_cache=False, **kwargs)</code>","text":"<p>Check if application exists</p> <p>Automatically handles mixed public/private folder hierarchies.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> required <code>application_type</code> <code>Union[str, ApplicationTypes]</code> required <code>name</code> <code>str</code> required <code>private</code> <code>bool</code> <code>False</code> <code>use_cache</code> <code>bool</code> <p>boolean - whether to cache discovered private boundaries</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> Source code in <code>TM1py/Services/ApplicationService.py</code> <pre><code>def exists(\n    self, path: str, application_type: Union[str, ApplicationTypes], name: str, private: bool = False,\n    use_cache: bool = False, **kwargs\n) -&gt; bool:\n    \"\"\"Check if application exists\n\n    Automatically handles mixed public/private folder hierarchies.\n\n    :param path:\n    :param application_type:\n    :param name:\n    :param private:\n    :param use_cache: boolean - whether to cache discovered private boundaries\n    :return:\n    \"\"\"\n    # raise ValueError if not a valid ApplicationType\n    application_type = ApplicationTypes(application_type)\n\n    if not application_type == ApplicationTypes.FOLDER and not verify_version(\n        required_version=\"12\", version=self.version\n    ):\n        name += application_type.suffix\n\n    # For exists check with private=True, we need special handling\n    # because we want to check both public and private paths\n    if not private:\n        # Simple public check\n        segments = path.split(\"/\") if path.strip() else []\n        mid = self._build_path_url(segments, None)\n        url = \"/Contents('Applications')\" + mid + \"/Contents('\" + name + \"')\"\n        return self._exists(url, **kwargs)\n\n    # For private access, first try to resolve the path\n    segments = path.split(\"/\") if path.strip() else []\n\n    if not segments:\n        # Root level - just check directly\n        url = \"/Contents('Applications')/PrivateContents('\" + name + \"')\"\n        return self._exists(url, **kwargs)\n\n    # Check cache first\n    cache_key = \"/\".join(segments)\n    if use_cache and cache_key in self._private_path_cache:\n        boundary = self._private_path_cache[cache_key]\n        mid = self._build_path_url(segments, boundary)\n        in_private_context = boundary &lt; len(segments)\n        contents = \"PrivateContents\" if in_private_context else \"Contents\"\n        url = \"/Contents('Applications')\" + mid + \"/\" + contents + \"('\" + name + \"')\"\n        return self._exists(url, **kwargs)\n\n    # Try all-public path first\n    mid_public = self._build_path_url(segments, None)\n    url_public = \"/Contents('Applications')\" + mid_public + \"/PrivateContents('\" + name + \"')\"\n    if self._exists(url_public, **kwargs):\n        if use_cache:\n            self._private_path_cache[cache_key] = len(segments)\n        return True\n\n    # Try to find the private boundary\n    boundary = self._find_private_boundary(segments, **kwargs)\n\n    if boundary == -1:\n        return False  # Path doesn't exist\n\n    if use_cache:\n        self._private_path_cache[cache_key] = boundary\n\n    mid = self._build_path_url(segments, boundary)\n    # If path has private folders, item must be accessed via PrivateContents\n    contents = \"PrivateContents\" if boundary &lt; len(segments) else \"PrivateContents\"\n    url = \"/Contents('Applications')\" + mid + \"/\" + contents + \"('\" + name + \"')\"\n    return self._exists(url, **kwargs)\n</code></pre>"},{"location":"reference/services/applicationservice/#TM1py.Services.ApplicationService.ApplicationService.get","title":"<code>get(path, application_type, name, private=False, use_cache=False, **kwargs)</code>","text":"<p>Retrieve Planning Analytics Application</p> <p>Automatically handles mixed public/private folder hierarchies.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>path with forward slashes</p> required <code>application_type</code> <code>Union[str, ApplicationTypes]</code> <p>str or ApplicationType from Enum</p> required <code>name</code> <code>str</code> required <code>private</code> <code>bool</code> <code>False</code> <code>use_cache</code> <code>bool</code> <p>boolean - whether to cache discovered private boundaries</p> <code>False</code> <p>Returns:</p> Type Description <code>Application</code> Source code in <code>TM1py/Services/ApplicationService.py</code> <pre><code>def get(\n    self, path: str, application_type: Union[str, ApplicationTypes], name: str, private: bool = False,\n    use_cache: bool = False, **kwargs\n) -&gt; Application:\n    \"\"\"Retrieve Planning Analytics Application\n\n    Automatically handles mixed public/private folder hierarchies.\n\n    :param path: path with forward slashes\n    :param application_type: str or ApplicationType from Enum\n    :param name:\n    :param private:\n    :param use_cache: boolean - whether to cache discovered private boundaries\n    :return:\n    \"\"\"\n    # raise ValueError if not a valid ApplicationType\n    application_type = ApplicationTypes(application_type)\n\n    # documents require special treatment\n    if application_type == ApplicationTypes.DOCUMENT:\n        return self.get_document(path=path, name=name, private=private, use_cache=use_cache, **kwargs)\n\n    if not application_type == ApplicationTypes.FOLDER and not verify_version(\n        required_version=\"12\", version=self.version\n    ):\n        name += application_type.suffix\n\n    base_url, in_private_context = self._resolve_path(path, private, use_cache, **kwargs)\n\n    # Use PrivateContents if we're in a private context OR if private=True\n    contents = \"PrivateContents\" if (private or in_private_context) else \"Contents\"\n    base_url = format_url(base_url + \"/\" + contents + \"('{}')\", name)\n\n    if application_type == ApplicationTypes.CUBE:\n        response = self._rest.GET(url=base_url + \"?$expand=Cube($select=Name)\", **kwargs)\n        return CubeApplication(path=path, name=name, cube_name=response.json()[\"Cube\"][\"Name\"])\n\n    elif application_type == ApplicationTypes.CHORE:\n        response = self._rest.GET(url=base_url + \"?$expand=Chore($select=Name)\", **kwargs)\n        return ChoreApplication(path=path, name=name, chore_name=response.json()[\"Chore\"][\"Name\"])\n\n    elif application_type == ApplicationTypes.DIMENSION:\n        response = self._rest.GET(url=base_url + \"?$expand=Dimension($select=Name)\", **kwargs)\n        return DimensionApplication(path=path, name=name, dimension_name=response.json()[\"Dimension\"][\"Name\"])\n\n    elif application_type == ApplicationTypes.FOLDER:\n        # implicit TM1pyException if application doesn't exist\n        self._rest.GET(url=base_url, **kwargs)\n        return FolderApplication(path=path, name=name)\n\n    elif application_type == ApplicationTypes.LINK:\n        # implicit TM1pyException if application doesn't exist\n        self._rest.GET(url=base_url, **kwargs)\n        response = self._rest.GET(base_url + \"?$expand=*\", **kwargs)\n        return LinkApplication(path=path, name=name, url=response.json()[\"URL\"])\n\n    elif application_type == ApplicationTypes.PROCESS:\n        response = self._rest.GET(url=base_url + \"?$expand=Process($select=Name)\", **kwargs)\n        return ProcessApplication(path=path, name=name, process_name=response.json()[\"Process\"][\"Name\"])\n\n    elif application_type == ApplicationTypes.SUBSET:\n        url = \"\".join(\n            [\n                base_url,\n                \"?$expand=Subset($select=Name;$expand=Hierarchy($select=Name;$expand=Dimension($select=Name)))\",\n            ]\n        )\n        response = self._rest.GET(url=url, **kwargs)\n        return SubsetApplication(\n            path=path,\n            name=name,\n            dimension_name=response.json()[\"Subset\"][\"Hierarchy\"][\"Dimension\"][\"Name\"],\n            hierarchy_name=response.json()[\"Subset\"][\"Hierarchy\"][\"Name\"],\n            subset_name=response.json()[\"Subset\"][\"Name\"],\n        )\n\n    elif application_type == ApplicationTypes.VIEW:\n        response = self._rest.GET(url=base_url + \"?$expand=View($select=Name;$expand=Cube($select=Name))\", **kwargs)\n        return ViewApplication(\n            path=path,\n            name=name,\n            cube_name=response.json()[\"View\"][\"Cube\"][\"Name\"],\n            view_name=response.json()[\"View\"][\"Name\"],\n        )\n</code></pre>"},{"location":"reference/services/applicationservice/#TM1py.Services.ApplicationService.ApplicationService.get_all_private_root_names","title":"<code>get_all_private_root_names(**kwargs)</code>","text":"<p>Retrieve all private root application names.</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <p>Additional arguments for the REST request.</p> <code>{}</code> <p>Returns:</p> Type Description <p>List of private root application names.</p> Source code in <code>TM1py/Services/ApplicationService.py</code> <pre><code>def get_all_private_root_names(self, **kwargs):\n    \"\"\"\n    Retrieve all private root application names.\n\n    :param kwargs: Additional arguments for the REST request.\n    :return: List of private root application names.\n    \"\"\"\n    url = \"/Contents('Applications')/PrivateContents\"\n    response = self._rest.GET(url, **kwargs)\n    applications = list(application[\"Name\"] for application in response.json()[\"value\"])\n    return applications\n</code></pre>"},{"location":"reference/services/applicationservice/#TM1py.Services.ApplicationService.ApplicationService.get_all_public_root_names","title":"<code>get_all_public_root_names(**kwargs)</code>","text":"<p>Retrieve all public root application names.</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <p>Additional arguments for the REST request.</p> <code>{}</code> <p>Returns:</p> Type Description <p>List of public root application names.</p> Source code in <code>TM1py/Services/ApplicationService.py</code> <pre><code>def get_all_public_root_names(self, **kwargs):\n    \"\"\"\n    Retrieve all public root application names.\n\n    :param kwargs: Additional arguments for the REST request.\n    :return: List of public root application names.\n    \"\"\"\n    url = \"/Contents('Applications')/Contents\"\n    response = self._rest.GET(url, **kwargs)\n    applications = list(application[\"Name\"] for application in response.json()[\"value\"])\n    return applications\n</code></pre>"},{"location":"reference/services/applicationservice/#TM1py.Services.ApplicationService.ApplicationService.get_document","title":"<code>get_document(path, name, private=False, use_cache=False, **kwargs)</code>","text":"<p>Get Excel Application from TM1 Server in binary format. Can be dumped to file.</p> <p>Automatically handles mixed public/private folder hierarchies.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>path through folder structure to application. For instance: \"Finance/P&amp;L.xlsx\"</p> required <code>name</code> <code>str</code> <p>name of the application</p> required <code>private</code> <code>bool</code> <p>boolean</p> <code>False</code> <code>use_cache</code> <code>bool</code> <p>boolean - whether to cache discovered private boundaries</p> <code>False</code> <p>Returns:</p> Type Description <code>DocumentApplication</code> <p>Return DocumentApplication</p> Source code in <code>TM1py/Services/ApplicationService.py</code> <pre><code>def get_document(self, path: str, name: str, private: bool = False, use_cache: bool = False,\n                 **kwargs) -&gt; DocumentApplication:\n    \"\"\"Get Excel Application from TM1 Server in binary format. Can be dumped to file.\n\n    Automatically handles mixed public/private folder hierarchies.\n\n    :param path: path through folder structure to application. For instance: \"Finance/P&amp;L.xlsx\"\n    :param name: name of the application\n    :param private: boolean\n    :param use_cache: boolean - whether to cache discovered private boundaries\n    :return: Return DocumentApplication\n    \"\"\"\n    if not name.endswith(ApplicationTypes.DOCUMENT.suffix) and not verify_version(\n        required_version=\"12\", version=self.version\n    ):\n        name += ApplicationTypes.DOCUMENT.suffix\n\n    base_url, in_private_context = self._resolve_path(path, private, use_cache, **kwargs)\n\n    # Use PrivateContents if we're in a private context OR if private=True\n    contents = \"PrivateContents\" if (private or in_private_context) else \"Contents\"\n\n    url = format_url(base_url + \"/\" + contents + \"('{}')/Document/Content\", name)\n    content = self._rest.GET(url, **kwargs).content\n\n    url = format_url(base_url + \"/\" + contents + \"('{}')/Document\", name)\n    document_fields = self._rest.GET(url, **kwargs).json()\n\n    return DocumentApplication(\n        path=path,\n        name=name,\n        content=content,\n        file_id=document_fields.get(\"ID\"),\n        file_name=document_fields.get(\"Name\"),\n        last_updated=document_fields.get(\"LastUpdated\"),\n    )\n</code></pre>"},{"location":"reference/services/applicationservice/#TM1py.Services.ApplicationService.ApplicationService.get_names","title":"<code>get_names(path, private=False, use_cache=False, **kwargs)</code>","text":"<p>Retrieve Planning Analytics Application names in given path</p> <p>Automatically handles mixed public/private folder hierarchies.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>path with forward slashes</p> required <code>private</code> <code>bool</code> <p>boolean - whether to retrieve private or public contents at the leaf</p> <code>False</code> <code>use_cache</code> <code>bool</code> <p>boolean - whether to cache discovered private boundaries</p> <code>False</code> <p>Returns:</p> Type Description <p>list of application names</p> Source code in <code>TM1py/Services/ApplicationService.py</code> <pre><code>def get_names(self, path: str, private: bool = False, use_cache: bool = False, **kwargs):\n    \"\"\"Retrieve Planning Analytics Application names in given path\n\n    Automatically handles mixed public/private folder hierarchies.\n\n    :param path: path with forward slashes\n    :param private: boolean - whether to retrieve private or public contents at the leaf\n    :param use_cache: boolean - whether to cache discovered private boundaries\n    :return: list of application names\n    \"\"\"\n    base_url, in_private_context = self._resolve_path(path, private, use_cache, **kwargs)\n\n    # Use PrivateContents if we're in a private context OR if private=True\n    contents = \"PrivateContents\" if (private or in_private_context) else \"Contents\"\n    url = base_url + \"/\" + contents\n\n    response = self._rest.GET(url=url, **kwargs)\n    return [application[\"Name\"] for application in response.json()[\"value\"]]\n</code></pre>"},{"location":"reference/services/applicationservice/#TM1py.Services.ApplicationService.ApplicationService.rename","title":"<code>rename(path, application_type, application_name, new_application_name, private=False, use_cache=False, **kwargs)</code>","text":"<p>Rename a Planning Analytics application.</p> <p>Automatically handles mixed public/private folder hierarchies.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>path through folder structure</p> required <code>application_type</code> <code>Union[str, ApplicationTypes]</code> <p>type of the application</p> required <code>application_name</code> <code>str</code> <p>current name of the application</p> required <code>new_application_name</code> <code>str</code> <p>new name for the application</p> required <code>private</code> <code>bool</code> <p>Access level of the object</p> <code>False</code> <code>use_cache</code> <code>bool</code> <p>boolean - whether to cache discovered private boundaries</p> <code>False</code> <p>Returns:</p> Type Description Source code in <code>TM1py/Services/ApplicationService.py</code> <pre><code>def rename(\n    self,\n    path: str,\n    application_type: Union[str, ApplicationTypes],\n    application_name: str,\n    new_application_name: str,\n    private: bool = False,\n    use_cache: bool = False,\n    **kwargs,\n):\n    \"\"\"Rename a Planning Analytics application.\n\n    Automatically handles mixed public/private folder hierarchies.\n\n    :param path: path through folder structure\n    :param application_type: type of the application\n    :param application_name: current name of the application\n    :param new_application_name: new name for the application\n    :param private: Access level of the object\n    :param use_cache: boolean - whether to cache discovered private boundaries\n    :return:\n    \"\"\"\n    # raise ValueError if not a valid ApplicationType\n    application_type = ApplicationTypes(application_type)\n\n    if not application_type == ApplicationTypes.FOLDER and not verify_version(\n        required_version=\"12\", version=self.version\n    ):\n        application_name += application_type.suffix\n\n    base_url, in_private_context = self._resolve_path(path, private, use_cache, **kwargs)\n\n    # Use PrivateContents if we're in a private context OR if private=True\n    contents = \"PrivateContents\" if (private or in_private_context) else \"Contents\"\n    url = format_url(base_url + \"/\" + contents + \"('{}')/tm1.Move\", application_name)\n\n    data = {\"Name\": new_application_name}\n    return self._rest.POST(url, data=json.dumps(data), **kwargs)\n</code></pre>"},{"location":"reference/services/applicationservice/#TM1py.Services.ApplicationService.ApplicationService.update","title":"<code>update(application, private=False, use_cache=False, **kwargs)</code>","text":"<p>Update Planning Analytics application</p> <p>Automatically handles mixed public/private folder hierarchies.</p> <p>Parameters:</p> Name Type Description Default <code>application</code> <code>Union[Application, DocumentApplication]</code> <p>instance of Application</p> required <code>private</code> <code>bool</code> <p>boolean</p> <code>False</code> <code>use_cache</code> <code>bool</code> <p>boolean - whether to cache discovered private boundaries</p> <code>False</code> <p>Returns:</p> Type Description <code>Response</code> Source code in <code>TM1py/Services/ApplicationService.py</code> <pre><code>def update(self, application: Union[Application, DocumentApplication], private: bool = False,\n           use_cache: bool = False, **kwargs) -&gt; Response:\n    \"\"\"Update Planning Analytics application\n\n    Automatically handles mixed public/private folder hierarchies.\n\n    :param application: instance of Application\n    :param private: boolean\n    :param use_cache: boolean - whether to cache discovered private boundaries\n    :return:\n    \"\"\"\n    base_url, in_private_context = self._resolve_path(application.path, private, use_cache, **kwargs)\n\n    # Use PrivateContents if we're in a private context OR if private=True\n    contents = \"PrivateContents\" if (private or in_private_context) else \"Contents\"\n\n    if application.application_type == ApplicationTypes.DOCUMENT:\n        url = format_url(\n            base_url + \"/\" + contents + \"('{name}{extension}')/Document/Content\",\n            name=application.name,\n            extension=\"\" if verify_version(\"12\", self.version) else \".blob\"\n        )\n        response = self._rest.PATCH(url=url, data=application.content, headers=self.binary_http_header, **kwargs)\n    else:\n        url = base_url + \"/\" + contents\n        response = self._rest.POST(url, application.body, **kwargs)\n\n    return response\n</code></pre>"},{"location":"reference/services/applicationservice/#TM1py.Services.ApplicationService.ApplicationService.update_document_from_file","title":"<code>update_document_from_file(path_to_file, application_path, application_name, private=False, use_cache=False, **kwargs)</code>","text":"<p>Update DocumentApplication in TM1 from local file</p> <p>Automatically handles mixed public/private folder hierarchies.</p> <p>Parameters:</p> Name Type Description Default <code>path_to_file</code> <code>str</code> required <code>application_path</code> <code>str</code> required <code>application_name</code> <code>str</code> required <code>private</code> <code>bool</code> <code>False</code> <code>use_cache</code> <code>bool</code> <p>boolean - whether to cache discovered private boundaries</p> <code>False</code> <p>Returns:</p> Type Description <code>Response</code> Source code in <code>TM1py/Services/ApplicationService.py</code> <pre><code>def update_document_from_file(\n    self, path_to_file: str, application_path: str, application_name: str, private: bool = False,\n    use_cache: bool = False, **kwargs\n) -&gt; Response:\n    \"\"\"Update DocumentApplication in TM1 from local file\n\n    Automatically handles mixed public/private folder hierarchies.\n\n    :param path_to_file:\n    :param application_path:\n    :param application_name:\n    :param private:\n    :param use_cache: boolean - whether to cache discovered private boundaries\n    :return:\n    \"\"\"\n    with open(path_to_file, \"rb\") as file:\n        application = DocumentApplication(path=application_path, name=application_name, content=file.read())\n        return self.update(application=application, private=private, use_cache=use_cache, **kwargs)\n</code></pre>"},{"location":"reference/services/applicationservice/#TM1py.Services.ApplicationService.ApplicationService.update_or_create","title":"<code>update_or_create(application, private=False, use_cache=False, **kwargs)</code>","text":"<p>Update or create Planning Analytics application</p> <p>Automatically handles mixed public/private folder hierarchies.</p> <p>Parameters:</p> Name Type Description Default <code>application</code> <code>Union[Application, DocumentApplication]</code> <p>instance of Application</p> required <code>private</code> <code>bool</code> <p>boolean</p> <code>False</code> <code>use_cache</code> <code>bool</code> <p>boolean - whether to cache discovered private boundaries</p> <code>False</code> <p>Returns:</p> Type Description <code>Response</code> <p>Response</p> Source code in <code>TM1py/Services/ApplicationService.py</code> <pre><code>def update_or_create(\n    self, application: Union[Application, DocumentApplication], private: bool = False,\n    use_cache: bool = False, **kwargs\n) -&gt; Response:\n    \"\"\"Update or create Planning Analytics application\n\n    Automatically handles mixed public/private folder hierarchies.\n\n    :param application: instance of Application\n    :param private: boolean\n    :param use_cache: boolean - whether to cache discovered private boundaries\n    :return: Response\n    \"\"\"\n    if self.exists(\n        path=application.path,\n        application_type=application.application_type,\n        name=application.name,\n        private=private,\n        use_cache=use_cache,\n        **kwargs,\n    ):\n        response = self.update(application=application, private=private, use_cache=use_cache, **kwargs)\n    else:\n        response = self.create(application=application, private=private, use_cache=use_cache, **kwargs)\n    return response\n</code></pre>"},{"location":"reference/services/applicationservice/#TM1py.Services.ApplicationService.ApplicationService.update_or_create_document_from_file","title":"<code>update_or_create_document_from_file(path, name, path_to_file, private=False, use_cache=False, **kwargs)</code>","text":"<p>Update or create application from file</p> <p>Automatically handles mixed public/private folder hierarchies.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>application path on server, i.e. 'Finance/Reports'</p> required <code>name</code> <code>str</code> <p>name of the application on server, i.e. 'Flash.xlsx'</p> required <code>path_to_file</code> <code>str</code> <p>full local file path of file, i.e. 'C:\\Users\\User\\Flash.xslx'</p> required <code>private</code> <code>bool</code> <p>access level of the object</p> <code>False</code> <code>use_cache</code> <code>bool</code> <p>boolean - whether to cache discovered private boundaries</p> <code>False</code> <p>Returns:</p> Type Description <code>Response</code> <p>Response</p> Source code in <code>TM1py/Services/ApplicationService.py</code> <pre><code>def update_or_create_document_from_file(\n    self, path: str, name: str, path_to_file: str, private: bool = False, use_cache: bool = False, **kwargs\n) -&gt; Response:\n    \"\"\"Update or create application from file\n\n    Automatically handles mixed public/private folder hierarchies.\n\n    :param path: application path on server, i.e. 'Finance/Reports'\n    :param name: name of the application on server, i.e. 'Flash.xlsx'\n    :param path_to_file: full local file path of file, i.e. 'C:\\\\Users\\\\User\\\\Flash.xslx'\n    :param private: access level of the object\n    :param use_cache: boolean - whether to cache discovered private boundaries\n    :return: Response\n    \"\"\"\n    if self.exists(path=path, application_type=ApplicationTypes.DOCUMENT, name=name, private=private,\n                   use_cache=use_cache, **kwargs):\n        response = self.update_document_from_file(\n            path_to_file=path_to_file, application_path=path, application_name=name, private=private,\n            use_cache=use_cache, **kwargs\n        )\n    else:\n        response = self.create_document_from_file(\n            path_to_file=path_to_file, application_path=path, application_name=name, private=private,\n            use_cache=use_cache, **kwargs\n        )\n\n    return response\n</code></pre>"},{"location":"reference/services/auditlogservice/","title":"AuditLogService","text":""},{"location":"reference/services/auditlogservice/#TM1py.Services.AuditLogService.AuditLogService","title":"<code>AuditLogService(rest)</code>","text":"<p>               Bases: <code>ObjectService</code></p> Source code in <code>TM1py/Services/AuditLogService.py</code> <pre><code>def __init__(self, rest: RestService):\n    super().__init__(rest)\n    if verify_version(required_version=\"12.0.0\", version=rest.version):\n        # warn only due to use in Monitoring Service\n        warn(\"Audit Logs are not available in this version of TM1, removed as of 12.0.0\", DeprecationWarning, 2)\n    self.last_delta_request = None\n    self.configuration = ConfigurationService(rest)\n</code></pre>"},{"location":"reference/services/auditlogservice/#TM1py.Services.AuditLogService.AuditLogService.configuration","title":"<code>configuration = ConfigurationService(rest)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/services/auditlogservice/#TM1py.Services.AuditLogService.AuditLogService.last_delta_request","title":"<code>last_delta_request = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/services/auditlogservice/#TM1py.Services.AuditLogService.AuditLogService.activate","title":"<code>activate()</code>","text":"Source code in <code>TM1py/Services/AuditLogService.py</code> <pre><code>@require_ops_admin\ndef activate(self):\n    config = {\"Administration\": {\"AuditLog\": {\"Enable\": True}}}\n    self.configuration.update_static(config)\n</code></pre>"},{"location":"reference/services/auditlogservice/#TM1py.Services.AuditLogService.AuditLogService.execute_delta_request","title":"<code>execute_delta_request(**kwargs)</code>","text":"Source code in <code>TM1py/Services/AuditLogService.py</code> <pre><code>@deprecated_in_version(version=\"12.0.0\")\n@odata_track_changes_header\ndef execute_delta_request(self, **kwargs) -&gt; Dict:\n    response = self._rest.GET(url=\"/\" + self.last_delta_request, **kwargs)\n    self.last_delta_request = response.text[response.text.rfind(\"AuditLogEntries/!delta('\") : -2]\n    return response.json()[\"value\"]\n</code></pre>"},{"location":"reference/services/auditlogservice/#TM1py.Services.AuditLogService.AuditLogService.get_entries","title":"<code>get_entries(user=None, object_type=None, object_name=None, since=None, until=None, top=None, **kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>user</code> <code>str</code> <p>UserName</p> <code>None</code> <code>object_type</code> <code>str</code> <p>ObjectType</p> <code>None</code> <code>object_name</code> <code>str</code> <p>ObjectName</p> <code>None</code> <code>since</code> <code>datetime</code> <p>of type datetime. If it doesn't have tz information, UTC is assumed.</p> <code>None</code> <code>until</code> <code>datetime</code> <p>of type datetime. If it doesn't have tz information, UTC is assumed.</p> <code>None</code> <code>top</code> <code>int</code> <p>int</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict</code> Source code in <code>TM1py/Services/AuditLogService.py</code> <pre><code>@require_data_admin\n@deprecated_in_version(version=\"12.0.0\")\n@require_version(version=\"11.6\")\ndef get_entries(\n    self,\n    user: str = None,\n    object_type: str = None,\n    object_name: str = None,\n    since: datetime = None,\n    until: datetime = None,\n    top: int = None,\n    **kwargs,\n) -&gt; Dict:\n    \"\"\"\n    :param user: UserName\n    :param object_type: ObjectType\n    :param object_name: ObjectName\n    :param since: of type datetime. If it doesn't have tz information, UTC is assumed.\n    :param until: of type datetime. If it doesn't have tz information, UTC is assumed.\n    :param top: int\n    :return:\n    \"\"\"\n\n    url = \"/AuditLogEntries?$expand=AuditDetails\"\n    # filter on user, object_type, object_name  and time\n    if any([user, object_type, object_name, since, until]):\n        log_filters = []\n        if user:\n            log_filters.append(format_url(\"UserName eq '{}'\", user))\n        if object_type:\n            log_filters.append(format_url(\"ObjectType eq '{}'\", object_type))\n        if object_name:\n            log_filters.append(format_url(\"ObjectName eq '{}'\", object_name))\n        if since:\n            # If since doesn't have tz information, UTC is assumed\n            if not since.tzinfo:\n                since = utc_localize_time(since)\n            log_filters.append(format_url(\"TimeStamp ge {}\", since.strftime(\"%Y-%m-%dT%H:%M:%SZ\")))\n        if until:\n            # If until doesn't have tz information, UTC is assumed\n            if not until.tzinfo:\n                until = utc_localize_time(until)\n            log_filters.append(format_url(\"TimeStamp le {}\", until.strftime(\"%Y-%m-%dT%H:%M:%SZ\")))\n        url += \"&amp;$filter={}\".format(\" and \".join(log_filters))\n    # top limit\n    if top:\n        url += \"&amp;$top={}\".format(top)\n    response = self._rest.GET(url, **kwargs)\n    return response.json()[\"value\"]\n</code></pre>"},{"location":"reference/services/auditlogservice/#TM1py.Services.AuditLogService.AuditLogService.initialize_delta_requests","title":"<code>initialize_delta_requests(filter=None, **kwargs)</code>","text":"Source code in <code>TM1py/Services/AuditLogService.py</code> <pre><code>@deprecated_in_version(version=\"12.0.0\")\n@odata_track_changes_header\ndef initialize_delta_requests(self, filter=None, **kwargs):\n    url = \"/TailAuditLog()\"\n    if filter:\n        url += \"?$filter={}\".format(filter)\n    response = self._rest.GET(url=url, **kwargs)\n    # Read the next delta-request-url from the response\n    self.last_delta_request = response.text[response.text.rfind(\"AuditLogEntries/!delta('\") : -2]\n</code></pre>"},{"location":"reference/services/cellservice/","title":"CellService","text":""},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService","title":"<code>CellService(tm1_rest)</code>","text":"<p>               Bases: <code>ObjectService</code></p> <p>Service to handle Read and Write operations to TM1 cubes</p> <p>Parameters:</p> Name Type Description Default <code>tm1_rest</code> <code>RestService</code> <p>instance of RestService</p> required Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def __init__(self, tm1_rest: RestService):\n    \"\"\"\n\n    :param tm1_rest: instance of RestService\n    \"\"\"\n    super().__init__(tm1_rest)\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.activate_transactionlog","title":"<code>activate_transactionlog(*args, **kwargs)</code>","text":"<p>Activate Transactionlog for one or many cubes</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>str</code> <p>one or many cube names</p> <code>()</code> <p>Returns:</p> Type Description <code>Response</code> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def activate_transactionlog(self, *args: str, **kwargs) -&gt; Response:\n    \"\"\"Activate Transactionlog for one or many cubes\n\n    :param args: one or many cube names\n    :return:\n    \"\"\"\n\n    value = \"YES\"\n    element_tuple = (args[0], \"Logging\")\n    return self.write_value(value=value, cube_name=\"}CubeProperties\", element_tuple=element_tuple, **kwargs)\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.begin_changeset","title":"<code>begin_changeset()</code>","text":"<p>begin a change set</p> <p>Returns:</p> Type Description <code>str</code> <p>Change set ID</p> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def begin_changeset(self) -&gt; str:\n    \"\"\"begin a change set\n\n    :return: Change set ID\n    \"\"\"\n\n    url = \"/BeginChangeSet\"\n    return self._rest.POST(url).json()[\"value\"]\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.check_cell_feeders","title":"<code>check_cell_feeders(cube_name, elements, dimensions=None, sandbox_name=None, element_separator=',', hierarchy_separator='&amp;&amp;', hierarchy_element_separator='::', **kwargs)</code>","text":"<p>Check feeders</p> <p>Parameters:</p> Name Type Description Default <code>cube_name</code> <code>str</code> <p>name of the target cube</p> required <code>elements</code> <code>Union[Iterable, str]</code> <p>string \"Hierarchy1::Element1 &amp;&amp; Hierarchy2::Element4, Element9, Element2\" - Dimensions are not specified! They are derived from the position. - The , separates the element-selections - If more than one hierarchy is selected per dimension &amp;&amp; splits the elementselections - If no Hierarchy is specified. Default Hierarchy will be addressed or Iterable [Element1, Element2, Element3]</p> required <code>dimensions</code> <code>Iterable[str]</code> <p>optional. Dimension names in their natural order. Will speed up the execution!</p> <code>None</code> <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <code>element_separator</code> <code>str</code> <p>Alternative separator for the elements, if elements are passed as string</p> <code>','</code> <code>hierarchy_separator</code> <code>str</code> <p>Alternative separator for multiple hierarchies, if elements are passed as string</p> <code>'&amp;&amp;'</code> <code>hierarchy_element_separator</code> <code>str</code> <p>Alternative separator between hierarchy name and element name, if elements are passed as string</p> <code>'::'</code> <p>Returns:</p> Type Description <code>Dict</code> <p>fed cell descriptor</p> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def check_cell_feeders(\n    self,\n    cube_name: str,\n    elements: Union[Iterable, str],\n    dimensions: Iterable[str] = None,\n    sandbox_name: str = None,\n    element_separator: str = \",\",\n    hierarchy_separator: str = \"&amp;&amp;\",\n    hierarchy_element_separator: str = \"::\",\n    **kwargs,\n) -&gt; Dict:\n    \"\"\"Check feeders\n\n    :param cube_name: name of the target cube\n    :param elements:\n    string \"Hierarchy1::Element1 &amp;&amp; Hierarchy2::Element4, Element9, Element2\"\n        - Dimensions are not specified! They are derived from the position.\n        - The , separates the element-selections\n        - If more than one hierarchy is selected per dimension &amp;&amp; splits the elementselections\n        - If no Hierarchy is specified. Default Hierarchy will be addressed\n    or\n    Iterable [Element1, Element2, Element3]\n    :param dimensions: optional. Dimension names in their natural order. Will speed up the execution!\n    :param sandbox_name: str\n    :param element_separator: Alternative separator for the elements, if elements are passed as string\n    :param hierarchy_separator: Alternative separator for multiple hierarchies, if elements are passed as string\n    :param hierarchy_element_separator: Alternative separator between hierarchy name and element name, if elements are passed as string\n    :return: fed cell descriptor\n    \"\"\"\n\n    url = format_url(\n        \"/Cubes('{}')/tm1.CheckFeeders\"\n        \"?$select=Fed\"\n        \"&amp;$expand=Tuple($select=Name,UniqueName,Type),Cube($select=Name)\",\n        cube_name,\n    )\n\n    url = add_url_parameters(url, **{\"!sandbox\": sandbox_name})\n    if isinstance(elements, str):\n        body_as_dict = self._compose_odata_tuple_from_string(\n            cube_name, elements, dimensions, element_separator, hierarchy_separator, hierarchy_element_separator\n        )\n    else:\n        body_as_dict = self._compose_odata_tuple_from_iterable(cube_name, elements, dimensions)\n    data = json.dumps(body_as_dict, ensure_ascii=False)\n\n    return json.loads(self._rest.POST(url=url, data=data, **kwargs).content)\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.clear","title":"<code>clear(cube, **kwargs)</code>","text":"<p>Takes the cube name and keyword argument pairs of dimensions and MDX expressions:</p> <pre><code>tm1.cells.clear(\n    cube=\"Sales\",\n    salesregion=\"{[Sales Region].[Australia],[Sales Region].[New Zealand]}\",\n    product=\"{[Product].[ABC]}\",\n    time=\"{[Time].[2022].Children}\")\n</code></pre> <p>Make sure that the keyword argument names (e.g. product) map with the dimension names (e.g. Product) in the cube. Spaces in the dimension name (e.g., \"Sales Region\") must be omitted in the keyword (e.g. \"salesregion\")</p> <p>Parameters:</p> Name Type Description Default <code>cube</code> <code>str</code> <p>name of the cube</p> required <code>kwargs</code> <p>keyword argument pairs of dimension names and mdx set expressions</p> <code>{}</code> <p>Returns:</p> Type Description Source code in <code>TM1py/Services/CellService.py</code> <pre><code>@require_data_admin\n@require_ops_admin\n@require_version(version=\"11.7\")\ndef clear(self, cube: str, **kwargs):\n    \"\"\"\n    Takes the cube name and keyword argument pairs of dimensions and MDX expressions:\n\n    ```\n    tm1.cells.clear(\n        cube=\"Sales\",\n        salesregion=\"{[Sales Region].[Australia],[Sales Region].[New Zealand]}\",\n        product=\"{[Product].[ABC]}\",\n        time=\"{[Time].[2022].Children}\")\n    ```\n\n    Make sure that the keyword argument names (e.g. product) map with the dimension names (e.g. Product) in the cube.\n    Spaces in the dimension name (e.g., \"Sales Region\") must be omitted in the keyword (e.g. \"salesregion\")\n\n    :param cube: name of the cube\n    :param kwargs: keyword argument pairs of dimension names and mdx set expressions\n    :return:\n    \"\"\"\n    cube_service = self.get_cube_service()\n    dimension_names = CaseAndSpaceInsensitiveSet(*cube_service.get_dimension_names(cube_name=cube))\n    dimension_expression_pairs = CaseAndSpaceInsensitiveDict()\n\n    for kwarg in kwargs:\n        if kwarg in dimension_names:\n            dimension_expression_pairs[kwarg] = wrap_in_curly_braces(kwargs[kwarg])\n\n    for dimension_name in dimension_names:\n        if dimension_name not in dimension_expression_pairs:\n            expression = MdxHierarchySet.tm1_subset_all(dimension_name).filter_by_level(0).to_mdx()\n            dimension_expression_pairs[dimension_name] = expression\n\n    mdx_builder = MdxBuilder.from_cube(cube).columns_non_empty()\n    for dimension, expression in dimension_expression_pairs.items():\n        hierarchy_set = MdxHierarchySet.from_str(dimension=dimension, hierarchy=dimension, mdx=expression)\n        mdx_builder.add_hierarchy_set_to_column_axis(hierarchy_set)\n\n    return self.clear_with_mdx(cube=cube, mdx=mdx_builder.to_mdx(), **kwargs)\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.clear_spread","title":"<code>clear_spread(cube, unique_element_names, sandbox_name=None, **kwargs)</code>","text":"<p>Execute clear spread</p> <p>Parameters:</p> Name Type Description Default <code>cube</code> <code>str</code> <p>name of the cube</p> required <code>unique_element_names</code> <code>Iterable[str]</code> <p>target cell coordinates as unique element names (e.g. [\"[d1].[c1]\",\"[d2].[e3]\"])</p> required <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def clear_spread(\n    self, cube: str, unique_element_names: Iterable[str], sandbox_name: str = None, **kwargs\n) -&gt; Response:\n    \"\"\"Execute clear spread\n    :param cube: name of the cube\n    :param unique_element_names: target cell coordinates as unique element names (e.g. [\"[d1].[c1]\",\"[d2].[e3]\"])\n    :param sandbox_name: str\n    :return:\n    \"\"\"\n    mdx = \"\"\"\n    SELECT\n    {{ {rows} }} ON 0\n    FROM [{cube}]\n    \"\"\".format(\n        rows=\"}*{\".join(unique_element_names), cube=cube\n    )\n    cellset_id = self.create_cellset(mdx=mdx, sandbox_name=sandbox_name, **kwargs)\n\n    payload = {\"BeginOrdinal\": 0, \"Value\": \"C\", \"ReferenceCell@odata.bind\": list()}\n    for unique_element_name in unique_element_names:\n        payload[\"ReferenceCell@odata.bind\"].append(\n            format_url(\n                \"Dimensions('{}')/Hierarchies('{}')/Elements('{}')\",\n                *Utils.dimension_hierarchy_element_tuple_from_unique_name(unique_element_name),\n            )\n        )\n\n    return self._post_against_cellset(\n        cellset_id=cellset_id, payload=payload, delete_cellset=True, sandbox_name=sandbox_name, **kwargs\n    )\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.clear_with_dataframe","title":"<code>clear_with_dataframe(cube, df, dimension_mapping=None, **kwargs)</code>","text":"<p>Clears data from a TM1 cube based on the distinct values in a DataFrame over cube dimensions.   Note:       This function is similar to <code>tm1.cells.clear</code>, but it is designed specifically for clearing data        based on distinct values in a DataFrame over cube dimensions. The key difference is that this        function interprets the DataFrame columns as dimensions and supports a mapping (<code>dimension_mapping</code>)        for specifying hierarchies within those dimensions.</p> <p>:example:     <pre><code># Sample DataFrame with distinct values over cube dimensions\ndata = {\n    \"Year\": [\"2021\", \"2022\"],\n    \"Organisation\": [\"some_company\", \"some_company\"],\n    \"Location\": [\"Germany\", \"Albania\"]\n}\n\n# Sample dimension mapping\ndimensions_mapping = {\n    \"Organisation\": \"hierarchy_1\",\n    \"Location\": [\"hierarchy_2\", \"hierarchy_3\", \"hierarchy_4\"]\n}\n\ndataframe = pd.DataFrame(data)\n\nwith TM1Service(**tm1params) as tm1:\n  tm1.cells.clear_with_dataframe(cube=\"Sales\", df=dataframe)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>cube</code> <code>str</code> <p>str The name of the TM1 cube.</p> required <code>df</code> <code>DataFrame</code> <p>pd.DataFrame The DataFrame containing distinct values over cube dimensions. Columns in the DataFrame should correspond to cube dimensions.</p> required <code>dimension_mapping</code> <code>Dict</code> <p>Dict, optional A dictionary mapping the DataFrame columns to one or many hierarchies within the given dimension. If not provided, assumes that the dimensions have just one hierarchy.</p> <code>None</code> <p>Returns:</p> Type Description <p>None The function clears data in the specified TM1 cube.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If there are unmatched dimensions in the DataFrame or if specified dimensions do not exist in the TM1 cube.</p> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>@require_data_admin\n@require_ops_admin\n@require_version(version=\"11.7\")\ndef clear_with_dataframe(self, cube: str, df: \"pd.DataFrame\", dimension_mapping: Dict = None, **kwargs):\n    \"\"\"Clears data from a TM1 cube based on the distinct values in a DataFrame over cube dimensions.\n      Note:\n          This function is similar to `tm1.cells.clear`, but it is designed specifically for clearing data\n           based on distinct values in a DataFrame over cube dimensions. The key difference is that this\n           function interprets the DataFrame columns as dimensions and supports a mapping (`dimension_mapping`)\n           for specifying hierarchies within those dimensions.\n\n    :param cube: str\n        The name of the TM1 cube.\n    :param df: pd.DataFrame\n        The DataFrame containing distinct values over cube dimensions.\n        Columns in the DataFrame should correspond to cube dimensions.\n    :param dimension_mapping: Dict, optional\n        A dictionary mapping the DataFrame columns to one or many hierarchies within the given dimension.\n        If not provided, assumes that the dimensions have just one hierarchy.\n\n    :return: None\n        The function clears data in the specified TM1 cube.\n\n    :raises ValueError:\n        If there are unmatched dimensions in the DataFrame or if specified dimensions\n        do not exist in the TM1 cube.\n\n    :example:\n        ```python\n\n        # Sample DataFrame with distinct values over cube dimensions\n        data = {\n            \"Year\": [\"2021\", \"2022\"],\n            \"Organisation\": [\"some_company\", \"some_company\"],\n            \"Location\": [\"Germany\", \"Albania\"]\n        }\n\n        # Sample dimension mapping\n        dimensions_mapping = {\n            \"Organisation\": \"hierarchy_1\",\n            \"Location\": [\"hierarchy_2\", \"hierarchy_3\", \"hierarchy_4\"]\n        }\n\n        dataframe = pd.DataFrame(data)\n\n        with TM1Service(**tm1params) as tm1:\n          tm1.cells.clear_with_dataframe(cube=\"Sales\", df=dataframe)\n\n        ```\n    \"\"\"\n    if not dimension_mapping:\n        dimension_mapping = {}\n\n    if len(CaseAndSpaceInsensitiveSet(df.columns)) != len(df.columns):\n        raise ValueError(f\"Column names in DataFrame are not unique identifiers for TM1: {list(df.columns)}\")\n\n    cube_service = self.get_cube_service()\n    dimension_names = CaseAndSpaceInsensitiveSet(*cube_service.get_dimension_names(cube_name=cube))\n\n    df = df.astype(str)\n\n    elements_by_column = {col_name: df[col_name].unique() for col_name in df.columns}\n\n    mdx_selections = {}\n    unmatched_dimension_names = []\n    for column, elements in elements_by_column.items():\n        members = []\n\n        if column not in dimension_names:\n            unmatched_dimension_names.append(column)\n\n        for element in elements:\n            if column in dimension_mapping:\n                hierarchy = dimension_mapping.get(column)\n                if not isinstance(hierarchy, str):\n                    raise ValueError(f\"Value for key '{column}' in dimension_mapping must be of type str\")\n                members.append(Member.of(column, hierarchy, element))\n\n            else:\n                members.append(Member.of(column, column, element))\n        mdx_selections[column] = MdxHierarchySet.members(members)\n\n    if dimension_mapping:\n        for dimension, hierarchies in dimension_mapping.items():\n            if dimension not in dimension_names:\n                unmatched_dimension_names.append(dimension)\n\n            elif isinstance(hierarchies, str):\n                hierarchy = hierarchies\n                mdx_selections[dimension] = MdxHierarchySet.tm1_subset_all(\n                    dimension=dimension, hierarchy=hierarchy\n                ).filter_by_level(0)\n\n            elif isinstance(hierarchies, Iterable):\n                for hierarchy in hierarchies:\n                    mdx_selections[dimension] = MdxHierarchySet.tm1_subset_all(\n                        dimension=dimension, hierarchy=hierarchy\n                    ).filter_by_level(0)\n\n            else:\n                raise ValueError(f\"Unexpected value type for key '{dimension}' in dimension_mapping\")\n\n    if unmatched_dimension_names:\n        raise ValueError(\n            f\"Dimension(s) {unmatched_dimension_names} does not exist in cube {cube}.\"\n            f\"\\nCheck the source of the dataframe to fix the problem\"\n        )\n\n    for dimension_name in dimension_names:\n        if dimension_name not in mdx_selections:\n            mdx_selections[dimension_name] = MdxHierarchySet.tm1_subset_all(dimension_name).filter_by_level(0)\n\n    mdx_builder = MdxBuilder.from_cube(cube).columns_non_empty()\n    for dimension, expression in mdx_selections.items():\n        mdx_builder.add_hierarchy_set_to_column_axis(expression)\n\n    return self.clear_with_mdx(cube=cube, mdx=mdx_builder.to_mdx(), **kwargs)\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.clear_with_mdx","title":"<code>clear_with_mdx(cube, mdx, sandbox_name=None, **kwargs)</code>","text":"<p>clear a slice in a cube based on an MDX query. Function requires admin permissions, since TM1py uses an unbound TI with a <code>ViewZeroOut</code> statement.</p> <p>Parameters:</p> Name Type Description Default <code>cube</code> <code>str</code> <p>name of the cube</p> required <code>mdx</code> <code>str</code> <p>a valid MDX query</p> required <code>sandbox_name</code> <code>str</code> <p>a valid existing sandbox for the current user</p> <code>None</code> <code>kwargs</code> <code>{}</code> <p>Returns:</p> Type Description Source code in <code>TM1py/Services/CellService.py</code> <pre><code>@require_data_admin\n@require_ops_admin\n@require_version(version=\"11.7\")\ndef clear_with_mdx(self, cube: str, mdx: str, sandbox_name: str = None, **kwargs):\n    \"\"\"clear a slice in a cube based on an MDX query.\n    Function requires admin permissions, since TM1py uses an unbound TI with a `ViewZeroOut` statement.\n\n    :param cube: name of the cube\n    :param mdx: a valid MDX query\n    :param sandbox_name: a valid existing sandbox for the current user\n    :param kwargs:\n    :return:\n    \"\"\"\n    view_service = ViewService(self._rest)\n\n    enable_sandbox = self.generate_enable_sandbox_ti(sandbox_name)\n\n    view_name = \"\".join([\"}TM1py\", str(uuid.uuid4())])\n    view_service.create(MDXView(cube_name=cube, view_name=view_name, MDX=mdx))\n\n    try:\n        code = f\"ViewZeroOut('{cube}','{view_name}');\"\n        process = Process(name=\"\")\n        process.prolog_procedure = enable_sandbox\n        process.epilog_procedure = code\n\n        success, _, _ = self.execute_unbound_process(process, **kwargs)\n        if not success:\n            raise TM1pyException(f\"Failed to clear cube: '{cube}' with mdx: '{abbreviate_mdx(mdx, 100)}'\")\n    finally:\n        if view_service.exists(cube, view_name, private=False):\n            view_service.delete(cube, view_name, private=False)\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.create_cellset","title":"<code>create_cellset(mdx, sandbox_name=None, **kwargs)</code>","text":"<p>Execute MDX in order to create cellset at server. return the cellset-id</p> <p>Parameters:</p> Name Type Description Default <code>mdx</code> <code>Union[str, MdxBuilder]</code> <p>MDX Query, as string</p> required <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def create_cellset(self, mdx: Union[str, MdxBuilder], sandbox_name: str = None, **kwargs) -&gt; str:\n    \"\"\"Execute MDX in order to create cellset at server. return the cellset-id\n\n    :param mdx: MDX Query, as string\n    :param sandbox_name: str\n    :return:\n    \"\"\"\n    url = \"/ExecuteMDX\"\n    url = add_url_parameters(url, **{\"!sandbox\": sandbox_name})\n    data = {\"MDX\": mdx.to_mdx() if isinstance(mdx, MdxBuilder) else mdx}\n    response = self._rest.POST(url=url, data=json.dumps(data, ensure_ascii=False), **kwargs)\n    cellset_id = response.json()[\"ID\"]\n    return cellset_id\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.create_cellset_from_view","title":"<code>create_cellset_from_view(cube_name, view_name, private, sandbox_name=None, **kwargs)</code>","text":"<p>create cellset from a cube view. return the cellset-id</p> <p>Parameters:</p> Name Type Description Default <code>cube_name</code> <code>str</code> <p>String, name of the cube</p> required <code>view_name</code> <code>str</code> <p>String, name of the view</p> required <code>private</code> <code>bool</code> <p>True (private) or False (public)</p> required <code>kwargs</code> <code>{}</code> <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def create_cellset_from_view(\n    self, cube_name: str, view_name: str, private: bool, sandbox_name: str = None, **kwargs\n) -&gt; str:\n    \"\"\"create cellset from a cube view. return the cellset-id\n\n    :param cube_name: String, name of the cube\n    :param view_name: String, name of the view\n    :param private: True (private) or False (public)\n    :param kwargs:\n    :param sandbox_name: str\n    :return:\n    \"\"\"\n    url = format_url(\n        \"/Cubes('{cube_name}')/{views}('{view_name}')/tm1.Execute\",\n        cube_name=cube_name,\n        views=\"PrivateViews\" if private else \"Views\",\n        view_name=view_name,\n    )\n    url = add_url_parameters(url, **{\"!sandbox\": sandbox_name})\n    return self._rest.POST(url=url, **kwargs).json()[\"ID\"]\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.deactivate_transactionlog","title":"<code>deactivate_transactionlog(*args, **kwargs)</code>","text":"<p>Deactivate Transactionlog for one or many cubes</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>str</code> <p>one or many cube names</p> <code>()</code> <p>Returns:</p> Type Description <code>Response</code> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def deactivate_transactionlog(self, *args: str, **kwargs) -&gt; Response:\n    \"\"\"Deactivate Transactionlog for one or many cubes\n\n    :param args: one or many cube names\n    :return:\n    \"\"\"\n    value = \"NO\"\n    element_tuple = (args[0], \"Logging\")\n    return self.write_value(value=value, cube_name=\"}CubeProperties\", element_tuple=element_tuple, **kwargs)\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.delete_cellset","title":"<code>delete_cellset(cellset_id, sandbox_name=None, **kwargs)</code>","text":"<p>Delete a cellset</p> <p>Parameters:</p> Name Type Description Default <code>cellset_id</code> <code>str</code> required <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def delete_cellset(self, cellset_id: str, sandbox_name: str = None, **kwargs) -&gt; Response:\n    \"\"\"Delete a cellset\n\n    :param cellset_id:\n    :param sandbox_name: str\n    :return:\n    \"\"\"\n    url = \"/Cellsets('{}')\".format(cellset_id)\n    url = add_url_parameters(url, **{\"!sandbox\": sandbox_name})\n    return self._rest.DELETE(url, **kwargs)\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.drop_non_updateable_cells","title":"<code>drop_non_updateable_cells(cells, cube_name, dimensions)</code>","text":"Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def drop_non_updateable_cells(self, cells: Dict, cube_name: str, dimensions: List[str]):\n    mdx = build_mdx_from_cellset(cells, cube_name, dimensions)\n    updateable_cells = CaseAndSpaceInsensitiveTuplesDict()\n\n    cells_with_updateable_flag = self.execute_mdx(\n        mdx,\n        # Issue in TM1 Server 11.8: Updateable property is not correct if Value property is not retrieved\n        cell_properties=[\"Updateable\", \"Value\"],\n        element_unique_names=False,\n        skip_consolidated_cells=True,\n        skip_rule_derived_cells=True,\n    )\n\n    for elements, cell in cells_with_updateable_flag.items():\n        # skip sandbox element\n        if len(elements) &gt; len(dimensions):\n            elements = elements[1:]\n\n        if cell_is_updateable(cell):\n            updateable_cells[elements] = cells[elements]\n    return updateable_cells\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.end_changeset","title":"<code>end_changeset(change_set)</code>","text":"<p>end a change set</p> <p>Returns:</p> Type Description <code>Response</code> <p>Change set ID</p> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def end_changeset(self, change_set: str) -&gt; Response:\n    \"\"\"end a change set\n\n    :return: Change set ID\n    \"\"\"\n\n    url = \"/EndChangeSet\"\n    data = {\"ChangeSetID\": change_set}\n    return self._rest.POST(url, data=json.dumps(data, ensure_ascii=False))\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.execute_mdx","title":"<code>execute_mdx(mdx, cell_properties=None, top=None, skip_contexts=False, skip=None, skip_zeros=False, skip_consolidated_cells=False, skip_rule_derived_cells=False, sandbox_name=None, element_unique_names=True, skip_cell_properties=False, use_compact_json=False, skip_sandbox_dimension=False, max_workers=1, async_axis=0, **kwargs)</code>","text":"<p>Execute MDX and return the cells with their properties</p> <p>:skip_sandbox_dimension: bool = False</p> <p>Parameters:</p> Name Type Description Default <code>mdx</code> <code>str</code> <p>MDX Query, as string</p> required <code>cell_properties</code> <code>List[str]</code> <p>properties to be queried from the cell. E.g. Value, Ordinal, RuleDerived, ...</p> <code>None</code> <code>top</code> <code>int</code> <p>Int, number of cells to return (counting from top)</p> <code>None</code> <code>skip</code> <code>int</code> <p>Int, number of cells to skip (counting from top)</p> <code>None</code> <code>skip_contexts</code> <code>bool</code> <p>skip elements from titles / contexts in response</p> <code>False</code> <code>skip_zeros</code> <code>bool</code> <p>skip zeros in cellset (irrespective of zero suppression in MDX / view)</p> <code>False</code> <code>skip_consolidated_cells</code> <code>bool</code> <p>skip consolidated cells in cellset</p> <code>False</code> <code>skip_rule_derived_cells</code> <code>bool</code> <p>skip rule derived cells in cellset</p> <code>False</code> <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <code>element_unique_names</code> <code>bool</code> <p>'[d1].[h1].[e1]' or 'e1'</p> <code>True</code> <code>skip_cell_properties</code> <code>bool</code> <p>cell values in result dictionary, instead of cell_properties dictionary</p> <code>False</code> <code>use_compact_json</code> <code>bool</code> <p>bool</p> <code>False</code> <p>Returns:</p> Type Description <code>CaseAndSpaceInsensitiveTuplesDict</code> <p>content in sweet concise structure.</p> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def execute_mdx(\n    self,\n    mdx: str,\n    cell_properties: List[str] = None,\n    top: int = None,\n    skip_contexts: bool = False,\n    skip: int = None,\n    skip_zeros: bool = False,\n    skip_consolidated_cells: bool = False,\n    skip_rule_derived_cells: bool = False,\n    sandbox_name: str = None,\n    element_unique_names: bool = True,\n    skip_cell_properties: bool = False,\n    use_compact_json: bool = False,\n    skip_sandbox_dimension: bool = False,\n    max_workers: int = 1,\n    async_axis: int = 0,\n    **kwargs,\n) -&gt; CaseAndSpaceInsensitiveTuplesDict:\n    \"\"\"Execute MDX and return the cells with their properties\n\n    :param mdx: MDX Query, as string\n    :param cell_properties: properties to be queried from the cell. E.g. Value, Ordinal, RuleDerived, ...\n    :param top: Int, number of cells to return (counting from top)\n    :param skip: Int, number of cells to skip (counting from top)\n    :param skip_contexts: skip elements from titles / contexts in response\n    :param skip_zeros: skip zeros in cellset (irrespective of zero suppression in MDX / view)\n    :param skip_consolidated_cells: skip consolidated cells in cellset\n    :param skip_rule_derived_cells: skip rule derived cells in cellset\n    :param sandbox_name: str\n    :param element_unique_names: '[d1].[h1].[e1]' or 'e1'\n    :param skip_cell_properties: cell values in result dictionary, instead of cell_properties dictionary\n    :param use_compact_json: bool\n    :skip_sandbox_dimension: bool = False\n    :return: content in sweet concise structure.\n    \"\"\"\n    if max_workers &gt; 1:\n        return self.execute_mdx_async(\n            mdx=mdx,\n            cell_properties=cell_properties,\n            top=top,\n            skip=skip,\n            skip_contexts=skip_contexts,\n            skip_zeros=skip_zeros,\n            skip_consolidated_cells=skip_consolidated_cells,\n            skip_rule_derived_cells=skip_rule_derived_cells,\n            sandbox_name=sandbox_name,\n            element_unique_names=element_unique_names,\n            skip_cell_properties=skip_cell_properties,\n            use_compact_json=use_compact_json,\n            skip_sandbox_dimension=skip_sandbox_dimension,\n            max_workers=max_workers,\n            async_axis=async_axis,\n            **kwargs,\n        )\n\n    cellset_id = self.create_cellset(mdx=mdx, sandbox_name=sandbox_name, **kwargs)\n    return self.extract_cellset(\n        cellset_id=cellset_id,\n        cell_properties=cell_properties,\n        top=top,\n        skip=skip,\n        skip_contexts=skip_contexts,\n        skip_zeros=skip_zeros,\n        skip_consolidated_cells=skip_consolidated_cells,\n        skip_rule_derived_cells=skip_rule_derived_cells,\n        delete_cellset=True,\n        sandbox_name=sandbox_name,\n        element_unique_names=element_unique_names,\n        skip_cell_properties=skip_cell_properties,\n        use_compact_json=use_compact_json,\n        skip_sandbox_dimension=skip_sandbox_dimension,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.execute_mdx_async","title":"<code>execute_mdx_async(mdx, cell_properties=None, top=None, skip_contexts=False, skip=None, skip_zeros=False, skip_consolidated_cells=False, skip_rule_derived_cells=False, sandbox_name=None, element_unique_names=True, skip_cell_properties=False, use_compact_json=False, skip_sandbox_dimension=False, max_workers=8, async_axis=0, **kwargs)</code>","text":"<p>Execute MDX and return the cells with their properties</p> <p>Parameters:</p> Name Type Description Default <code>mdx</code> <code>str</code> <p>MDX Query, as string</p> required <code>cell_properties</code> <code>List[str]</code> <p>properties to be queried from the cell. E.g. Value, Ordinal, RuleDerived, ...</p> <code>None</code> <code>top</code> <code>int</code> <p>Int, number of cells to return (counting from top)</p> <code>None</code> <code>skip</code> <code>int</code> <p>Int, number of cells to skip (counting from top)</p> <code>None</code> <code>skip_contexts</code> <code>bool</code> <p>skip elements from titles / contexts in response</p> <code>False</code> <code>skip_zeros</code> <code>bool</code> <p>skip zeros in cellset (irrespective of zero suppression in MDX / view)</p> <code>False</code> <code>skip_consolidated_cells</code> <code>bool</code> <p>skip consolidated cells in cellset</p> <code>False</code> <code>skip_rule_derived_cells</code> <code>bool</code> <p>skip rule derived cells in cellset</p> <code>False</code> <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <code>element_unique_names</code> <code>bool</code> <p>'[d1].[h1].[e1]' or 'e1'</p> <code>True</code> <code>skip_cell_properties</code> <code>bool</code> <p>cell values in result dictionary, instead of cell_properties dictionary</p> <code>False</code> <code>use_compact_json</code> <code>bool</code> <p>bool</p> <code>False</code> <code>skip_sandbox_dimension</code> <code>bool</code> <p>bool = False</p> <code>False</code> <code>max_workers</code> <code>int</code> <p>Int, number of threads to use in parallel</p> <code>8</code> <code>async_axis</code> <code>int</code> <p>0 (columns) or 1 (rows). On which axis to parallelize retrieval</p> <code>0</code> <p>Returns:</p> Type Description <code>CaseAndSpaceInsensitiveTuplesDict</code> <p>content in sweet concise structure.</p> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def execute_mdx_async(\n    self,\n    mdx: str,\n    cell_properties: List[str] = None,\n    top: int = None,\n    skip_contexts: bool = False,\n    skip: int = None,\n    skip_zeros: bool = False,\n    skip_consolidated_cells: bool = False,\n    skip_rule_derived_cells: bool = False,\n    sandbox_name: str = None,\n    element_unique_names: bool = True,\n    skip_cell_properties: bool = False,\n    use_compact_json: bool = False,\n    skip_sandbox_dimension: bool = False,\n    max_workers: int = 8,\n    async_axis: int = 0,\n    **kwargs,\n) -&gt; CaseAndSpaceInsensitiveTuplesDict:\n    \"\"\"Execute MDX and return the cells with their properties\n\n    :param mdx: MDX Query, as string\n    :param cell_properties: properties to be queried from the cell. E.g. Value, Ordinal, RuleDerived, ...\n    :param top: Int, number of cells to return (counting from top)\n    :param skip: Int, number of cells to skip (counting from top)\n    :param skip_contexts: skip elements from titles / contexts in response\n    :param skip_zeros: skip zeros in cellset (irrespective of zero suppression in MDX / view)\n    :param skip_consolidated_cells: skip consolidated cells in cellset\n    :param skip_rule_derived_cells: skip rule derived cells in cellset\n    :param sandbox_name: str\n    :param element_unique_names: '[d1].[h1].[e1]' or 'e1'\n    :param skip_cell_properties: cell values in result dictionary, instead of cell_properties dictionary\n    :param use_compact_json: bool\n    :param skip_sandbox_dimension: bool = False\n    :param max_workers: Int, number of threads to use in parallel\n    :param async_axis: 0 (columns) or 1 (rows). On which axis to parallelize retrieval\n    :return: content in sweet concise structure.\n    \"\"\"\n    cellset_id = self.create_cellset(mdx=mdx, sandbox_name=sandbox_name, **kwargs)\n\n    return self.extract_cellset_async(\n        cellset_id=cellset_id,\n        cell_properties=cell_properties,\n        top=top,\n        skip=skip,\n        skip_contexts=skip_contexts,\n        skip_zeros=skip_zeros,\n        skip_consolidated_cells=skip_consolidated_cells,\n        skip_rule_derived_cells=skip_rule_derived_cells,\n        delete_cellset=True,\n        sandbox_name=sandbox_name,\n        element_unique_names=element_unique_names,\n        skip_cell_properties=skip_cell_properties,\n        use_compact_json=use_compact_json,\n        skip_sandbox_dimension=skip_sandbox_dimension,\n        max_workers=max_workers,\n        async_axis=async_axis,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.execute_mdx_cellcount","title":"<code>execute_mdx_cellcount(mdx, sandbox_name=None, **kwargs)</code>","text":"<p>Execute MDX in order to understand how many cells are in a cellset. Only return number of cells in the cellset. FAST!</p> <p>Parameters:</p> Name Type Description Default <code>mdx</code> <code>str</code> <p>MDX Query, as string</p> required <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>Number of Cells in the CellSet</p> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def execute_mdx_cellcount(self, mdx: str, sandbox_name: str = None, **kwargs) -&gt; int:\n    \"\"\"Execute MDX in order to understand how many cells are in a cellset.\n    Only return number of cells in the cellset. FAST!\n\n    :param mdx: MDX Query, as string\n    :param sandbox_name: str\n    :return: Number of Cells in the CellSet\n    \"\"\"\n    cellset_id = self.create_cellset(mdx, sandbox_name=sandbox_name, **kwargs)\n    return self.extract_cellset_cellcount(cellset_id, delete_cellset=True, sandbox_name=sandbox_name, **kwargs)\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.execute_mdx_csv","title":"<code>execute_mdx_csv(mdx, top=None, skip=None, skip_zeros=True, skip_consolidated_cells=False, skip_rule_derived_cells=False, csv_dialect=None, line_separator='\\r\\n', value_separator=',', sandbox_name=None, include_attributes=False, use_iterative_json=False, use_compact_json=False, use_blob=False, mdx_headers=False, **kwargs)</code>","text":"<p>Optimized for performance. Get csv string of coordinates and values.</p> <p>Parameters:</p> Name Type Description Default <code>mdx</code> <code>Union[str, MdxBuilder]</code> <p>Valid MDX Query</p> required <code>top</code> <code>int</code> <p>Int, number of cells to return (counting from top)</p> <code>None</code> <code>skip</code> <code>int</code> <p>Int, number of cells to skip (counting from top)</p> <code>None</code> <code>skip_zeros</code> <code>bool</code> <p>skip zeros in cellset (irrespective of zero suppression in MDX / view)</p> <code>True</code> <code>skip_consolidated_cells</code> <code>bool</code> <p>skip consolidated cells in cellset</p> <code>False</code> <code>skip_rule_derived_cells</code> <code>bool</code> <p>skip rule derived cells in cellset</p> <code>False</code> <code>csv_dialect</code> <code>Dialect</code> <p>provide all csv output settings through standard library csv.Dialect If not provided dialect is created based on line_separator and value_separator arguments.</p> <code>None</code> <code>line_separator</code> <code>str</code> <code>'\\r\\n'</code> <code>value_separator</code> <code>str</code> <code>','</code> <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <code>include_attributes</code> <code>bool</code> <p>include attribute columns</p> <code>False</code> <code>use_iterative_json</code> <code>bool</code> <p>use iterative json parsing to reduce memory consumption significantly. Comes at a cost of 3-5% performance.</p> <code>False</code> <code>use_compact_json</code> <code>bool</code> <p>bool</p> <code>False</code> <code>use_blob</code> <code>bool</code> <p>Has better performance on datasets &gt; 1M cells and lower memory footprint in any case.</p> <code>False</code> <code>mdx_headers</code> <code>bool</code> <p>boolean, fully qualified hierarchy name as header instead of simple dimension name</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>String</p> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def execute_mdx_csv(\n    self,\n    mdx: Union[str, MdxBuilder],\n    top: int = None,\n    skip: int = None,\n    skip_zeros: bool = True,\n    skip_consolidated_cells: bool = False,\n    skip_rule_derived_cells: bool = False,\n    csv_dialect: \"csv.Dialect\" = None,\n    line_separator: str = \"\\r\\n\",\n    value_separator: str = \",\",\n    sandbox_name: str = None,\n    include_attributes: bool = False,\n    use_iterative_json: bool = False,\n    use_compact_json: bool = False,\n    use_blob: bool = False,\n    mdx_headers: bool = False,\n    **kwargs,\n) -&gt; str:\n    \"\"\"Optimized for performance. Get csv string of coordinates and values.\n\n    :param mdx: Valid MDX Query\n    :param top: Int, number of cells to return (counting from top)\n    :param skip: Int, number of cells to skip (counting from top)\n    :param skip_zeros: skip zeros in cellset (irrespective of zero suppression in MDX / view)\n    :param skip_consolidated_cells: skip consolidated cells in cellset\n    :param skip_rule_derived_cells: skip rule derived cells in cellset\n    :param csv_dialect: provide all csv output settings through standard library csv.Dialect\n        If not provided dialect is created based on line_separator and value_separator arguments.\n    :param line_separator:\n    :param value_separator:\n    :param sandbox_name: str\n    :param include_attributes: include attribute columns\n    :param use_iterative_json: use iterative json parsing to reduce memory consumption significantly.\n    Comes at a cost of 3-5% performance.\n    :param use_compact_json: bool\n    :param use_blob: Has better performance on datasets &gt; 1M cells and lower memory footprint in any case.\n    :param mdx_headers: boolean, fully qualified hierarchy name as header instead of simple dimension name\n    :return: String\n    \"\"\"\n    if use_blob:\n        if include_attributes:\n            raise ValueError(\"'include_attributes' must not be used in conjunction with 'use_blob'\")\n        if use_iterative_json:\n            raise ValueError(\"'use_iterative_json' must not be used in conjunction with 'use_blob'\")\n        if use_compact_json:\n            raise ValueError(\"'use_compact_json' must not be used in conjunction with 'use_blob'\")\n        if csv_dialect:\n            raise ValueError(\"'csv_dialect' must not be used in conjunction with 'use_blob'\")\n        if line_separator != \"\\r\\n\":\n            raise ValueError(\"'line_separator' must be '\\r\\n' to leverage 'use_blob' feature\")\n\n        return self._execute_mdx_csv_use_blob(\n            mdx=mdx,\n            top=top,\n            skip=skip,\n            skip_zeros=skip_zeros,\n            skip_consolidated_cells=skip_consolidated_cells,\n            skip_rule_derived_cells=skip_rule_derived_cells,\n            value_separator=value_separator,\n            sandbox_name=sandbox_name,\n            mdx_headers=mdx_headers,\n            **kwargs,\n        )\n\n    cellset_id = self.create_cellset(mdx, sandbox_name=sandbox_name, **kwargs)\n\n    if use_iterative_json:\n        return self.extract_cellset_csv_iter_json(\n            cellset_id=cellset_id,\n            top=top,\n            skip=skip,\n            skip_zeros=skip_zeros,\n            skip_rule_derived_cells=skip_rule_derived_cells,\n            skip_consolidated_cells=skip_consolidated_cells,\n            csv_dialect=csv_dialect,\n            line_separator=line_separator,\n            value_separator=value_separator,\n            sandbox_name=sandbox_name,\n            include_attributes=include_attributes,\n            mdx_headers=mdx_headers,\n            **kwargs,\n        )\n\n    return self.extract_cellset_csv(\n        cellset_id=cellset_id,\n        top=top,\n        skip=skip,\n        skip_zeros=skip_zeros,\n        skip_rule_derived_cells=skip_rule_derived_cells,\n        skip_consolidated_cells=skip_consolidated_cells,\n        csv_dialect=csv_dialect,\n        line_separator=line_separator,\n        value_separator=value_separator,\n        sandbox_name=sandbox_name,\n        include_attributes=include_attributes,\n        use_compact_json=use_compact_json,\n        mdx_headers=mdx_headers,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.execute_mdx_dataframe","title":"<code>execute_mdx_dataframe(mdx, top=None, skip=None, skip_zeros=True, skip_consolidated_cells=False, skip_rule_derived_cells=False, sandbox_name=None, include_attributes=False, use_iterative_json=False, use_compact_json=False, use_blob=False, shaped=False, mdx_headers=False, fillna_numeric_attributes=False, fillna_numeric_attributes_value=0, fillna_string_attributes=False, fillna_string_attributes_value='', **kwargs)</code>","text":"<p>Optimized for performance. Get Pandas DataFrame from MDX Query.</p> <p>Takes all arguments from the pandas.read_csv method: https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html</p> <p>If 'use_blob' and 'shaped' are True, 'skip_zeros' will be overruled to False. This is necessary to assure column order is in line with cube view in TM1</p> <p>Parameters:</p> Name Type Description Default <code>mdx</code> <code>Union[str, MdxBuilder]</code> <p>Valid MDX Query</p> required <code>top</code> <code>int</code> <p>Int, number of cells to return (counting from top)</p> <code>None</code> <code>skip</code> <code>int</code> <p>Int, number of cells to skip (counting from top)</p> <code>None</code> <code>skip_zeros</code> <code>bool</code> <p>skip zeros in cellset (irrespective of zero suppression in MDX / view)</p> <code>True</code> <code>skip_consolidated_cells</code> <code>bool</code> <p>skip consolidated cells in cellset</p> <code>False</code> <code>skip_rule_derived_cells</code> <code>bool</code> <p>skip rule derived cells in cellset</p> <code>False</code> <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <code>include_attributes</code> <code>bool</code> <p>include attribute columns</p> <code>False</code> <code>use_iterative_json</code> <code>bool</code> <p>use iterative json parsing to reduce memory consumption significantly. Comes at a cost of 3-5% performance.</p> <code>False</code> <code>use_compact_json</code> <code>bool</code> <p>bool</p> <code>False</code> <code>use_blob</code> <code>bool</code> <p>Has better performance on datasets &gt; 1M cells and lower memory footprint in any case.</p> <code>False</code> <code>shaped</code> <code>bool</code> <p>preserve shape of view/mdx in data frame</p> <code>False</code> <code>mdx_headers</code> <code>bool</code> <p>boolean, fully qualified hierarchy name as header instead of simple dimension name</p> <code>False</code> <code>fillna_numeric_attributes</code> <code>bool</code> <p>boolean, fills empty numerical attributes with fillna_numeric_attributes_value</p> <code>False</code> <code>fillna_string_attributes</code> <code>bool</code> <p>boolean, fills empty string attributes with fillna_string_attributes_value</p> <code>False</code> <code>fillna_numeric_attributes_value</code> <code>Any</code> <p>Any, value with which to replace na if fillna_numeric_attributes is True</p> <code>0</code> <code>fillna_string_attributes_value</code> <code>Any</code> <p>Any, value with which to replace na if fillna_string_attributes is True</p> <code>''</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Pandas Dataframe</p> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>@require_pandas\ndef execute_mdx_dataframe(\n    self,\n    mdx: Union[str, MdxBuilder],\n    top: int = None,\n    skip: int = None,\n    skip_zeros: bool = True,\n    skip_consolidated_cells: bool = False,\n    skip_rule_derived_cells: bool = False,\n    sandbox_name: str = None,\n    include_attributes: bool = False,\n    use_iterative_json: bool = False,\n    use_compact_json: bool = False,\n    use_blob: bool = False,\n    shaped: bool = False,\n    mdx_headers: bool = False,\n    fillna_numeric_attributes: bool = False,\n    fillna_numeric_attributes_value: Any = 0,\n    fillna_string_attributes: bool = False,\n    fillna_string_attributes_value: Any = \"\",\n    **kwargs,\n) -&gt; \"pd.DataFrame\":\n    \"\"\"Optimized for performance. Get Pandas DataFrame from MDX Query.\n\n    Takes all arguments from the pandas.read_csv method:\n    https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html\n\n    If 'use_blob' and 'shaped' are True, 'skip_zeros' will be overruled to False.\n    This is necessary to assure column order is in line with cube view in TM1\n\n    :param mdx: Valid MDX Query\n    :param top: Int, number of cells to return (counting from top)\n    :param skip: Int, number of cells to skip (counting from top)\n    :param skip_zeros: skip zeros in cellset (irrespective of zero suppression in MDX / view)\n    :param skip_consolidated_cells: skip consolidated cells in cellset\n    :param skip_rule_derived_cells: skip rule derived cells in cellset\n    :param sandbox_name: str\n    :param include_attributes: include attribute columns\n    :param use_iterative_json: use iterative json parsing to reduce memory consumption significantly.\n    Comes at a cost of 3-5% performance.\n    :param use_compact_json: bool\n    :param use_blob: Has better performance on datasets &gt; 1M cells and lower memory footprint in any case.\n    :param shaped: preserve shape of view/mdx in data frame\n    :param mdx_headers: boolean, fully qualified hierarchy name as header instead of simple dimension name\n    :param fillna_numeric_attributes: boolean, fills empty numerical attributes with fillna_numeric_attributes_value\n    :param fillna_string_attributes: boolean, fills empty string attributes with fillna_string_attributes_value\n    :param fillna_numeric_attributes_value: Any, value with which to replace na if fillna_numeric_attributes is True\n    :param fillna_string_attributes_value: Any, value with which to replace na if fillna_string_attributes is True\n    :return: Pandas Dataframe\n    \"\"\"\n    if (fillna_numeric_attributes or fillna_string_attributes) and not include_attributes:\n        raise ValueError(\"Include attributes must be True if fillna_numeric or fillna_string is True.\")\n\n    # necessary to assure column order in line with cube view\n    if shaped:\n        skip_zeros = False\n\n    if use_blob:\n        if any(\n            [\n                fillna_numeric_attributes,\n                fillna_numeric_attributes_value,\n                fillna_string_attributes,\n                fillna_string_attributes_value,\n            ]\n        ):\n            raise ValueError(\"fillna attributes' feature must not be used with use_blob as True\")\n\n        raw_csv = self.execute_mdx_csv(\n            mdx=mdx,\n            top=top,\n            skip=skip,\n            skip_zeros=skip_zeros,\n            skip_consolidated_cells=skip_consolidated_cells,\n            skip_rule_derived_cells=skip_rule_derived_cells,\n            sandbox_name=sandbox_name,\n            include_attributes=include_attributes,\n            line_separator=\"\\r\\n\",\n            value_separator=\"~\",\n            use_blob=use_blob,\n            mdx_headers=mdx_headers,\n        )\n\n        return build_dataframe_from_csv(raw_csv, sep=\"~\", shaped=shaped, **kwargs)\n\n    cellset_id = self.create_cellset(mdx, sandbox_name=sandbox_name, **kwargs)\n    return self.extract_cellset_dataframe(\n        cellset_id,\n        top=top,\n        skip=skip,\n        skip_zeros=skip_zeros,\n        skip_consolidated_cells=skip_consolidated_cells,\n        skip_rule_derived_cells=skip_rule_derived_cells,\n        sandbox_name=sandbox_name,\n        include_attributes=include_attributes,\n        use_iterative_json=use_iterative_json,\n        use_compact_json=use_compact_json,\n        shaped=shaped,\n        mdx_headers=mdx_headers,\n        fillna_numeric_attributes=fillna_numeric_attributes,\n        fillna_numeric_attributes_value=fillna_numeric_attributes_value,\n        fillna_string_attributes=fillna_string_attributes,\n        fillna_string_attributes_value=fillna_string_attributes_value,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.execute_mdx_dataframe_async","title":"<code>execute_mdx_dataframe_async(mdx_list, max_workers=8, top=None, skip=None, skip_zeros=True, skip_consolidated_cells=False, skip_rule_derived_cells=False, sandbox_name=None, include_attributes=False, use_iterative_json=False, use_compact_json=False, use_blob=False, shaped=False, mdx_headers=False, **kwargs)</code>","text":"Source code in <code>TM1py/Services/CellService.py</code> <pre><code>@require_pandas\ndef execute_mdx_dataframe_async(\n    self,\n    mdx_list: List[Union[str, MdxBuilder]],\n    max_workers: int = 8,\n    top: int = None,\n    skip: int = None,\n    skip_zeros: bool = True,\n    skip_consolidated_cells: bool = False,\n    skip_rule_derived_cells: bool = False,\n    sandbox_name: str = None,\n    include_attributes: bool = False,\n    use_iterative_json: bool = False,\n    use_compact_json: bool = False,\n    use_blob: bool = False,\n    shaped: bool = False,\n    mdx_headers: bool = False,\n    **kwargs,\n) -&gt; \"pd.DataFrame\":\n\n    def _execute_mdx_dataframe(mdx: Union[str, MdxBuilder]):\n        return self.execute_mdx_dataframe(\n            mdx=mdx,\n            top=top,\n            skip=skip,\n            skip_zeros=skip_zeros,\n            skip_consolidated_cells=skip_consolidated_cells,\n            skip_rule_derived_cells=skip_rule_derived_cells,\n            sandbox_name=sandbox_name,\n            include_attributes=include_attributes,\n            use_iterative_json=use_iterative_json,\n            use_compact_json=use_compact_json,\n            use_blob=use_blob,\n            shaped=shaped,\n            mdx_headers=mdx_headers,\n            **kwargs,\n        )\n\n    async def _exec_mdx_dataframe_async():\n        loop = asyncio.get_event_loop()\n        result_list = []\n        with ThreadPoolExecutor(max_workers) as executor:\n            futures = [loop.run_in_executor(executor, _execute_mdx_dataframe, mdx) for mdx in mdx_list]\n            for future in futures:\n                result = await future\n                result_list.append(result)\n        return pd.concat(result_list, ignore_index=True)\n\n    result_dataframe = asyncio.run(_exec_mdx_dataframe_async())\n\n    return result_dataframe\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.execute_mdx_dataframe_pivot","title":"<code>execute_mdx_dataframe_pivot(mdx, dropna=False, fill_value=None, sandbox_name=None)</code>","text":"<p>Execute MDX Query to get a pandas pivot data frame in the shape as specified in the Query</p> <p>Parameters:</p> Name Type Description Default <code>mdx</code> <code>str</code> required <code>dropna</code> <code>bool</code> <code>False</code> <code>fill_value</code> <code>bool</code> <code>None</code> <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>@require_pandas\ndef execute_mdx_dataframe_pivot(\n    self, mdx: str, dropna: bool = False, fill_value: bool = None, sandbox_name: str = None\n) -&gt; \"pd.DataFrame\":\n    \"\"\"Execute MDX Query to get a pandas pivot data frame in the shape as specified in the Query\n\n    :param mdx:\n    :param dropna:\n    :param fill_value:\n    :param sandbox_name: str\n    :return:\n    \"\"\"\n    cellset_id = self.create_cellset(mdx=mdx, sandbox_name=sandbox_name)\n    return self.extract_cellset_dataframe_pivot(\n        cellset_id=cellset_id, dropna=dropna, fill_value=fill_value, sandbox_name=sandbox_name\n    )\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.execute_mdx_dataframe_shaped","title":"<code>execute_mdx_dataframe_shaped(mdx, sandbox_name=None, display_attribute=False, use_iterative_json=False, use_blob=False, mdx_headers=False, **kwargs)</code>","text":"<p>Retrieves data from cube in the shape of the query. Dimensions on rows can be stacked. One dimension must be placed on columns. Title selections are ignored.</p> <p>Parameters:</p> Name Type Description Default <code>mdx</code> <code>str</code> required <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <code>use_blob</code> <code>bool</code> <code>False</code> <code>use_iterative_json</code> <code>bool</code> <code>False</code> <code>display_attribute</code> <code>bool</code> <p>bool, show element name or first attribute from MDX PROPERTIES clause</p> <code>False</code> <code>kwargs</code> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>@require_pandas\ndef execute_mdx_dataframe_shaped(\n    self,\n    mdx: str,\n    sandbox_name: str = None,\n    display_attribute: bool = False,\n    use_iterative_json: bool = False,\n    use_blob: bool = False,\n    mdx_headers: bool = False,\n    **kwargs,\n) -&gt; \"pd.DataFrame\":\n    \"\"\"Retrieves data from cube in the shape of the query.\n    Dimensions on rows can be stacked. One dimension must be placed on columns. Title selections are ignored.\n\n    :param mdx:\n    :param sandbox_name: str\n    :param use_blob:\n    :param use_iterative_json:\n    :param display_attribute: bool, show element name or first attribute from MDX PROPERTIES clause\n    :param kwargs:\n    :return:\n    \"\"\"\n    if display_attribute and any([use_blob, use_iterative_json]):\n        raise ValueError(\"When 'use_blob' or 'use_iterative_json' is True, 'display_attribute' must be False\")\n\n    # default case\n    if not any([use_blob, use_iterative_json]):\n        cellset_id = self.create_cellset(mdx=mdx, sandbox_name=sandbox_name)\n        return self.extract_cellset_dataframe_shaped(\n            cellset_id=cellset_id,\n            delete_cellset=True,\n            sandbox_name=sandbox_name,\n            display_attribute=display_attribute,\n            mdx_headers=mdx_headers,\n            **kwargs,\n        )\n\n    if all([use_blob, use_iterative_json]):\n        raise ValueError(\"'use_blob' and 'use_iterative_json' must not be used together\")\n\n    # ijson approach\n    if use_iterative_json:\n        return self.execute_mdx_dataframe(\n            mdx=mdx,\n            shaped=True,\n            sandbox_name=sandbox_name,\n            use_iterative_json=use_iterative_json,\n            use_blob=False,\n            mdx_headers=mdx_headers,\n            **kwargs,\n        )\n\n    # blob approach\n    return self.execute_mdx_dataframe(\n        mdx=mdx, shaped=True, sandbox_name=sandbox_name, use_blob=True, mdx_headers=mdx_headers, **kwargs\n    )\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.execute_mdx_elements_value_dict","title":"<code>execute_mdx_elements_value_dict(mdx, top=None, skip=None, skip_zeros=True, skip_consolidated_cells=False, skip_rule_derived_cells=False, element_separator='|', sandbox_name=None, **kwargs)</code>","text":"<p>Optimized for performance. Get Dict from MDX Query.</p> <p>Parameters:</p> Name Type Description Default <code>mdx</code> <code>str</code> <p>Valid MDX Query</p> required <code>top</code> <code>int</code> <p>Int, number of cells to return (counting from top)</p> <code>None</code> <code>skip</code> <code>int</code> <p>Int, number of cells to skip (counting from top)</p> <code>None</code> <code>skip_zeros</code> <code>bool</code> <p>skip zeros in cellset (irrespective of zero suppression in MDX / view)</p> <code>True</code> <code>skip_consolidated_cells</code> <code>bool</code> <p>skip consolidated cells in cellset</p> <code>False</code> <code>skip_rule_derived_cells</code> <code>bool</code> <p>skip rule derived cells in cellset</p> <code>False</code> <code>element_separator</code> <code>str</code> <p>separator for the dimension element combination</p> <code>'|'</code> <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <p>Returns:</p> Type Description <code>CaseAndSpaceInsensitiveDict</code> <p>CaseAndSpaceInsensitiveDict {'2020|Jan|Sales': 2000, '2020|Feb|Sales': 3000}</p> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def execute_mdx_elements_value_dict(\n    self,\n    mdx: str,\n    top: int = None,\n    skip: int = None,\n    skip_zeros: bool = True,\n    skip_consolidated_cells: bool = False,\n    skip_rule_derived_cells: bool = False,\n    element_separator: str = \"|\",\n    sandbox_name: str = None,\n    **kwargs,\n) -&gt; CaseAndSpaceInsensitiveDict:\n    \"\"\"Optimized for performance. Get Dict from MDX Query.\n    :param mdx: Valid MDX Query\n    :param top: Int, number of cells to return (counting from top)\n    :param skip: Int, number of cells to skip (counting from top)\n    :param skip_zeros: skip zeros in cellset (irrespective of zero suppression in MDX / view)\n    :param skip_consolidated_cells: skip consolidated cells in cellset\n    :param skip_rule_derived_cells: skip rule derived cells in cellset\n    :param element_separator: separator for the dimension element combination\n    :param sandbox_name: str\n    :return: CaseAndSpaceInsensitiveDict {'2020|Jan|Sales': 2000, '2020|Feb|Sales': 3000}\n    \"\"\"\n    lines = self.execute_mdx_csv(\n        mdx=mdx,\n        top=top,\n        skip=skip,\n        skip_zeros=skip_zeros,\n        skip_consolidated_cells=skip_consolidated_cells,\n        skip_rule_derived_cells=skip_rule_derived_cells,\n        value_separator=element_separator,\n        sandbox_name=sandbox_name,\n        **kwargs,\n    )\n    reader = csv.reader(StringIO(lines), delimiter=element_separator)\n\n    # skip header\n    next(reader, None)\n\n    elements_value_dict = CaseAndSpaceInsensitiveDict()\n    for row in reader:\n        elements_value_dict[element_separator.join(row[:-1])] = row[-1]\n    return elements_value_dict\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.execute_mdx_raw","title":"<code>execute_mdx_raw(mdx, cell_properties=None, elem_properties=None, member_properties=None, top=None, skip_contexts=False, skip=None, skip_zeros=False, skip_consolidated_cells=False, skip_rule_derived_cells=False, sandbox_name=None, include_hierarchies=False, use_compact_json=False, **kwargs)</code>","text":"<p>Execute MDX and return the raw data from TM1</p> <p>Parameters:</p> Name Type Description Default <code>mdx</code> <code>str</code> <p>String, a valid MDX Query</p> required <code>cell_properties</code> <code>Iterable[str]</code> <p>List of properties to be queried from the cell. E.g. ['Value', 'RuleDerived', ...]</p> <code>None</code> <code>elem_properties</code> <code>Iterable[str]</code> <p>List of properties to be queried from the elements. E.g. ['Name','Attributes', ...]</p> <code>None</code> <code>member_properties</code> <code>Iterable[str]</code> <p>List of properties to be queried from the members. E.g. ['Name','Attributes', ...]</p> <code>None</code> <code>top</code> <code>int</code> <p>Integer limiting the number of cells and the number or rows returned</p> <code>None</code> <code>skip</code> <code>int</code> <p>Integer limiting the number of cells and the number or rows returned</p> <code>None</code> <code>skip_contexts</code> <code>bool</code> <p>skip elements from titles / contexts in response</p> <code>False</code> <code>skip_zeros</code> <code>bool</code> <p>skip zeros in cellset (irrespective of zero suppression in MDX / view)</p> <code>False</code> <code>skip_consolidated_cells</code> <code>bool</code> <p>skip consolidated cells in cellset</p> <code>False</code> <code>skip_rule_derived_cells</code> <code>bool</code> <p>skip rule derived cells in cellset</p> <code>False</code> <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <code>include_hierarchies</code> <code>bool</code> <p>retrieve Hierarchies property on Axes</p> <code>False</code> <code>use_compact_json</code> <code>bool</code> <p>bool</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict</code> <p>Raw format from TM1.</p> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def execute_mdx_raw(\n    self,\n    mdx: str,\n    cell_properties: Iterable[str] = None,\n    elem_properties: Iterable[str] = None,\n    member_properties: Iterable[str] = None,\n    top: int = None,\n    skip_contexts: bool = False,\n    skip: int = None,\n    skip_zeros: bool = False,\n    skip_consolidated_cells: bool = False,\n    skip_rule_derived_cells: bool = False,\n    sandbox_name: str = None,\n    include_hierarchies: bool = False,\n    use_compact_json: bool = False,\n    **kwargs,\n) -&gt; Dict:\n    \"\"\"Execute MDX and return the raw data from TM1\n\n    :param mdx: String, a valid MDX Query\n    :param cell_properties: List of properties to be queried from the cell. E.g. ['Value', 'RuleDerived', ...]\n    :param elem_properties: List of properties to be queried from the elements. E.g. ['Name','Attributes', ...]\n    :param member_properties: List of properties to be queried from the members. E.g. ['Name','Attributes', ...]\n    :param top: Integer limiting the number of cells and the number or rows returned\n    :param skip: Integer limiting the number of cells and the number or rows returned\n    :param skip_contexts: skip elements from titles / contexts in response\n    :param skip_zeros: skip zeros in cellset (irrespective of zero suppression in MDX / view)\n    :param skip_consolidated_cells: skip consolidated cells in cellset\n    :param skip_rule_derived_cells: skip rule derived cells in cellset\n    :param sandbox_name: str\n    :param include_hierarchies: retrieve Hierarchies property on Axes\n    :param use_compact_json: bool\n    :return: Raw format from TM1.\n    \"\"\"\n    cellset_id = self.create_cellset(mdx=mdx, sandbox_name=sandbox_name, **kwargs)\n    return self.extract_cellset_raw(\n        cellset_id=cellset_id,\n        cell_properties=cell_properties,\n        elem_properties=elem_properties,\n        member_properties=member_properties,\n        top=top,\n        skip=skip,\n        delete_cellset=True,\n        skip_contexts=skip_contexts,\n        skip_zeros=skip_zeros,\n        skip_consolidated_cells=skip_consolidated_cells,\n        skip_rule_derived_cells=skip_rule_derived_cells,\n        sandbox_name=sandbox_name,\n        include_hierarchies=include_hierarchies,\n        use_compact_json=use_compact_json,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.execute_mdx_rows_and_values","title":"<code>execute_mdx_rows_and_values(mdx, element_unique_names=True, sandbox_name=None, **kwargs)</code>","text":"<p>Execute MDX and retrieve row element names and values in a case and space insensitive dictionary</p> <p>Parameters:</p> Name Type Description Default <code>mdx</code> <code>str</code> required <code>element_unique_names</code> <code>bool</code> <code>True</code> <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <code>kwargs</code> <code>{}</code> <p>Returns:</p> Type Description <code>CaseAndSpaceInsensitiveTuplesDict</code> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def execute_mdx_rows_and_values(\n    self, mdx: str, element_unique_names: bool = True, sandbox_name: str = None, **kwargs\n) -&gt; CaseAndSpaceInsensitiveTuplesDict:\n    \"\"\"Execute MDX and retrieve row element names and values in a case and space insensitive dictionary\n\n    :param mdx:\n    :param element_unique_names:\n    :param sandbox_name: str\n    :param kwargs:\n    :return:\n    \"\"\"\n    cellset_id = self.create_cellset(mdx=mdx, sandbox_name=sandbox_name, **kwargs)\n    return self.extract_cellset_rows_and_values(\n        cellset_id, element_unique_names, delete_cellset=True, sandbox_name=sandbox_name, **kwargs\n    )\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.execute_mdx_rows_and_values_string_set","title":"<code>execute_mdx_rows_and_values_string_set(mdx, exclude_empty_cells=True, sandbox_name=None, **kwargs)</code>","text":"<p>Retrieve row element names and string cell values in a case and space insensitive set</p> <p>Parameters:</p> Name Type Description Default <code>exclude_empty_cells</code> <code>bool</code> <code>True</code> <code>mdx</code> <code>str</code> required <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <p>Returns:</p> Type Description <code>CaseAndSpaceInsensitiveSet</code> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def execute_mdx_rows_and_values_string_set(\n    self, mdx: str, exclude_empty_cells: bool = True, sandbox_name: str = None, **kwargs\n) -&gt; CaseAndSpaceInsensitiveSet:\n    \"\"\"Retrieve row element names and **string** cell values in a case and space insensitive set\n\n    :param exclude_empty_cells:\n    :param mdx:\n    :param sandbox_name: str\n    :return:\n    \"\"\"\n    rows_and_values = self.execute_mdx_rows_and_values(\n        mdx, element_unique_names=False, sandbox_name=sandbox_name, **kwargs\n    )\n    return self._extract_string_set_from_rows_and_values(rows_and_values, exclude_empty_cells)\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.execute_mdx_ui_array","title":"<code>execute_mdx_ui_array(mdx, elem_properties=None, member_properties=None, value_precision=2, top=None, skip=None, sandbox_name=None, use_compact_json=False, **kwargs)</code>","text":"<p>Useful for grids or charting libraries that want an array of cell values per row. Returns 3-dimensional cell structure for tabbed grids or multiple charts. Rows and pages are dicts, addressable by their name. Proper order of rows can be obtained in headers[1] Example 'cells' return format: <pre><code>'cells': {\n    '10100': {\n        'Net Operating Income': [ 19832724.72429739,\n                                    20365654.788303416,\n                                    20729201.329183243,\n                                    20480205.20121749],\n        'Revenue': [ 28981046.50724231,\n                        29512482.207418434,\n                        29913730.038971487,\n                        29563345.9542385]},\n    '10200': {\n        'Net Operating Income': [ 9853293.623709997,\n                                    10277650.763958748,\n                                    10466934.096533755,\n                                    10333095.839474997],\n        'Revenue': [ 13888143.710000003,\n                        14300216.43,\n                        14502421.63,\n                        14321501.940000001]}\n},\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>top</code> <code>int</code> <p>Int, number of cells to return (counting from top)</p> <code>None</code> <code>skip</code> <code>int</code> <p>Int, number of cells to skip (counting from top)</p> <code>None</code> <code>mdx</code> <code>str</code> <p>a valid MDX Query</p> required <code>elem_properties</code> <code>Iterable[str]</code> <p>List of properties to be queried from the elements. E.g. ['UniqueName','Attributes']</p> <code>None</code> <code>member_properties</code> <code>Iterable[str]</code> <p>List of properties to be queried from the members. E.g. ['UniqueName','Attributes']</p> <code>None</code> <code>value_precision</code> <code>int</code> <p>Integer (optional) specifying number of decimal places to return</p> <code>2</code> <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <code>use_compact_json</code> <code>bool</code> <p>bool</p> <code>False</code> <p>Returns:</p> Type Description <p>dict :<code>{ titles: [], headers: [axis][], cells:{ Page0:{ Row0:{ [row values], Row1: [], ...}, ...}, ...}}</code></p> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def execute_mdx_ui_array(\n    self,\n    mdx: str,\n    elem_properties: Iterable[str] = None,\n    member_properties: Iterable[str] = None,\n    value_precision: int = 2,\n    top: int = None,\n    skip: int = None,\n    sandbox_name: str = None,\n    use_compact_json: bool = False,\n    **kwargs,\n):\n    \"\"\"\n    Useful for grids or charting libraries that want an array of cell values per row.\n    Returns 3-dimensional cell structure for tabbed grids or multiple charts.\n    Rows and pages are dicts, addressable by their name. Proper order of rows can be obtained in headers[1]\n    Example 'cells' return format:\n    ```\n    'cells': {\n        '10100': {\n            'Net Operating Income': [ 19832724.72429739,\n                                        20365654.788303416,\n                                        20729201.329183243,\n                                        20480205.20121749],\n            'Revenue': [ 28981046.50724231,\n                            29512482.207418434,\n                            29913730.038971487,\n                            29563345.9542385]},\n        '10200': {\n            'Net Operating Income': [ 9853293.623709997,\n                                        10277650.763958748,\n                                        10466934.096533755,\n                                        10333095.839474997],\n            'Revenue': [ 13888143.710000003,\n                            14300216.43,\n                            14502421.63,\n                            14321501.940000001]}\n    },\n    ```\n    :param top: Int, number of cells to return (counting from top)\n    :param skip: Int, number of cells to skip (counting from top)\n    :param mdx: a valid MDX Query\n    :param elem_properties: List of properties to be queried from the elements. E.g. ['UniqueName','Attributes']\n    :param member_properties: List of properties to be queried from the members. E.g. ['UniqueName','Attributes']\n    :param value_precision: Integer (optional) specifying number of decimal places to return\n    :param sandbox_name: str\n    :param use_compact_json: bool\n    :return: dict :`{ titles: [], headers: [axis][], cells:{ Page0:{ Row0:{ [row values], Row1: [], ...}, ...}, ...}}`\n    \"\"\"\n    cellset_id = self.create_cellset(mdx=mdx, sandbox_name=sandbox_name, **kwargs)\n    data = self.extract_cellset_raw(\n        cellset_id=cellset_id,\n        cell_properties=[\"Value\"],\n        elem_properties=elem_properties,\n        member_properties=list(set(member_properties or []) | {\"Name\"}),\n        top=top,\n        skip=skip,\n        delete_cellset=True,\n        sandbox_name=sandbox_name,\n        use_compact_json=use_compact_json,\n        **kwargs,\n    )\n    return Utils.build_ui_arrays_from_cellset(raw_cellset_as_dict=data, value_precision=value_precision, top=top)\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.execute_mdx_ui_dygraph","title":"<code>execute_mdx_ui_dygraph(mdx, elem_properties=None, member_properties=None, value_precision=2, top=None, skip=None, sandbox_name=None, use_compact_json=False, **kwargs)</code>","text":"<p>Execute MDX get dygraph dictionary Useful for grids or charting libraries that want an array of cell values per column Returns 3-dimensional cell structure for tabbed grids or multiple charts Example 'cells' return format: <pre><code>'cells': {\n    '10100': [\n        ['Q1-2004', 28981046.50724231, 19832724.72429739],\n        ['Q2-2004', 29512482.207418434, 20365654.788303416],\n        ['Q3-2004', 29913730.038971487, 20729201.329183243],\n        ['Q4-2004', 29563345.9542385, 20480205.20121749]],\n    '10200': [\n        ['Q1-2004', 13888143.710000003, 9853293.623709997],\n        ['Q2-2004', 14300216.43, 10277650.763958748],\n        ['Q3-2004', 14502421.63, 10466934.096533755],\n        ['Q4-2004', 14321501.940000001, 10333095.839474997]]\n},\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>top</code> <code>int</code> <p>Int, number of cells to return (counting from top)</p> <code>None</code> <code>skip</code> <code>int</code> <p>Int, number of cells to skip (counting from top)</p> <code>None</code> <code>mdx</code> <code>str</code> <p>String, valid MDX Query</p> required <code>elem_properties</code> <code>Iterable[str]</code> <p>List of properties to be queried from the elements. E.g. ['UniqueName','Attributes']</p> <code>None</code> <code>member_properties</code> <code>Iterable[str]</code> <p>List of properties to be queried from the members. E.g. ['UniqueName','Attributes']</p> <code>None</code> <code>value_precision</code> <code>int</code> <p>Integer (optional) specifying number of decimal places to return</p> <code>2</code> <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <code>use_compact_json</code> <code>bool</code> <p>bool</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict</code> <p>dict: <code>{ titles: [], headers: [axis][], cells: { Page0: [ [column name, column values], [], ... ], ...}}</code></p> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def execute_mdx_ui_dygraph(\n    self,\n    mdx: str,\n    elem_properties: Iterable[str] = None,\n    member_properties: Iterable[str] = None,\n    value_precision: int = 2,\n    top: int = None,\n    skip: int = None,\n    sandbox_name: str = None,\n    use_compact_json: bool = False,\n    **kwargs,\n) -&gt; Dict:\n    \"\"\"Execute MDX get dygraph dictionary\n    Useful for grids or charting libraries that want an array of cell values per column\n    Returns 3-dimensional cell structure for tabbed grids or multiple charts\n    Example 'cells' return format:\n    ```\n    'cells': {\n        '10100': [\n            ['Q1-2004', 28981046.50724231, 19832724.72429739],\n            ['Q2-2004', 29512482.207418434, 20365654.788303416],\n            ['Q3-2004', 29913730.038971487, 20729201.329183243],\n            ['Q4-2004', 29563345.9542385, 20480205.20121749]],\n        '10200': [\n            ['Q1-2004', 13888143.710000003, 9853293.623709997],\n            ['Q2-2004', 14300216.43, 10277650.763958748],\n            ['Q3-2004', 14502421.63, 10466934.096533755],\n            ['Q4-2004', 14321501.940000001, 10333095.839474997]]\n    },\n    ```\n    :param top: Int, number of cells to return (counting from top)\n    :param skip: Int, number of cells to skip (counting from top)\n    :param mdx: String, valid MDX Query\n    :param elem_properties: List of properties to be queried from the elements. E.g. ['UniqueName','Attributes']\n    :param member_properties: List of properties to be queried from the members. E.g. ['UniqueName','Attributes']\n    :param value_precision: Integer (optional) specifying number of decimal places to return\n    :param sandbox_name: str\n    :param use_compact_json: bool\n    :return: dict: `{ titles: [], headers: [axis][], cells: { Page0: [ [column name, column values], [], ... ], ...}}`\n    \"\"\"\n    cellset_id = self.create_cellset(mdx=mdx, sandbox_name=sandbox_name)\n    data = self.extract_cellset_raw(\n        cellset_id=cellset_id,\n        cell_properties=[\"Value\"],\n        elem_properties=elem_properties,\n        member_properties=list(set(member_properties or []) | {\"Name\"}),\n        top=top,\n        skip=skip,\n        delete_cellset=True,\n        sandbox_name=sandbox_name,\n        use_compact_json=use_compact_json,\n        **kwargs,\n    )\n    return Utils.build_ui_dygraph_arrays_from_cellset(raw_cellset_as_dict=data, value_precision=value_precision)\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.execute_mdx_values","title":"<code>execute_mdx_values(mdx, sandbox_name=None, use_compact_json=False, skip_zeros=False, skip_consolidated_cells=False, skip_rule_derived_cells=False, **kwargs)</code>","text":"<p>Optimized for performance. Query only raw cell values. Coordinates are omitted !</p> <p>Parameters:</p> Name Type Description Default <code>mdx</code> <code>str</code> <p>a valid MDX Query</p> required <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <code>use_compact_json</code> <code>bool</code> <p>bool</p> <code>False</code> <code>skip_zeros</code> <code>bool</code> <p>bool</p> <code>False</code> <code>skip_consolidated_cells</code> <code>bool</code> <p>bool</p> <code>False</code> <code>skip_rule_derived_cells</code> <code>bool</code> <p>bool</p> <code>False</code> <p>Returns:</p> Type Description <code>List[Union[str, float]]</code> <p>List of cell values</p> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def execute_mdx_values(\n    self,\n    mdx: str,\n    sandbox_name: str = None,\n    use_compact_json: bool = False,\n    skip_zeros: bool = False,\n    skip_consolidated_cells: bool = False,\n    skip_rule_derived_cells: bool = False,\n    **kwargs,\n) -&gt; List[Union[str, float]]:\n    \"\"\"Optimized for performance. Query only raw cell values.\n    Coordinates are omitted !\n\n    :param mdx: a valid MDX Query\n    :param sandbox_name: str\n    :param use_compact_json: bool\n    :param skip_zeros: bool\n    :param skip_consolidated_cells: bool\n    :param skip_rule_derived_cells: bool\n    :return: List of cell values\n    \"\"\"\n    cellset_id = self.create_cellset(mdx=mdx, sandbox_name=sandbox_name, **kwargs)\n    return self.extract_cellset_values(\n        cellset_id,\n        delete_cellset=True,\n        sandbox_name=sandbox_name,\n        skip_zeros=skip_zeros,\n        skip_consolidated_cells=skip_consolidated_cells,\n        skip_rule_derived_cells=skip_rule_derived_cells,\n        use_compact_json=use_compact_json,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.execute_unbound_process","title":"<code>execute_unbound_process(process, **kwargs)</code>","text":"Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def execute_unbound_process(self, process: Process, **kwargs) -&gt; Tuple[bool, str, str]:\n    from TM1py import ProcessService\n\n    process_service = ProcessService(self._rest)\n\n    return process_service.execute_process_with_return(process, **kwargs)\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.execute_view","title":"<code>execute_view(cube_name, view_name, private=False, cell_properties=None, top=None, skip_contexts=False, skip=None, skip_zeros=False, skip_consolidated_cells=False, skip_rule_derived_cells=False, sandbox_name=None, element_unique_names=True, skip_cell_properties=False, use_compact_json=False, max_workers=1, async_axis=0, **kwargs)</code>","text":"<p>get view content as dictionary with sweet and concise structure.     Works on NativeView and MDXView !</p> <p>Parameters:</p> Name Type Description Default <code>cube_name</code> <code>str</code> <p>String, name of the cube</p> required <code>view_name</code> <code>str</code> <p>String, name of the view</p> required <code>private</code> <code>bool</code> <p>True (private) or False (public)</p> <code>False</code> <code>cell_properties</code> <code>Iterable[str]</code> <p>List, cell properties: [Values, Status, HasPicklist, etc.]</p> <code>None</code> <code>top</code> <code>int</code> <p>Int, number of cells to return (counting from top)</p> <code>None</code> <code>skip</code> <code>int</code> <p>Int, number of cells to skip (counting from top)</p> <code>None</code> <code>skip_contexts</code> <code>bool</code> <p>skip elements from titles / contexts in response</p> <code>False</code> <code>skip_zeros</code> <code>bool</code> <p>skip zeros in cellset (irrespective of zero suppression in MDX / view)</p> <code>False</code> <code>skip_consolidated_cells</code> <code>bool</code> <p>skip consolidated cells in cellset</p> <code>False</code> <code>skip_rule_derived_cells</code> <code>bool</code> <p>skip rule derived cells in cellset</p> <code>False</code> <code>element_unique_names</code> <code>bool</code> <p>'[d1].[h1].[e1]' or 'e1'</p> <code>True</code> <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <code>skip_cell_properties</code> <code>bool</code> <p>cell values in result dictionary, instead of cell_properties dictionary</p> <code>False</code> <code>max_workers</code> <code>int</code> <p>Int, number of threads to use in parallel</p> <code>1</code> <code>async_axis</code> <code>int</code> <p>0 (columns) or 1 (rows). On which axis to parallelize retrieval</p> <code>0</code> <code>use_compact_json</code> <code>bool</code> <p>bool</p> <code>False</code> <p>Returns:</p> Type Description <code>CaseAndSpaceInsensitiveTuplesDict</code> <p>Dictionary : <code>{([dim1].[elem1], [dim2][elem6]): {'Value':3127.312, 'Ordinal':12}   ....  }</code></p> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def execute_view(\n    self,\n    cube_name: str,\n    view_name: str,\n    private: bool = False,\n    cell_properties: Iterable[str] = None,\n    top: int = None,\n    skip_contexts: bool = False,\n    skip: int = None,\n    skip_zeros: bool = False,\n    skip_consolidated_cells: bool = False,\n    skip_rule_derived_cells: bool = False,\n    sandbox_name: str = None,\n    element_unique_names: bool = True,\n    skip_cell_properties: bool = False,\n    use_compact_json: bool = False,\n    max_workers: int = 1,\n    async_axis: int = 0,\n    **kwargs,\n) -&gt; CaseAndSpaceInsensitiveTuplesDict:\n    \"\"\"get view content as dictionary with sweet and concise structure.\n        Works on NativeView and MDXView !\n\n    :param cube_name: String, name of the cube\n    :param view_name: String, name of the view\n    :param private: True (private) or False (public)\n    :param cell_properties: List, cell properties: [Values, Status, HasPicklist, etc.]\n    :param top: Int, number of cells to return (counting from top)\n    :param skip: Int, number of cells to skip (counting from top)\n    :param skip_contexts: skip elements from titles / contexts in response\n    :param skip_zeros: skip zeros in cellset (irrespective of zero suppression in MDX / view)\n    :param skip_consolidated_cells: skip consolidated cells in cellset\n    :param skip_rule_derived_cells: skip rule derived cells in cellset\n    :param element_unique_names: '[d1].[h1].[e1]' or 'e1'\n    :param sandbox_name: str\n    :param skip_cell_properties: cell values in result dictionary, instead of cell_properties dictionary\n    :param max_workers: Int, number of threads to use in parallel\n    :param async_axis: 0 (columns) or 1 (rows). On which axis to parallelize retrieval\n    :param use_compact_json: bool\n    :return: Dictionary : `{([dim1].[elem1], [dim2][elem6]): {'Value':3127.312, 'Ordinal':12}   ....  }`\n    \"\"\"\n    if max_workers &gt; 1:\n        return self.execute_view_async(\n            cube_name=cube_name,\n            view_name=view_name,\n            private=private,\n            top=top,\n            skip=skip,\n            skip_contexts=skip_contexts,\n            skip_zeros=skip_zeros,\n            skip_consolidated_cells=skip_consolidated_cells,\n            skip_rule_derived_cells=skip_rule_derived_cells,\n            sandbox_name=sandbox_name,\n            element_unique_names=element_unique_names,\n            skip_cell_properties=skip_cell_properties,\n            max_workers=max_workers,\n            async_axis=async_axis,\n        )\n    cellset_id = self.create_cellset_from_view(\n        cube_name=cube_name, view_name=view_name, private=private, sandbox_name=sandbox_name, **kwargs\n    )\n    return self.extract_cellset(\n        cellset_id=cellset_id,\n        cell_properties=cell_properties,\n        top=top,\n        skip=skip,\n        skip_contexts=skip_contexts,\n        skip_zeros=skip_zeros,\n        skip_consolidated_cells=skip_consolidated_cells,\n        skip_rule_derived_cells=skip_rule_derived_cells,\n        delete_cellset=True,\n        sandbox_name=sandbox_name,\n        element_unique_names=element_unique_names,\n        skip_cell_properties=skip_cell_properties,\n        use_compact_json=use_compact_json,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.execute_view_async","title":"<code>execute_view_async(cube_name, view_name, private=False, cell_properties=None, top=None, skip_contexts=False, skip=None, skip_zeros=False, skip_consolidated_cells=False, skip_rule_derived_cells=False, sandbox_name=None, element_unique_names=True, skip_cell_properties=False, max_workers=8, async_axis=0, **kwargs)</code>","text":"<p>get view content as dictionary with sweet and concise structure.     Works on NativeView and MDXView !</p> <p>Parameters:</p> Name Type Description Default <code>cube_name</code> <code>str</code> <p>String, name of the cube</p> required <code>view_name</code> <code>str</code> <p>String, name of the view</p> required <code>private</code> <code>bool</code> <p>True (private) or False (public)</p> <code>False</code> <code>cell_properties</code> <code>Iterable[str]</code> <p>List, cell properties: [Values, Status, HasPicklist, etc.]</p> <code>None</code> <code>top</code> <code>int</code> <p>Int, number of cells to return (counting from top)</p> <code>None</code> <code>skip</code> <code>int</code> <p>Int, number of cells to skip (counting from top)</p> <code>None</code> <code>skip_contexts</code> <code>bool</code> <p>skip elements from titles / contexts in response</p> <code>False</code> <code>skip_zeros</code> <code>bool</code> <p>skip zeros in cellset (irrespective of zero suppression in MDX / view)</p> <code>False</code> <code>skip_consolidated_cells</code> <code>bool</code> <p>skip consolidated cells in cellset</p> <code>False</code> <code>skip_rule_derived_cells</code> <code>bool</code> <p>skip rule derived cells in cellset</p> <code>False</code> <code>element_unique_names</code> <code>bool</code> <p>'[d1].[h1].[e1]' or 'e1'</p> <code>True</code> <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <code>skip_cell_properties</code> <code>bool</code> <p>cell values in result dictionary, instead of cell_properties dictionary</p> <code>False</code> <code>max_workers</code> <code>int</code> <p>Int, number of threads to use in parallel</p> <code>8</code> <code>async_axis</code> <code>int</code> <p>0 (columns) or 1 (rows). On which axis to parallelize retrieval</p> <code>0</code> <p>Returns:</p> Type Description <code>CaseAndSpaceInsensitiveTuplesDict</code> <p>Dictionary : <code>{([dim1].[elem1], [dim2][elem6]): {'Value':3127.312, 'Ordinal':12}   ....  }</code></p> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def execute_view_async(\n    self,\n    cube_name: str,\n    view_name: str,\n    private: bool = False,\n    cell_properties: Iterable[str] = None,\n    top: int = None,\n    skip_contexts: bool = False,\n    skip: int = None,\n    skip_zeros: bool = False,\n    skip_consolidated_cells: bool = False,\n    skip_rule_derived_cells: bool = False,\n    sandbox_name: str = None,\n    element_unique_names: bool = True,\n    skip_cell_properties: bool = False,\n    max_workers: int = 8,\n    async_axis: int = 0,\n    **kwargs,\n) -&gt; CaseAndSpaceInsensitiveTuplesDict:\n    \"\"\"get view content as dictionary with sweet and concise structure.\n        Works on NativeView and MDXView !\n\n    :param cube_name: String, name of the cube\n    :param view_name: String, name of the view\n    :param private: True (private) or False (public)\n    :param cell_properties: List, cell properties: [Values, Status, HasPicklist, etc.]\n    :param top: Int, number of cells to return (counting from top)\n    :param skip: Int, number of cells to skip (counting from top)\n    :param skip_contexts: skip elements from titles / contexts in response\n    :param skip_zeros: skip zeros in cellset (irrespective of zero suppression in MDX / view)\n    :param skip_consolidated_cells: skip consolidated cells in cellset\n    :param skip_rule_derived_cells: skip rule derived cells in cellset\n    :param element_unique_names: '[d1].[h1].[e1]' or 'e1'\n    :param sandbox_name: str\n    :param skip_cell_properties: cell values in result dictionary, instead of cell_properties dictionary\n    :param max_workers: Int, number of threads to use in parallel\n    :param async_axis: 0 (columns) or 1 (rows). On which axis to parallelize retrieval\n    :return: Dictionary : `{([dim1].[elem1], [dim2][elem6]): {'Value':3127.312, 'Ordinal':12}   ....  }`\n    \"\"\"\n    cellset_id = self.create_cellset_from_view(\n        cube_name=cube_name, view_name=view_name, private=private, sandbox_name=sandbox_name, **kwargs\n    )\n    return self.extract_cellset_async(\n        cellset_id=cellset_id,\n        cell_properties=cell_properties,\n        top=top,\n        skip=skip,\n        skip_contexts=skip_contexts,\n        skip_zeros=skip_zeros,\n        skip_consolidated_cells=skip_consolidated_cells,\n        skip_rule_derived_cells=skip_rule_derived_cells,\n        delete_cellset=True,\n        sandbox_name=sandbox_name,\n        element_unique_names=element_unique_names,\n        skip_cell_properties=skip_cell_properties,\n        max_workers=max_workers,\n        async_axis=async_axis,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.execute_view_cellcount","title":"<code>execute_view_cellcount(cube_name, view_name, private=False, sandbox_name=None, **kwargs)</code>","text":"<p>Execute cube view in order to understand how many cells are in a cellset. Only return number of cells in the cellset. FAST!</p> <p>Parameters:</p> Name Type Description Default <code>cube_name</code> <code>str</code> <p>String, name of the cube</p> required <code>view_name</code> <code>str</code> <p>String, name of the view</p> required <code>private</code> <code>bool</code> <p>True (private) or False (public)</p> <code>False</code> <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def execute_view_cellcount(\n    self, cube_name: str, view_name: str, private: bool = False, sandbox_name: str = None, **kwargs\n) -&gt; int:\n    \"\"\"Execute cube view in order to understand how many cells are in a cellset.\n    Only return number of cells in the cellset. FAST!\n\n    :param cube_name: String, name of the cube\n    :param view_name: String, name of the view\n    :param private: True (private) or False (public)\n    :param sandbox_name: str\n    :return:\n    \"\"\"\n    cellset_id = self.create_cellset_from_view(\n        cube_name=cube_name, view_name=view_name, private=private, sandbox_name=sandbox_name, **kwargs\n    )\n    return self.extract_cellset_cellcount(cellset_id, delete_cellset=True, sandbox_name=sandbox_name, **kwargs)\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.execute_view_csv","title":"<code>execute_view_csv(cube_name, view_name, private=False, top=None, skip=None, skip_zeros=True, skip_consolidated_cells=False, skip_rule_derived_cells=False, csv_dialect=None, line_separator='\\r\\n', value_separator=',', sandbox_name=None, use_iterative_json=False, use_compact_json=False, use_blob=False, arranged_axes=None, mdx_headers=False, **kwargs)</code>","text":"<p>Optimized for performance. Get csv string of coordinates and values.</p> <p>Parameters:</p> Name Type Description Default <code>cube_name</code> <code>str</code> <p>String, name of the cube</p> required <code>view_name</code> <code>str</code> <p>String, name of the view</p> required <code>private</code> <code>bool</code> <p>True (private) or False (public)</p> <code>False</code> <code>top</code> <code>int</code> <p>Int, number of cells to return (counting from top)</p> <code>None</code> <code>skip</code> <code>int</code> <p>Int, number of cells to skip (counting from top)</p> <code>None</code> <code>skip_zeros</code> <code>bool</code> <p>skip zeros in cellset (irrespective of zero suppression in MDX / view)</p> <code>True</code> <code>skip_consolidated_cells</code> <code>bool</code> <p>skip consolidated cells in cellset</p> <code>False</code> <code>skip_rule_derived_cells</code> <code>bool</code> <p>skip rule derived cells in cellset</p> <code>False</code> <code>csv_dialect</code> <code>Dialect</code> <p>provide all csv output settings through standard library csv.Dialect If not provided dialect is created based on line_separator and value_separator arguments.</p> <code>None</code> <code>line_separator</code> <code>str</code> <code>'\\r\\n'</code> <code>value_separator</code> <code>str</code> <code>','</code> <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <code>use_iterative_json</code> <code>bool</code> <p>use iterative json parsing to reduce memory consumption significantly. Comes at a cost of 3-5% performance.</p> <code>False</code> <code>use_compact_json</code> <code>bool</code> <p>bool</p> <code>False</code> <code>use_blob</code> <code>bool</code> <p>Has 40% better performance and lower memory footprint in any case. Requires admin permissions.</p> <code>False</code> <code>arranged_axes</code> <code>Tuple[List, List, List]</code> <p>Tuple of dimension names on all axes as 3 lists: Titles, Rows, Columns. Allows function to skip retrieval of cellset composition. E.g.: arranged_axes=([\"Year\"], [\"Region\",\"Product\"], [\"Period\", \"Version\"])</p> <code>None</code> <code>mdx_headers</code> <code>bool</code> <p>boolean, fully qualified hierarchy name as header instead of simple dimension name</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>dict, String</p> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def execute_view_csv(\n    self,\n    cube_name: str,\n    view_name: str,\n    private: bool = False,\n    top: int = None,\n    skip: int = None,\n    skip_zeros: bool = True,\n    skip_consolidated_cells: bool = False,\n    skip_rule_derived_cells: bool = False,\n    csv_dialect: \"csv.Dialect\" = None,\n    line_separator: str = \"\\r\\n\",\n    value_separator: str = \",\",\n    sandbox_name: str = None,\n    use_iterative_json: bool = False,\n    use_compact_json: bool = False,\n    use_blob: bool = False,\n    arranged_axes: Tuple[List, List, List] = None,\n    mdx_headers: bool = False,\n    **kwargs,\n) -&gt; str:\n    \"\"\"Optimized for performance. Get csv string of coordinates and values.\n\n    :param cube_name: String, name of the cube\n    :param view_name: String, name of the view\n    :param private: True (private) or False (public)\n    :param top: Int, number of cells to return (counting from top)\n    :param skip: Int, number of cells to skip (counting from top)\n    :param skip_zeros: skip zeros in cellset (irrespective of zero suppression in MDX / view)\n    :param skip_consolidated_cells: skip consolidated cells in cellset\n    :param skip_rule_derived_cells: skip rule derived cells in cellset\n    :param csv_dialect: provide all csv output settings through standard library csv.Dialect\n        If not provided dialect is created based on line_separator and value_separator arguments.\n    :param line_separator:\n    :param value_separator:\n    :param sandbox_name: str\n    :param use_iterative_json: use iterative json parsing to reduce memory consumption significantly.\n    Comes at a cost of 3-5% performance.\n    :param use_compact_json: bool\n    :param use_blob: Has 40% better performance and lower memory footprint in any case. Requires admin permissions.\n    :param arranged_axes: Tuple of dimension names on all axes as 3 lists: Titles, Rows, Columns.\n     Allows function to skip retrieval of cellset composition.\n     E.g.: arranged_axes=([\"Year\"], [\"Region\",\"Product\"], [\"Period\", \"Version\"])\n    :param mdx_headers: boolean, fully qualified hierarchy name as header instead of simple dimension name\n    :return: dict, String\n    \"\"\"\n    if use_blob:\n        if use_iterative_json:\n            raise ValueError(\"'use_iterative_json' must not be used in conjunction with 'use_blob'\")\n        if use_compact_json:\n            raise ValueError(\"'use_compact_json' must not be used in conjunction with 'use_blob'\")\n        if csv_dialect:\n            raise ValueError(\"'csv_dialect' must not be used in conjunction with 'use_blob'\")\n        if line_separator != \"\\r\\n\":\n            raise ValueError(\"'line_separator' must be '\\r\\n' to leverage 'use_blob' feature\")\n        if private:\n            raise ValueError(\"'private' must be False to leverage 'use_blob' feature\")\n\n        return self._execute_view_csv_use_blob(\n            cube_name=cube_name,\n            view_name=view_name,\n            top=top,\n            skip=skip,\n            skip_zeros=skip_zeros,\n            skip_consolidated_cells=skip_consolidated_cells,\n            skip_rule_derived_cells=skip_rule_derived_cells,\n            value_separator=value_separator,\n            sandbox_name=sandbox_name,\n            arranged_axes=arranged_axes,\n            mdx_headers=mdx_headers,\n            **kwargs,\n        )\n\n    cellset_id = self.create_cellset_from_view(\n        cube_name=cube_name, view_name=view_name, private=private, sandbox_name=sandbox_name\n    )\n    if use_iterative_json:\n        return self.extract_cellset_csv_iter_json(\n            cellset_id=cellset_id,\n            skip_zeros=skip_zeros,\n            top=top,\n            skip=skip,\n            skip_consolidated_cells=skip_consolidated_cells,\n            skip_rule_derived_cells=skip_rule_derived_cells,\n            csv_dialect=csv_dialect,\n            line_separator=line_separator,\n            value_separator=value_separator,\n            sandbox_name=sandbox_name,\n            mdx_headers=mdx_headers,\n            **kwargs,\n        )\n\n    return self.extract_cellset_csv(\n        cellset_id=cellset_id,\n        skip_zeros=skip_zeros,\n        top=top,\n        skip=skip,\n        skip_consolidated_cells=skip_consolidated_cells,\n        skip_rule_derived_cells=skip_rule_derived_cells,\n        csv_dialect=csv_dialect,\n        line_separator=line_separator,\n        value_separator=value_separator,\n        sandbox_name=sandbox_name,\n        use_compact_json=use_compact_json,\n        mdx_headers=mdx_headers,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.execute_view_dataframe","title":"<code>execute_view_dataframe(cube_name, view_name, private=False, top=None, skip=None, skip_zeros=True, skip_consolidated_cells=False, skip_rule_derived_cells=False, sandbox_name=None, use_iterative_json=False, use_blob=False, shaped=False, arranged_axes=None, mdx_headers=False, **kwargs)</code>","text":"<p>Optimized for performance. Get Pandas DataFrame from an existing Cube View Context dimensions are omitted in the resulting Dataframe ! Cells with Zero/null are omitted !</p> <p>If 'use_blob' and 'shaped' are True, 'skip_zeros' will be overruled to False. This is necessary to assure column order is in line with cube view in TM1</p> <p>Takes all arguments from the pandas.read_csv method: https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html</p> <p>Parameters:</p> Name Type Description Default <code>cube_name</code> <code>str</code> <p>String, name of the cube</p> required <code>view_name</code> <code>str</code> <p>String, name of the view</p> required <code>private</code> <code>bool</code> <p>True (private) or False (public)</p> <code>False</code> <code>top</code> <code>int</code> <p>Int, number of cells to return (counting from top)</p> <code>None</code> <code>skip</code> <code>int</code> <p>Int, number of cells to skip (counting from top)</p> <code>None</code> <code>skip_zeros</code> <code>bool</code> <p>skip zeros in cellset (irrespective of zero suppression in MDX / view)</p> <code>True</code> <code>skip_consolidated_cells</code> <code>bool</code> <p>skip consolidated cells in cellset</p> <code>False</code> <code>skip_rule_derived_cells</code> <code>bool</code> <p>skip rule derived cells in cellset</p> <code>False</code> <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <code>use_iterative_json</code> <code>bool</code> <p>use iterative json parsing to reduce memory consumption significantly. Comes at a cost of 3-5% performance.</p> <code>False</code> <code>use_blob</code> <code>bool</code> <p>Has 40% better performance and lower memory footprint in any case. Requires admin permissions.</p> <code>False</code> <code>shaped</code> <code>bool</code> <p>Shape rows and columns of data frame as specified in cube view / MDX</p> <code>False</code> <code>arranged_axes</code> <code>Tuple[List, List, List]</code> <p>Tuple of dimension names on all axes as 3 lists: Titles, Rows, Columns. Allows function to skip retrieval of cellset composition in use_blob mode. E.g.: axes=([\"Year\"], [\"Region\",\"Product\"], [\"Period\", \"Version\"]) :param mdx_headers: boolean, fully qualified hierarchy name as header instead of simple dimension name</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Pandas Dataframe</p> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>@require_pandas\ndef execute_view_dataframe(\n    self,\n    cube_name: str,\n    view_name: str,\n    private: bool = False,\n    top: int = None,\n    skip: int = None,\n    skip_zeros: bool = True,\n    skip_consolidated_cells: bool = False,\n    skip_rule_derived_cells: bool = False,\n    sandbox_name: str = None,\n    use_iterative_json: bool = False,\n    use_blob: bool = False,\n    shaped: bool = False,\n    arranged_axes: Tuple[List, List, List] = None,\n    mdx_headers: bool = False,\n    **kwargs,\n) -&gt; \"pd.DataFrame\":\n    \"\"\"Optimized for performance. Get Pandas DataFrame from an existing Cube View\n    Context dimensions are omitted in the resulting Dataframe !\n    Cells with Zero/null are omitted !\n\n    If 'use_blob' and 'shaped' are True, 'skip_zeros' will be overruled to False.\n    This is necessary to assure column order is in line with cube view in TM1\n\n    Takes all arguments from the pandas.read_csv method:\n    https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html\n\n    :param cube_name: String, name of the cube\n    :param view_name: String, name of the view\n    :param private: True (private) or False (public)\n    :param top: Int, number of cells to return (counting from top)\n    :param skip: Int, number of cells to skip (counting from top)\n    :param skip_zeros: skip zeros in cellset (irrespective of zero suppression in MDX / view)\n    :param skip_consolidated_cells: skip consolidated cells in cellset\n    :param skip_rule_derived_cells: skip rule derived cells in cellset\n    :param sandbox_name: str\n    :param use_iterative_json: use iterative json parsing to reduce memory consumption significantly.\n    Comes at a cost of 3-5% performance.\n    :param use_blob: Has 40% better performance and lower memory footprint in any case. Requires admin permissions.\n    :param shaped: Shape rows and columns of data frame as specified in cube view / MDX\n    :param arranged_axes: Tuple of dimension names on all axes as 3 lists: Titles, Rows, Columns.\n     Allows function to skip retrieval of cellset composition in use_blob mode.\n     E.g.: axes=([\"Year\"], [\"Region\",\"Product\"], [\"Period\", \"Version\"])\n     :param mdx_headers: boolean, fully qualified hierarchy name as header instead of simple dimension name\n    :return: Pandas Dataframe\n    \"\"\"\n    # necessary to assure column order in line with cube view\n    if shaped:\n        skip_zeros = False\n\n    if use_blob:\n        raw_csv = self.execute_view_csv(\n            cube_name=cube_name,\n            view_name=view_name,\n            top=top,\n            skip=skip,\n            skip_zeros=skip_zeros,\n            skip_consolidated_cells=skip_consolidated_cells,\n            skip_rule_derived_cells=skip_rule_derived_cells,\n            sandbox_name=sandbox_name,\n            use_iterative_json=use_iterative_json,\n            line_separator=\"\\r\\n\",\n            value_separator=\"~\",\n            use_blob=True,\n            arranged_axes=arranged_axes,\n            mdx_headers=mdx_headers,\n            **kwargs,\n        )\n        return build_dataframe_from_csv(raw_csv, sep=\"~\", shaped=shaped, **kwargs)\n\n    cellset_id = self.create_cellset_from_view(\n        cube_name=cube_name, view_name=view_name, private=private, sandbox_name=sandbox_name, **kwargs\n    )\n    return self.extract_cellset_dataframe(\n        cellset_id,\n        top=top,\n        skip=skip,\n        skip_zeros=skip_zeros,\n        skip_consolidated_cells=skip_consolidated_cells,\n        skip_rule_derived_cells=skip_rule_derived_cells,\n        sandbox_name=sandbox_name,\n        use_iterative_json=use_iterative_json,\n        shaped=shaped,\n        mdx_headers=mdx_headers,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.execute_view_dataframe_pivot","title":"<code>execute_view_dataframe_pivot(cube_name, view_name, private=False, dropna=False, fill_value=None, sandbox_name=None, **kwargs)</code>","text":"<p>Execute a cube view to get a pandas pivot dataframe, in the shape of the cube view</p> <p>Parameters:</p> Name Type Description Default <code>cube_name</code> <code>str</code> <p>String, name of the cube</p> required <code>view_name</code> <code>str</code> <p>String, name of the view</p> required <code>private</code> <code>bool</code> <p>True (private) or False (public)</p> <code>False</code> <code>dropna</code> <code>bool</code> <code>False</code> <code>fill_value</code> <code>bool</code> <code>None</code> <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>@require_pandas\ndef execute_view_dataframe_pivot(\n    self,\n    cube_name: str,\n    view_name: str,\n    private: bool = False,\n    dropna: bool = False,\n    fill_value: bool = None,\n    sandbox_name: str = None,\n    **kwargs,\n) -&gt; \"pd.DataFrame\":\n    \"\"\"Execute a cube view to get a pandas pivot dataframe, in the shape of the cube view\n\n    :param cube_name: String, name of the cube\n    :param view_name: String, name of the view\n    :param private: True (private) or False (public)\n    :param dropna:\n    :param fill_value:\n    :param sandbox_name: str\n    :return:\n    \"\"\"\n    cellset_id = self.create_cellset_from_view(\n        cube_name=cube_name, view_name=view_name, private=private, sandbox_name=sandbox_name, **kwargs\n    )\n    return self.extract_cellset_dataframe_pivot(\n        cellset_id=cellset_id, dropna=dropna, fill_value=fill_value, sandbox_name=sandbox_name, **kwargs\n    )\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.execute_view_dataframe_shaped","title":"<code>execute_view_dataframe_shaped(cube_name, view_name, private=False, sandbox_name=None, use_iterative_json=False, use_blob=False, mdx_headers=False, **kwargs)</code>","text":"<p>Retrieves data from cube in the shape of the query. Dimensions on rows can be stacked. One dimension must be placed on columns. Title selections are ignored.</p> <p>Parameters:</p> Name Type Description Default <code>cube_name</code> <code>str</code> required <code>view_name</code> <code>str</code> required <code>private</code> <code>bool</code> <code>False</code> <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <code>use_blob</code> <code>bool</code> <code>False</code> <code>use_iterative_json</code> <code>bool</code> <code>False</code> <code>kwargs</code> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>@require_pandas\ndef execute_view_dataframe_shaped(\n    self,\n    cube_name: str,\n    view_name: str,\n    private: bool = False,\n    sandbox_name: str = None,\n    use_iterative_json: bool = False,\n    use_blob: bool = False,\n    mdx_headers: bool = False,\n    **kwargs,\n) -&gt; \"pd.DataFrame\":\n    \"\"\"Retrieves data from cube in the shape of the query.\n    Dimensions on rows can be stacked. One dimension must be placed on columns. Title selections are ignored.\n\n    :param cube_name:\n    :param view_name:\n    :param private:\n    :param sandbox_name: str\n    :param use_blob:\n    :param use_iterative_json:\n    :param kwargs:\n    :return:\n    \"\"\"\n\n    # default approach\n    if not any([use_blob, use_iterative_json]):\n        cellset_id = self.create_cellset_from_view(\n            cube_name=cube_name, view_name=view_name, private=private, sandbox_name=sandbox_name\n        )\n        return self.extract_cellset_dataframe_shaped(\n            cellset_id=cellset_id, delete_cellset=True, sandbox_name=sandbox_name, mdx_headers=mdx_headers, **kwargs\n        )\n\n    if all([use_blob, use_iterative_json]):\n        raise ValueError(\"'use_blob' and 'use_iterative_json' must not be used together\")\n\n    # ijson approach\n    if use_iterative_json:\n        return self.execute_view_dataframe(\n            cube_name=cube_name,\n            view_name=view_name,\n            private=private,\n            shaped=True,\n            sandbox_name=sandbox_name,\n            use_iterative_json=use_iterative_json,\n            mdx_headers=mdx_headers,\n            use_blob=False,\n            **kwargs,\n        )\n\n    # blob approach\n    if private:\n        raise ValueError(\"view must be public when 'use_blob' argument is True\")\n\n    return self.execute_view_dataframe(\n        cube_name=cube_name,\n        view_name=view_name,\n        private=private,\n        shaped=True,\n        sandbox_name=sandbox_name,\n        mdx_headers=mdx_headers,\n        use_blob=True,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.execute_view_elements_value_dict","title":"<code>execute_view_elements_value_dict(cube_name, view_name, private=False, top=None, skip=None, skip_zeros=True, skip_consolidated_cells=False, skip_rule_derived_cells=False, element_separator='|', sandbox_name=None, **kwargs)</code>","text":"<p>Optimized for performance. Get a Dict(tuple, value) from an existing Cube View Context dimensions are omitted in the resulting Dataframe ! Cells with Zero/null are omitted by default, but still configurable!</p> <p>Parameters:</p> Name Type Description Default <code>cube_name</code> <code>str</code> <p>String, name of the cube</p> required <code>view_name</code> <code>str</code> <p>String, name of the view</p> required <code>private</code> <code>bool</code> <p>True (private) or False (public)</p> <code>False</code> <code>top</code> <code>int</code> <p>Int, number of cells to return (counting from top)</p> <code>None</code> <code>skip</code> <code>int</code> <p>Int, number of cells to skip (counting from top)</p> <code>None</code> <code>skip_zeros</code> <code>bool</code> <p>skip zeros in cellset (irrespective of zero suppression in MDX / view)</p> <code>True</code> <code>skip_consolidated_cells</code> <code>bool</code> <p>skip consolidated cells in cellset</p> <code>False</code> <code>skip_rule_derived_cells</code> <code>bool</code> <p>skip rule derived cells in cellset</p> <code>False</code> <code>element_separator</code> <code>str</code> <p>separator for the dimension element combination</p> <code>'|'</code> <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <p>Returns:</p> Type Description <code>CaseAndSpaceInsensitiveDict</code> <p>CaseAndSpaceInsensitiveDict {'2020|Jan|Sales': 2000, '2020|Feb|Sales': 3000}</p> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def execute_view_elements_value_dict(\n    self,\n    cube_name: str,\n    view_name: str,\n    private: bool = False,\n    top: int = None,\n    skip: int = None,\n    skip_zeros: bool = True,\n    skip_consolidated_cells: bool = False,\n    skip_rule_derived_cells: bool = False,\n    element_separator: str = \"|\",\n    sandbox_name: str = None,\n    **kwargs,\n) -&gt; CaseAndSpaceInsensitiveDict:\n    \"\"\"Optimized for performance. Get a Dict(tuple, value) from an existing Cube View\n    Context dimensions are omitted in the resulting Dataframe !\n    Cells with Zero/null are omitted by default, but still configurable!\n\n    :param cube_name: String, name of the cube\n    :param view_name: String, name of the view\n    :param private: True (private) or False (public)\n    :param top: Int, number of cells to return (counting from top)\n    :param skip: Int, number of cells to skip (counting from top)\n    :param skip_zeros: skip zeros in cellset (irrespective of zero suppression in MDX / view)\n    :param skip_consolidated_cells: skip consolidated cells in cellset\n    :param skip_rule_derived_cells: skip rule derived cells in cellset\n    :param element_separator: separator for the dimension element combination\n    :param sandbox_name: str\n    :return: CaseAndSpaceInsensitiveDict {'2020|Jan|Sales': 2000, '2020|Feb|Sales': 3000}\n    \"\"\"\n    lines = self.execute_view_csv(\n        cube_name=cube_name,\n        view_name=view_name,\n        private=private,\n        top=top,\n        skip=skip,\n        skip_zeros=skip_zeros,\n        skip_consolidated_cells=skip_consolidated_cells,\n        skip_rule_derived_cells=skip_rule_derived_cells,\n        value_separator=element_separator,\n        sandbox_name=sandbox_name,\n        **kwargs,\n    )\n    elements_value_dict = CaseAndSpaceInsensitiveDict()\n    for entries in lines.split(\"\\r\\n\")[1:]:\n        elements_value_dict[element_separator.join(entries.split(element_separator)[:-1])] = entries.split(\n            element_separator\n        )[-1]\n    return elements_value_dict\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.execute_view_raw","title":"<code>execute_view_raw(cube_name, view_name, private=False, cell_properties=None, elem_properties=None, member_properties=None, top=None, skip_contexts=False, skip=None, skip_zeros=False, skip_consolidated_cells=False, skip_rule_derived_cells=False, sandbox_name=None, use_compact_json=False, **kwargs)</code>","text":"<p>Execute a cube view and return the raw data from TM1</p> <p>Parameters:</p> Name Type Description Default <code>cube_name</code> <code>str</code> <p>String, name of the cube</p> required <code>view_name</code> <code>str</code> <p>String, name of the view</p> required <code>private</code> <code>bool</code> <p>True (private) or False (public)</p> <code>False</code> <code>cell_properties</code> <code>Iterable[str]</code> <p>List of properties to be queried from the cell. E.g. ['Value', 'RuleDerived', ...]</p> <code>None</code> <code>elem_properties</code> <code>Iterable[str]</code> <p>List of properties to be queried from the elements. E.g. ['Name','Attributes', ...]</p> <code>None</code> <code>member_properties</code> <code>Iterable[str]</code> <p>List of properties to be queried from the members. E.g. ['Name','Attributes', ...]</p> <code>None</code> <code>top</code> <code>int</code> <p>Integer limiting the number of cells and the number or rows returned</p> <code>None</code> <code>skip_contexts</code> <code>bool</code> <p>skip elements from titles / contexts in response</p> <code>False</code> <code>skip</code> <code>int</code> <p>Integer limiting the number of cells and the number or rows returned</p> <code>None</code> <code>skip_zeros</code> <code>bool</code> <p>skip zeros in cellset (irrespective of zero suppression in MDX / view)</p> <code>False</code> <code>skip_consolidated_cells</code> <code>bool</code> <p>skip consolidated cells in cellset</p> <code>False</code> <code>skip_rule_derived_cells</code> <code>bool</code> <p>skip rule derived cells in cellset</p> <code>False</code> <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <code>use_compact_json</code> <code>bool</code> <p>bool</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict</code> <p>Raw format from TM1.</p> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def execute_view_raw(\n    self,\n    cube_name: str,\n    view_name: str,\n    private: bool = False,\n    cell_properties: Iterable[str] = None,\n    elem_properties: Iterable[str] = None,\n    member_properties: Iterable[str] = None,\n    top: int = None,\n    skip_contexts: bool = False,\n    skip: int = None,\n    skip_zeros: bool = False,\n    skip_consolidated_cells: bool = False,\n    skip_rule_derived_cells: bool = False,\n    sandbox_name: str = None,\n    use_compact_json: bool = False,\n    **kwargs,\n) -&gt; Dict:\n    \"\"\"Execute a cube view and return the raw data from TM1\n\n\n    :param cube_name: String, name of the cube\n    :param view_name: String, name of the view\n    :param private: True (private) or False (public)\n    :param cell_properties: List of properties to be queried from the cell. E.g. ['Value', 'RuleDerived', ...]\n    :param elem_properties: List of properties to be queried from the elements. E.g. ['Name','Attributes', ...]\n    :param member_properties: List of properties to be queried from the members. E.g. ['Name','Attributes', ...]\n    :param top: Integer limiting the number of cells and the number or rows returned\n    :param skip_contexts: skip elements from titles / contexts in response\n    :param skip: Integer limiting the number of cells and the number or rows returned\n    :param skip_zeros: skip zeros in cellset (irrespective of zero suppression in MDX / view)\n    :param skip_consolidated_cells: skip consolidated cells in cellset\n    :param skip_rule_derived_cells: skip rule derived cells in cellset\n    :param sandbox_name: str\n    :param use_compact_json: bool\n    :return: Raw format from TM1.\n    \"\"\"\n    cellset_id = self.create_cellset_from_view(\n        cube_name=cube_name, view_name=view_name, private=private, sandbox_name=sandbox_name, **kwargs\n    )\n    return self.extract_cellset_raw(\n        cellset_id=cellset_id,\n        cell_properties=cell_properties,\n        elem_properties=elem_properties,\n        member_properties=member_properties,\n        top=top,\n        skip=skip,\n        skip_contexts=skip_contexts,\n        skip_zeros=skip_zeros,\n        skip_rule_derived_cells=skip_rule_derived_cells,\n        skip_consolidated_cells=skip_consolidated_cells,\n        delete_cellset=True,\n        sandbox_name=sandbox_name,\n        use_compact_json=use_compact_json,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.execute_view_rows_and_values","title":"<code>execute_view_rows_and_values(cube_name, view_name, private=False, element_unique_names=True, sandbox_name=None, **kwargs)</code>","text":"<p>Execute cube view and retrieve row element names and values in a case and space insensitive dictionary</p> <p>Parameters:</p> Name Type Description Default <code>cube_name</code> <code>str</code> <p>String, name of the cube</p> required <code>view_name</code> <code>str</code> <p>String, name of the view</p> required <code>private</code> <code>bool</code> <p>True (private) or False (public)</p> <code>False</code> <code>element_unique_names</code> <code>bool</code> <code>True</code> <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <code>kwargs</code> <code>{}</code> <p>Returns:</p> Type Description <code>CaseAndSpaceInsensitiveTuplesDict</code> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def execute_view_rows_and_values(\n    self,\n    cube_name: str,\n    view_name: str,\n    private: bool = False,\n    element_unique_names: bool = True,\n    sandbox_name: str = None,\n    **kwargs,\n) -&gt; CaseAndSpaceInsensitiveTuplesDict:\n    \"\"\"Execute cube view and retrieve row element names and values in a case and space insensitive dictionary\n\n    :param cube_name: String, name of the cube\n    :param view_name: String, name of the view\n    :param private: True (private) or False (public)\n    :param element_unique_names:\n    :param sandbox_name: str\n    :param kwargs:\n    :return:\n    \"\"\"\n    cellset_id = self.create_cellset_from_view(\n        cube_name=cube_name, view_name=view_name, private=private, sandbox_name=sandbox_name, **kwargs\n    )\n    return self.extract_cellset_rows_and_values(\n        cellset_id, element_unique_names, delete_cellset=True, sandbox_name=sandbox_name, **kwargs\n    )\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.execute_view_rows_and_values_string_set","title":"<code>execute_view_rows_and_values_string_set(cube_name, view_name, private=False, exclude_empty_cells=True, sandbox_name=None, **kwargs)</code>","text":"<p>Retrieve row element names and string cell values in a case and space insensitive set</p> <p>Parameters:</p> Name Type Description Default <code>cube_name</code> <code>str</code> <p>String, name of the cube</p> required <code>view_name</code> <code>str</code> <p>String, name of the view</p> required <code>private</code> <code>bool</code> <p>True (private) or False (public)</p> <code>False</code> <code>exclude_empty_cells</code> <code>bool</code> <code>True</code> <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <p>Returns:</p> Type Description <code>CaseAndSpaceInsensitiveSet</code> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def execute_view_rows_and_values_string_set(\n    self,\n    cube_name: str,\n    view_name: str,\n    private: bool = False,\n    exclude_empty_cells: bool = True,\n    sandbox_name: str = None,\n    **kwargs,\n) -&gt; CaseAndSpaceInsensitiveSet:\n    \"\"\"Retrieve row element names and **string** cell values in a case and space insensitive set\n\n    :param cube_name: String, name of the cube\n    :param view_name: String, name of the view\n    :param private: True (private) or False (public)\n    :param exclude_empty_cells:\n    :param sandbox_name: str\n    :return:\n    \"\"\"\n    rows_and_values = self.execute_view_rows_and_values(\n        cube_name, view_name, private, False, sandbox_name=sandbox_name, **kwargs\n    )\n    return self._extract_string_set_from_rows_and_values(rows_and_values, exclude_empty_cells)\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.execute_view_ui_array","title":"<code>execute_view_ui_array(cube_name, view_name, private=False, elem_properties=None, member_properties=None, value_precision=2, top=None, skip=None, sandbox_name=None, use_compact_json=False, **kwargs)</code>","text":"<p>Useful for grids or charting libraries that want an array of cell values per row. Returns 3-dimensional cell structure for tabbed grids or multiple charts. Rows and pages are dicts, addressable by their name. Proper order of rows can be obtained in headers[1] Example 'cells' return format: <pre><code>'cells': {\n    '10100': {\n        'Net Operating Income': [ 19832724.72429739,\n                                    20365654.788303416,\n                                    20729201.329183243,\n                                    20480205.20121749],\n        'Revenue': [ 28981046.50724231,\n                        29512482.207418434,\n                        29913730.038971487,\n                        29563345.9542385]},\n    '10200': {\n        'Net Operating Income': [ 9853293.623709997,\n                                    10277650.763958748,\n                                    10466934.096533755,\n                                    10333095.839474997],\n        'Revenue': [ 13888143.710000003,\n                        14300216.43,\n                        14502421.63,\n                        14321501.940000001]}\n},\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>top</code> <code>int</code> <p>Int, number of cells to return (counting from top)</p> <code>None</code> <code>skip</code> <code>int</code> <p>Int, number of cells to skip (counting from top)</p> <code>None</code> <code>cube_name</code> <code>str</code> <p>String, name of the cube</p> required <code>view_name</code> <code>str</code> <p>String, name of the view</p> required <code>private</code> <code>bool</code> <p>True (private) or False (public)</p> <code>False</code> <code>elem_properties</code> <code>Iterable[str]</code> <p>List of properties to be queried from the elements. E.g. ['UniqueName','Attributes']</p> <code>None</code> <code>member_properties</code> <code>Iterable[str]</code> <p>List properties to be queried from the member. E.g. ['Name', 'UniqueName']</p> <code>None</code> <code>value_precision</code> <code>int</code> <p>Integer (optional) specifying number of decimal places to return</p> <code>2</code> <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <code>use_compact_json</code> <code>bool</code> <p>bool</p> <code>False</code> <p>Returns:</p> Type Description <p>dict :<code>{ titles: [], headers: [axis][], cells:{ Page0:{ Row0: {[row values], Row1: [], ...}, ...}, ...}}</code></p> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def execute_view_ui_array(\n    self,\n    cube_name: str,\n    view_name: str,\n    private: bool = False,\n    elem_properties: Iterable[str] = None,\n    member_properties: Iterable[str] = None,\n    value_precision: int = 2,\n    top: int = None,\n    skip: int = None,\n    sandbox_name: str = None,\n    use_compact_json: bool = False,\n    **kwargs,\n):\n    \"\"\"\n    Useful for grids or charting libraries that want an array of cell values per row.\n    Returns 3-dimensional cell structure for tabbed grids or multiple charts.\n    Rows and pages are dicts, addressable by their name. Proper order of rows can be obtained in headers[1]\n    Example 'cells' return format:\n    ```\n    'cells': {\n        '10100': {\n            'Net Operating Income': [ 19832724.72429739,\n                                        20365654.788303416,\n                                        20729201.329183243,\n                                        20480205.20121749],\n            'Revenue': [ 28981046.50724231,\n                            29512482.207418434,\n                            29913730.038971487,\n                            29563345.9542385]},\n        '10200': {\n            'Net Operating Income': [ 9853293.623709997,\n                                        10277650.763958748,\n                                        10466934.096533755,\n                                        10333095.839474997],\n            'Revenue': [ 13888143.710000003,\n                            14300216.43,\n                            14502421.63,\n                            14321501.940000001]}\n    },\n    ```\n    :param top: Int, number of cells to return (counting from top)\n    :param skip: Int, number of cells to skip (counting from top)\n    :param cube_name: String, name of the cube\n    :param view_name: String, name of the view\n    :param private: True (private) or False (public)\n    :param elem_properties: List of properties to be queried from the elements. E.g. ['UniqueName','Attributes']\n    :param member_properties: List properties to be queried from the member. E.g. ['Name', 'UniqueName']\n    :param value_precision: Integer (optional) specifying number of decimal places to return\n    :param sandbox_name: str\n    :param use_compact_json: bool\n    :return: dict :`{ titles: [], headers: [axis][], cells:{ Page0:{ Row0: {[row values], Row1: [], ...}, ...}, ...}}`\n    \"\"\"\n    cellset_id = self.create_cellset_from_view(\n        cube_name=cube_name, view_name=view_name, private=private, sandbox_name=sandbox_name, **kwargs\n    )\n    data = self.extract_cellset_raw(\n        cellset_id=cellset_id,\n        cell_properties=[\"Value\"],\n        elem_properties=elem_properties,\n        member_properties=list(set(member_properties or []) | {\"Name\"}),\n        top=top,\n        skip=skip,\n        delete_cellset=True,\n        sandbox_name=sandbox_name,\n        use_compact_json=use_compact_json,\n        **kwargs,\n    )\n    return Utils.build_ui_arrays_from_cellset(raw_cellset_as_dict=data, value_precision=value_precision)\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.execute_view_ui_dygraph","title":"<code>execute_view_ui_dygraph(cube_name, view_name, private=False, elem_properties=None, member_properties=None, value_precision=2, top=None, skip=None, sandbox_name=None, use_compact_json=False, **kwargs)</code>","text":"<p>Useful for grids or charting libraries that want an array of cell values per row. Returns 3-dimensional cell structure for tabbed grids or multiple charts. Rows and pages are dicts, addressable by their name. Proper order of rows can be obtained in headers[1] Example 'cells' return format:     'cells': {         '10100': {             'Net Operating Income': [ 19832724.72429739,                                       20365654.788303416,                                       20729201.329183243,                                       20480205.20121749],             'Revenue': [ 28981046.50724231,                          29512482.207418434,                          29913730.038971487,                          29563345.9542385]},         '10200': {             'Net Operating Income': [ 9853293.623709997,                                        10277650.763958748,                                        10466934.096533755,                                        10333095.839474997],             'Revenue': [ 13888143.710000003,                          14300216.43,                          14502421.63,                          14321501.940000001]}     },</p> <p>Parameters:</p> Name Type Description Default <code>top</code> <code>int</code> <p>Int, number of cells to return (counting from top)</p> <code>None</code> <code>skip</code> <code>int</code> <p>Int, number of cells to skip (counting from top)</p> <code>None</code> <code>cube_name</code> <code>str</code> <p>cube name</p> required <code>view_name</code> <code>str</code> <p>view name</p> required <code>private</code> <code>bool</code> <p>True (private) or False (public)</p> <code>False</code> <code>elem_properties</code> <code>Iterable[str]</code> <p>List of properties to be queried from the elements. E.g. ['UniqueName','Attributes']</p> <code>None</code> <code>member_properties</code> <code>Iterable[str]</code> <p>List of properties to be queried from the members. E.g. ['UniqueName','Attributes']</p> <code>None</code> <code>value_precision</code> <code>int</code> <p>Integer (optional) specifying number of decimal places to return</p> <code>2</code> <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <code>use_compact_json</code> <code>bool</code> <p>bool</p> <code>False</code> <p>Returns:</p> Type Description Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def execute_view_ui_dygraph(\n    self,\n    cube_name: str,\n    view_name: str,\n    private: bool = False,\n    elem_properties: Iterable[str] = None,\n    member_properties: Iterable[str] = None,\n    value_precision: int = 2,\n    top: int = None,\n    skip: int = None,\n    sandbox_name: str = None,\n    use_compact_json: bool = False,\n    **kwargs,\n):\n    \"\"\"\n    Useful for grids or charting libraries that want an array of cell values per row.\n    Returns 3-dimensional cell structure for tabbed grids or multiple charts.\n    Rows and pages are dicts, addressable by their name. Proper order of rows can be obtained in headers[1]\n    Example 'cells' return format:\n        'cells': {\n            '10100': {\n                'Net Operating Income': [ 19832724.72429739,\n                                          20365654.788303416,\n                                          20729201.329183243,\n                                          20480205.20121749],\n                'Revenue': [ 28981046.50724231,\n                             29512482.207418434,\n                             29913730.038971487,\n                             29563345.9542385]},\n            '10200': {\n                'Net Operating Income': [ 9853293.623709997,\n                                           10277650.763958748,\n                                           10466934.096533755,\n                                           10333095.839474997],\n                'Revenue': [ 13888143.710000003,\n                             14300216.43,\n                             14502421.63,\n                             14321501.940000001]}\n        },\n\n    :param top: Int, number of cells to return (counting from top)\n    :param skip: Int, number of cells to skip (counting from top)\n    :param cube_name: cube name\n    :param view_name: view name\n    :param private: True (private) or False (public)\n    :param elem_properties: List of properties to be queried from the elements. E.g. ['UniqueName','Attributes']\n    :param member_properties: List of properties to be queried from the members. E.g. ['UniqueName','Attributes']\n    :param value_precision: Integer (optional) specifying number of decimal places to return\n    :param sandbox_name: str\n    :param use_compact_json: bool\n    :return:\n    \"\"\"\n    cellset_id = self.create_cellset_from_view(\n        cube_name=cube_name, view_name=view_name, private=private, sandbox_name=sandbox_name, **kwargs\n    )\n    data = self.extract_cellset_raw(\n        cellset_id=cellset_id,\n        cell_properties=[\"Value\"],\n        elem_properties=elem_properties,\n        member_properties=list(set(member_properties or []) | {\"Name\"}),\n        top=top,\n        skip=skip,\n        delete_cellset=True,\n        sandbox_name=sandbox_name,\n        use_compact_json=use_compact_json,\n        **kwargs,\n    )\n    return Utils.build_ui_dygraph_arrays_from_cellset(raw_cellset_as_dict=data, value_precision=value_precision)\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.execute_view_values","title":"<code>execute_view_values(cube_name, view_name, private=False, sandbox_name=None, skip_zeros=False, skip_consolidated_cells=False, skip_rule_derived_cells=False, use_compact_json=False, **kwargs)</code>","text":"<p>Execute view and retrieve only the cell values</p> <p>Parameters:</p> Name Type Description Default <code>cube_name</code> <code>str</code> <p>String, name of the cube</p> required <code>view_name</code> <code>str</code> <p>String, name of the view</p> required <code>private</code> <code>bool</code> <p>True (private) or False (public)</p> <code>False</code> <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <code>use_compact_json</code> <code>bool</code> <p>bool</p> <code>False</code> <code>skip_zeros</code> <code>bool</code> <p>bool</p> <code>False</code> <code>skip_consolidated_cells</code> <code>bool</code> <p>bool</p> <code>False</code> <code>skip_rule_derived_cells</code> <code>bool</code> <p>bool</p> <code>False</code> <code>kwargs</code> <code>{}</code> <p>Returns:</p> Type Description <code>List[Union[str, float]]</code> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def execute_view_values(\n    self,\n    cube_name: str,\n    view_name: str,\n    private: bool = False,\n    sandbox_name: str = None,\n    skip_zeros: bool = False,\n    skip_consolidated_cells: bool = False,\n    skip_rule_derived_cells: bool = False,\n    use_compact_json: bool = False,\n    **kwargs,\n) -&gt; List[Union[str, float]]:\n    \"\"\"Execute view and retrieve only the cell values\n\n    :param cube_name: String, name of the cube\n    :param view_name: String, name of the view\n    :param private: True (private) or False (public)\n    :param sandbox_name: str\n    :param use_compact_json: bool\n    :param skip_zeros: bool\n    :param skip_consolidated_cells: bool\n    :param skip_rule_derived_cells: bool\n    :param kwargs:\n    :return:\n    \"\"\"\n    cellset_id = self.create_cellset_from_view(\n        cube_name=cube_name, view_name=view_name, private=private, sandbox_name=sandbox_name, **kwargs\n    )\n    return self.extract_cellset_values(\n        cellset_id,\n        delete_cellset=True,\n        sandbox_name=sandbox_name,\n        use_compact_json=use_compact_json,\n        skip_zeros=skip_zeros,\n        skip_rule_derived_cells=skip_rule_derived_cells,\n        skip_consolidated_cells=skip_consolidated_cells,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.extract_cellset","title":"<code>extract_cellset(cellset_id, cell_properties=None, top=None, skip=None, delete_cellset=True, skip_contexts=False, skip_zeros=False, skip_consolidated_cells=False, skip_rule_derived_cells=False, sandbox_name=None, element_unique_names=True, skip_cell_properties=False, use_compact_json=False, skip_sandbox_dimension=False, **kwargs)</code>","text":"<p>Execute cellset and return the cells with their properties</p> <p>Parameters:</p> Name Type Description Default <code>skip_contexts</code> <code>bool</code> <code>False</code> <code>delete_cellset</code> <code>bool</code> <code>True</code> <code>cellset_id</code> <code>str</code> required <code>cell_properties</code> <code>Iterable[str]</code> <p>properties to be queried from the cell. E.g. Value, Ordinal, RuleDerived, ...</p> <code>None</code> <code>top</code> <code>int</code> <p>Int, number of cells to return (counting from top)</p> <code>None</code> <code>skip</code> <code>int</code> <p>Int, number of cells to skip (counting from top)</p> <code>None</code> <code>skip_zeros</code> <code>bool</code> <p>skip zeros in cellset (irrespective of zero suppression in MDX / view)</p> <code>False</code> <code>skip_consolidated_cells</code> <code>bool</code> <p>skip consolidated cells in cellset</p> <code>False</code> <code>skip_rule_derived_cells</code> <code>bool</code> <p>skip rule derived cells in cellset</p> <code>False</code> <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <code>element_unique_names</code> <code>bool</code> <p>'[d1].[h1].[e1]' or 'e1'</p> <code>True</code> <code>skip_cell_properties</code> <code>bool</code> <p>cell values in result dictionary, instead of cell_properties dictionary</p> <code>False</code> <code>use_compact_json</code> <code>bool</code> <p>bool</p> <code>False</code> <code>skip_sandbox_dimension</code> <code>bool</code> <p>skip sandbox dimension</p> <code>False</code> <p>Returns:</p> Type Description <code>CaseAndSpaceInsensitiveTuplesDict</code> <p>Content in sweet concise structure.</p> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def extract_cellset(\n    self,\n    cellset_id: str,\n    cell_properties: Iterable[str] = None,\n    top: int = None,\n    skip: int = None,\n    delete_cellset: bool = True,\n    skip_contexts: bool = False,\n    skip_zeros: bool = False,\n    skip_consolidated_cells: bool = False,\n    skip_rule_derived_cells: bool = False,\n    sandbox_name: str = None,\n    element_unique_names: bool = True,\n    skip_cell_properties: bool = False,\n    use_compact_json: bool = False,\n    skip_sandbox_dimension: bool = False,\n    **kwargs,\n) -&gt; CaseAndSpaceInsensitiveTuplesDict:\n    \"\"\"Execute cellset and return the cells with their properties\n\n    :param skip_contexts:\n    :param delete_cellset:\n    :param cellset_id:\n    :param cell_properties: properties to be queried from the cell. E.g. Value, Ordinal, RuleDerived, ...\n    :param top: Int, number of cells to return (counting from top)\n    :param skip: Int, number of cells to skip (counting from top)\n    :param skip_zeros: skip zeros in cellset (irrespective of zero suppression in MDX / view)\n    :param skip_consolidated_cells: skip consolidated cells in cellset\n    :param skip_rule_derived_cells: skip rule derived cells in cellset\n    :param sandbox_name: str\n    :param element_unique_names: '[d1].[h1].[e1]' or 'e1'\n    :param skip_cell_properties: cell values in result dictionary, instead of cell_properties dictionary\n    :param use_compact_json: bool\n    :param skip_sandbox_dimension: skip sandbox dimension\n    :return: Content in sweet concise structure.\n    \"\"\"\n    if not cell_properties:\n        cell_properties = [\"Value\"]\n\n    raw_cellset = self.extract_cellset_raw(\n        cellset_id,\n        cell_properties=cell_properties,\n        elem_properties=[\"UniqueName\"],\n        member_properties=[\"UniqueName\"],\n        top=top,\n        skip=skip,\n        skip_contexts=skip_contexts,\n        delete_cellset=delete_cellset,\n        skip_zeros=skip_zeros,\n        skip_consolidated_cells=skip_consolidated_cells,\n        skip_rule_derived_cells=skip_rule_derived_cells,\n        sandbox_name=sandbox_name,\n        include_hierarchies=False,\n        use_compact_json=use_compact_json,\n        **kwargs,\n    )\n\n    return Utils.build_content_from_cellset_dict(\n        raw_cellset_as_dict=raw_cellset,\n        top=top,\n        element_unique_names=element_unique_names,\n        skip_cell_properties=skip_cell_properties,\n        skip_sandbox_dimension=skip_sandbox_dimension,\n    )\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.extract_cellset_async","title":"<code>extract_cellset_async(cellset_id, cell_properties=None, top=None, skip=None, delete_cellset=True, skip_contexts=False, skip_zeros=False, skip_consolidated_cells=False, skip_rule_derived_cells=False, sandbox_name=None, element_unique_names=True, skip_cell_properties=False, skip_sandbox_dimension=False, max_workers=8, async_axis=1, **kwargs)</code>","text":"<p>Execute cellset and return the cells with their properties</p> <p>Parameters:</p> Name Type Description Default <code>skip_contexts</code> <code>bool</code> <code>False</code> <code>delete_cellset</code> <code>bool</code> <code>True</code> <code>cellset_id</code> <code>str</code> required <code>cell_properties</code> <code>Iterable[str]</code> <p>properties to be queried from the cell. E.g. Value, Ordinal, RuleDerived, ...</p> <code>None</code> <code>top</code> <code>int</code> <p>Int, number of cells to return (counting from top)</p> <code>None</code> <code>skip</code> <code>int</code> <p>Int, number of cells to skip (counting from top)</p> <code>None</code> <code>skip_zeros</code> <code>bool</code> <p>skip zeros in cellset (irrespective of zero suppression in MDX / view)</p> <code>False</code> <code>skip_consolidated_cells</code> <code>bool</code> <p>skip consolidated cells in cellset</p> <code>False</code> <code>skip_rule_derived_cells</code> <code>bool</code> <p>skip rule derived cells in cellset</p> <code>False</code> <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <code>element_unique_names</code> <code>bool</code> <p>'[d1].[h1].[e1]' or 'e1'</p> <code>True</code> <code>skip_cell_properties</code> <code>bool</code> <p>cell values in result dictionary, instead of cell_properties dictionary</p> <code>False</code> <code>skip_sandbox_dimension</code> <code>bool</code> <p>skip sandbox dimension</p> <code>False</code> <code>max_workers</code> <code>int</code> <p>Int, number of threads to use in parallel</p> <code>8</code> <code>async_axis</code> <code>int</code> <p>0 (columns) or 1 (rows). On which axis to parallelize retrieval</p> <code>1</code> <p>Returns:</p> Type Description <code>CaseAndSpaceInsensitiveTuplesDict</code> <p>Content in sweet concise structure.</p> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def extract_cellset_async(\n    self,\n    cellset_id: str,\n    cell_properties: Iterable[str] = None,\n    top: int = None,\n    skip: int = None,\n    delete_cellset: bool = True,\n    skip_contexts: bool = False,\n    skip_zeros: bool = False,\n    skip_consolidated_cells: bool = False,\n    skip_rule_derived_cells: bool = False,\n    sandbox_name: str = None,\n    element_unique_names: bool = True,\n    skip_cell_properties: bool = False,\n    skip_sandbox_dimension: bool = False,\n    max_workers: int = 8,\n    async_axis: int = 1,\n    **kwargs,\n) -&gt; CaseAndSpaceInsensitiveTuplesDict:\n    \"\"\"Execute cellset and return the cells with their properties\n\n    :param skip_contexts:\n    :param delete_cellset:\n    :param cellset_id:\n    :param cell_properties: properties to be queried from the cell. E.g. Value, Ordinal, RuleDerived, ...\n    :param top: Int, number of cells to return (counting from top)\n    :param skip: Int, number of cells to skip (counting from top)\n    :param skip_zeros: skip zeros in cellset (irrespective of zero suppression in MDX / view)\n    :param skip_consolidated_cells: skip consolidated cells in cellset\n    :param skip_rule_derived_cells: skip rule derived cells in cellset\n    :param sandbox_name: str\n    :param element_unique_names: '[d1].[h1].[e1]' or 'e1'\n    :param skip_cell_properties: cell values in result dictionary, instead of cell_properties dictionary\n    :param skip_sandbox_dimension: skip sandbox dimension\n    :param max_workers: Int, number of threads to use in parallel\n    :param async_axis: 0 (columns) or 1 (rows). On which axis to parallelize retrieval\n    :return: Content in sweet concise structure.\n    \"\"\"\n    if not cell_properties:\n        cell_properties = [\"Value\"]\n\n    axes = self.extract_cellset_axes_raw_async(\n        cellset_id=cellset_id,\n        async_axis=async_axis,\n        max_workers=max_workers,\n        elem_properties=[\"UniqueName\"],\n        member_properties=[\"UniqueName\"],\n        top=top,\n        skip=skip,\n        skip_contexts=skip_contexts,\n        sandbox_name=sandbox_name,\n        **kwargs,\n    )\n\n    cells = self.extract_cellset_cells_raw_async(\n        cellset_id=cellset_id,\n        max_workers=max_workers,\n        cell_properties=cell_properties,\n        skip_zeros=skip_zeros,\n        skip_consolidated_cells=skip_consolidated_cells,\n        skip_rule_derived_cells=skip_rule_derived_cells,\n        sandbox_name=sandbox_name,\n        **kwargs,\n    )\n\n    # cube with dimension names is required from transformation later on\n    cube_dimensions = self.extract_cellset_cube_with_dimensions(\n        cellset_id=cellset_id, delete_cellset=delete_cellset\n    )\n\n    raw_cellset = {**cube_dimensions, **axes, **cells}\n\n    return Utils.build_content_from_cellset_dict(\n        raw_cellset_as_dict=raw_cellset,\n        top=top,\n        element_unique_names=element_unique_names,\n        skip_cell_properties=skip_cell_properties,\n        skip_sandbox_dimension=skip_sandbox_dimension,\n    )\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.extract_cellset_axes_cardinality","title":"<code>extract_cellset_axes_cardinality(cellset_id)</code>","text":"Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def extract_cellset_axes_cardinality(self, cellset_id: str):\n    url = \"/Cellsets('{cellset_id}')?$expand=Axes($select=Cardinality)\".format(cellset_id=cellset_id)\n    response = self._rest.GET(url=url)\n    return response.json()\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.extract_cellset_axes_raw_async","title":"<code>extract_cellset_axes_raw_async(cellset_id, async_axis=1, max_workers=8, elem_properties=None, member_properties=None, skip_contexts=False, include_hierarchies=False, sandbox_name=None, **kwargs)</code>","text":"<p>Extract cellset axes asynchronously</p> <p>Parameters:</p> Name Type Description Default <code>cellset_id</code> <code>str</code> <p>String; ID of existing cellset</p> required <code>async_axis</code> <code>int</code> <p>determines which axis will be extracted asynchronously</p> <code>1</code> <code>max_workers</code> <code>int</code> <p>Max number of threads, e.g. 14</p> <code>8</code> <code>elem_properties</code> <code>Iterable[str]</code> <p>List of properties to be queried from elements. E.g. ['UniqueName','Attributes', ...]</p> <code>None</code> <code>member_properties</code> <code>Iterable[str]</code> <p>List properties to be queried from the member. E.g. ['Name', 'UniqueName']</p> <code>None</code> <code>skip_contexts</code> <code>bool</code> <p>skip elements from titles / contexts in response</p> <code>False</code> <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <code>include_hierarchies</code> <code>bool</code> <p>retrieve Hierarchies property on Axes</p> <code>False</code> <p>Returns:</p> Type Description <p>Raw format from TM1.</p> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def extract_cellset_axes_raw_async(\n    self,\n    cellset_id: str,\n    async_axis: int = 1,\n    max_workers: int = 8,\n    elem_properties: Iterable[str] = None,\n    member_properties: Iterable[str] = None,\n    skip_contexts: bool = False,\n    include_hierarchies: bool = False,\n    sandbox_name: str = None,\n    **kwargs,\n):\n    \"\"\"Extract cellset axes asynchronously\n\n    :param cellset_id: String; ID of existing cellset\n    :param async_axis: determines which axis will be extracted asynchronously\n    :param max_workers: Max number of threads, e.g. 14\n    :param elem_properties: List of properties to be queried from elements. E.g. ['UniqueName','Attributes', ...]\n    :param member_properties: List properties to be queried from the member. E.g. ['Name', 'UniqueName']\n    :param skip_contexts: skip elements from titles / contexts in response\n    :param sandbox_name: str\n    :param include_hierarchies: retrieve Hierarchies property on Axes\n    :return: Raw format from TM1.\n    \"\"\"\n\n    axes_cardinality = self.extract_cellset_axes_cardinality(cellset_id=cellset_id)\n\n    if async_axis &gt;= len(axes_cardinality[\"Axes\"]):\n        raise ValueError(\"Argument 'async_axis' must be less than axes cardinality\")\n\n    # select Name property if member_properties is None or empty.\n    # Necessary, as tm1 default behaviour is to return all properties if no $select is specified in the request.\n    if member_properties is None or len(list(member_properties)) == 0:\n        member_properties = [\"Name\"]\n    select_member_properties = \"$select={}\".format(\",\".join(member_properties))\n\n    expand_elem_properties = (\n        \";$expand=Element($select={elem_properties})\".format(elem_properties=\",\".join(elem_properties))\n        if elem_properties is not None and len(list(elem_properties)) &gt; 0\n        else \"\"\n    )\n\n    if include_hierarchies:\n        expand_hierarchies = \"Hierarchies($select=Name;$expand=Dimension($select=Name)),\"\n    else:\n        expand_hierarchies = \"\"\n\n    def _extract_cellset_axis_raw(axis: int = async_axis, partition: int = 0, partition_size: int = 0):\n        top = partition_size\n        skip = partition * partition_size\n        filter_axis = \"$filter=Ordinal eq {axis};\".format(axis=axis)\n        url = (\n            \"/Cellsets('{cellset_id}')?$expand=\"\n            \"Axes({filter_axis}$expand={hierarchies}Tuples($expand=Members({select_member_properties}\"\n            \"{expand_elem_properties}){partition}))\".format(\n                cellset_id=cellset_id,\n                partition=f\";$top={top};$skip={skip}\" if partition_size &gt; 0 else \"\",\n                filter_axis=filter_axis,\n                hierarchies=expand_hierarchies,\n                select_member_properties=select_member_properties,\n                expand_elem_properties=expand_elem_properties,\n            )\n        )\n        url = add_url_parameters(url, **{\"!sandbox\": sandbox_name})\n        response = self._rest.GET(url=url, **kwargs)\n\n        return response.json()\n\n    async def _extract_cellset_axes_raw_async():\n        partition_size = math.ceil(axes_cardinality[\"Axes\"][async_axis][\"Cardinality\"] / max_workers)\n        loop = asyncio.get_event_loop()\n        result_list = []\n        with ThreadPoolExecutor(max_workers) as executor:\n            futures = [\n                loop.run_in_executor(executor, _extract_cellset_axis_raw, async_axis, partition, partition_size)\n                for partition in range(max_workers)\n            ]\n\n            for future in futures:\n                result = await future\n                result_list = result_list + result[\"Axes\"][0][\"Tuples\"]\n        return result_list\n\n    # Extract non-asynchronous axis\n    axes = _extract_cellset_axis_raw(axis=1 - async_axis)\n    # Extract tuples for asynchronous axis\n    async_axis_tuples = asyncio.run(_extract_cellset_axes_raw_async())\n    # Combine results\n    axes[\"Axes\"].insert(\n        async_axis,\n        {\n            \"Ordinal\": async_axis,\n            \"Cardinality\": axes_cardinality[\"Axes\"][async_axis][\"Cardinality\"],\n            \"Tuples\": async_axis_tuples,\n        },\n    )\n\n    if not skip_contexts:\n        context = _extract_cellset_axis_raw(axis=2)\n        if len(context[\"Axes\"]) &gt; 0:\n            axes[\"Axes\"].append(context[\"Axes\"][0])\n\n    return axes\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.extract_cellset_cellcount","title":"<code>extract_cellset_cellcount(cellset_id, sandbox_name=None, **kwargs)</code>","text":"<p>Retrieve number of cells in the cellset</p> <p>Parameters:</p> Name Type Description Default <code>cellset_id</code> <code>str</code> required <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <code>kwargs</code> <code>{}</code> <p>Returns:</p> Type Description <code>int</code> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>@tidy_cellset\ndef extract_cellset_cellcount(self, cellset_id: str, sandbox_name: str = None, **kwargs) -&gt; int:\n    \"\"\"Retrieve number of cells in the cellset\n\n    :param cellset_id:\n    :param sandbox_name: str\n    :param kwargs:\n    :return:\n    \"\"\"\n    url = \"/Cellsets('{}')/Cells/$count\".format(cellset_id)\n    url = add_url_parameters(url, **{\"!sandbox\": sandbox_name})\n    response = self._rest.GET(url, **kwargs)\n    return int(response.content)\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.extract_cellset_cells_raw","title":"<code>extract_cellset_cells_raw(cellset_id, cell_properties=None, top=None, skip=None, skip_zeros=False, skip_consolidated_cells=False, skip_rule_derived_cells=False, sandbox_name=None, **kwargs)</code>","text":"Source code in <code>TM1py/Services/CellService.py</code> <pre><code>@odata_compact_json(return_as_dict=True)\ndef extract_cellset_cells_raw(\n    self,\n    cellset_id: str,\n    cell_properties: Iterable[str] = None,\n    top: int = None,\n    skip: int = None,\n    skip_zeros: bool = False,\n    skip_consolidated_cells: bool = False,\n    skip_rule_derived_cells: bool = False,\n    sandbox_name: str = None,\n    **kwargs,\n):\n\n    if not cell_properties:\n        cell_properties = [\"Value\"]\n\n    if skip_rule_derived_cells:\n        cell_properties.append(\"RuleDerived\")\n        # necessary due to bug in TM1 11.8: If only RuleDerived is retrieved it occasionally produces wrong results\n        cell_properties.append(\"Updateable\")\n\n    if skip_consolidated_cells:\n        cell_properties.append(\"Consolidated\")\n\n    if skip or skip_zeros or skip_rule_derived_cells or skip_consolidated_cells:\n        if \"Ordinal\" not in cell_properties:\n            cell_properties.append(\"Ordinal\")\n\n    filter_cells = \"\"\n    if skip_zeros or skip_consolidated_cells or skip_rule_derived_cells:\n        filters = []\n        if skip_zeros:\n            filters.append(\"Value ne 0 and Value ne null and Value ne ''\")\n        if skip_consolidated_cells:\n            filters.append(\"Consolidated eq false\")\n        if skip_rule_derived_cells:\n            filters.append(\"RuleDerived eq false\")\n\n        filter_cells = \" and \".join(filters)\n\n    url = (\n        \"/Cellsets('{cellset_id}')?$expand=\"\n        \"Cells($select={cell_properties}{top_cells}{skip_cells}{filter_cells})\".format(\n            cellset_id=cellset_id,\n            cell_properties=\",\".join(cell_properties),\n            top_cells=f\";$top={top}\" if top else \"\",\n            skip_cells=f\";$skip={skip}\" if skip else \"\",\n            filter_cells=f\";$filter={filter_cells}\" if filter_cells else \"\",\n        )\n    )\n\n    url = add_url_parameters(url, **{\"!sandbox\": sandbox_name})\n    response = self._rest.GET(url=url, **kwargs)\n    return response.json()\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.extract_cellset_cells_raw_async","title":"<code>extract_cellset_cells_raw_async(cellset_id, max_workers=8, cell_properties=None, skip_zeros=False, skip_consolidated_cells=False, skip_rule_derived_cells=False, sandbox_name=None, **kwargs)</code>","text":"Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def extract_cellset_cells_raw_async(\n    self,\n    cellset_id: str,\n    max_workers: int = 8,\n    cell_properties: Iterable[str] = None,\n    skip_zeros: bool = False,\n    skip_consolidated_cells: bool = False,\n    skip_rule_derived_cells: bool = False,\n    sandbox_name: str = None,\n    **kwargs,\n):\n\n    if not cell_properties:\n        cell_properties = [\"Value\"]\n\n    if skip_rule_derived_cells:\n        cell_properties.append(\"RuleDerived\")\n        # necessary due to bug in TM1 11.8: If only RuleDerived is retrieved it occasionally produces wrong results\n        cell_properties.append(\"Updateable\")\n\n    if skip_consolidated_cells:\n        cell_properties.append(\"Consolidated\")\n\n    if skip_zeros or skip_rule_derived_cells or skip_consolidated_cells:\n        if \"Ordinal\" not in cell_properties:\n            cell_properties.append(\"Ordinal\")\n\n    filter_cells = \"\"\n    if skip_zeros or skip_consolidated_cells or skip_rule_derived_cells:\n        filters = []\n        if skip_zeros:\n            filters.append(\"Value ne 0 and Value ne null and Value ne ''\")\n        if skip_consolidated_cells:\n            filters.append(\"Consolidated eq false\")\n        if skip_rule_derived_cells:\n            filters.append(\"RuleDerived eq false\")\n\n        filter_cells = \" and \".join(filters)\n\n    def _extract_cellset_cells_raw(partition: int = 0, partition_size: int = 0):\n        top = partition_size\n        skip = partition * partition_size\n\n        url = (\n            \"/Cellsets('{cellset_id}')?$expand=\"\n            \"Cells($select={cell_properties}{top_cells}{skip_cells}{filter_cells})\".format(\n                cellset_id=cellset_id,\n                cell_properties=\",\".join(cell_properties),\n                top_cells=f\";$top={top}\" if top else \"\",\n                skip_cells=f\";$skip={skip}\" if skip else \"\",\n                filter_cells=f\";$filter={filter_cells}\" if filter_cells else \"\",\n            )\n        )\n\n        url = add_url_parameters(url, **{\"!sandbox\": sandbox_name})\n        response = self._rest.GET(url=url, **kwargs)\n\n        return response.json()\n\n    async def _extract_cellset_cells_raw_async():\n        cellcount = self.extract_cellset_cellcount(\n            cellset_id=cellset_id, sandbox_name=sandbox_name, delete_cellset=False\n        )\n        partition_size = math.ceil(cellcount / max_workers)\n        loop = asyncio.get_event_loop()\n        result_list = []\n        with ThreadPoolExecutor(max_workers) as executor:\n            futures = [\n                loop.run_in_executor(executor, _extract_cellset_cells_raw, partition, partition_size)\n                for partition in range(max_workers)\n            ]\n            for future in futures:\n                result = await future\n                result_list = result_list + result[\"Cells\"]\n            cells = {\"@odata.context\": result[\"@odata.context\"], \"ID\": result[\"ID\"], \"Cells\": result_list}\n        return cells\n\n    cells = asyncio.run(_extract_cellset_cells_raw_async())\n\n    return cells\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.extract_cellset_composition","title":"<code>extract_cellset_composition(cellset_id, sandbox_name=None, **kwargs)</code>","text":"<p>Retrieve composition of dimensions on the axes in the cellset</p> <p>Parameters:</p> Name Type Description Default <code>cellset_id</code> <code>str</code> required <code>kwargs</code> <code>{}</code> <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[str, List[str], List[str], List[str]]</code> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>@tidy_cellset\ndef extract_cellset_composition(\n    self, cellset_id: str, sandbox_name: str = None, **kwargs\n) -&gt; Tuple[str, List[str], List[str], List[str]]:\n    \"\"\"Retrieve composition of dimensions on the axes in the cellset\n\n    :param cellset_id:\n    :param kwargs:\n    :param sandbox_name: str\n    :return:\n    \"\"\"\n    url = (\n        \"/Cellsets('{}')?$expand=\"\n        \"Cube($select=Name),\"\n        \"Axes($expand=Hierarchies($select=UniqueName))\".format(cellset_id)\n    )\n\n    url = add_url_parameters(url, **{\"!sandbox\": sandbox_name})\n    response = self._rest.GET(url=url, **kwargs)\n    response_json = response.json()\n    cube = response_json[\"Cube\"][\"Name\"]\n\n    rows, titles, columns = [], [], []\n    if len(response_json[\"Axes\"]) == 1:\n        if response_json[\"Axes\"][0][\"Hierarchies\"]:\n            columns = [hierarchy[\"UniqueName\"] for hierarchy in response_json[\"Axes\"][0][\"Hierarchies\"]]\n    else:\n        if response_json[\"Axes\"][0][\"Hierarchies\"]:\n            columns = [hierarchy[\"UniqueName\"] for hierarchy in response_json[\"Axes\"][0][\"Hierarchies\"]]\n        if response_json[\"Axes\"][1][\"Hierarchies\"]:\n            rows = [hierarchy[\"UniqueName\"] for hierarchy in response_json[\"Axes\"][1][\"Hierarchies\"]]\n    if len(response_json[\"Axes\"]) &gt; 2:\n        titles = [hierarchy[\"UniqueName\"] for hierarchy in response_json[\"Axes\"][2][\"Hierarchies\"]]\n    return cube, titles, rows, columns\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.extract_cellset_csv","title":"<code>extract_cellset_csv(cellset_id, top=None, skip=None, skip_zeros=True, skip_consolidated_cells=False, skip_rule_derived_cells=False, csv_dialect=None, line_separator='\\r\\n', value_separator=',', sandbox_name=None, include_attributes=False, use_compact_json=False, include_headers=True, mdx_headers=False, **kwargs)</code>","text":"<p>Execute cellset and return only the 'Content', in csv format</p> <p>Parameters:</p> Name Type Description Default <code>cellset_id</code> <code>str</code> <p>String; ID of existing cellset</p> required <code>top</code> <code>int</code> <p>Int, number of cells to return (counting from top)</p> <code>None</code> <code>skip</code> <code>int</code> <p>Int, number of cells to skip (counting from top)</p> <code>None</code> <code>skip_zeros</code> <code>bool</code> <p>skip zeros in cellset (irrespective of zero suppression in MDX / view)</p> <code>True</code> <code>skip_consolidated_cells</code> <code>bool</code> <p>skip consolidated cells in cellset</p> <code>False</code> <code>skip_rule_derived_cells</code> <code>bool</code> <p>skip rule derived cells in cellset</p> <code>False</code> <code>csv_dialect</code> <code>Dialect</code> <p>provide all csv output settings through standard library csv.Dialect If not provided dialect is created based on line_separator and value_separator arguments.</p> <code>None</code> <code>line_separator</code> <code>str</code> <code>'\\r\\n'</code> <code>value_separator</code> <code>str</code> <code>','</code> <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <code>include_attributes</code> <code>bool</code> <p>include attribute columns</p> <code>False</code> <code>use_compact_json</code> <code>bool</code> <p>boolean</p> <code>False</code> <code>include_headers</code> <code>bool</code> <p>boolean</p> <code>True</code> <code>mdx_headers</code> <code>bool</code> <p>boolean. Fully qualified hierarchy name as header instead of simple dimension name</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>Raw format from TM1.</p> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def extract_cellset_csv(\n    self,\n    cellset_id: str,\n    top: int = None,\n    skip: int = None,\n    skip_zeros: bool = True,\n    skip_consolidated_cells: bool = False,\n    skip_rule_derived_cells: bool = False,\n    csv_dialect: \"csv.Dialect\" = None,\n    line_separator: str = \"\\r\\n\",\n    value_separator: str = \",\",\n    sandbox_name: str = None,\n    include_attributes: bool = False,\n    use_compact_json: bool = False,\n    include_headers: bool = True,\n    mdx_headers: bool = False,\n    **kwargs,\n) -&gt; str:\n    \"\"\"Execute cellset and return only the 'Content', in csv format\n\n    :param cellset_id: String; ID of existing cellset\n    :param top: Int, number of cells to return (counting from top)\n    :param skip: Int, number of cells to skip (counting from top)\n    :param skip_zeros: skip zeros in cellset (irrespective of zero suppression in MDX / view)\n    :param skip_consolidated_cells: skip consolidated cells in cellset\n    :param skip_rule_derived_cells: skip rule derived cells in cellset\n    :param csv_dialect: provide all csv output settings through standard library csv.Dialect\n        If not provided dialect is created based on line_separator and value_separator arguments.\n    :param line_separator:\n    :param value_separator:\n    :param sandbox_name: str\n    :param include_attributes: include attribute columns\n    :param use_compact_json: boolean\n    :param include_headers: boolean\n    :param mdx_headers: boolean. Fully qualified hierarchy name as header instead of simple dimension name\n    :return: Raw format from TM1.\n    \"\"\"\n    delete_cellset = kwargs.pop(\"delete_cellset\", True)\n\n    cube, _, rows, columns = self.extract_cellset_composition(\n        cellset_id, delete_cellset=False, sandbox_name=sandbox_name, **kwargs\n    )\n\n    cellset_dict = self.extract_cellset_raw(\n        cellset_id,\n        cell_properties=[\"Value\"],\n        top=top,\n        skip=skip,\n        skip_contexts=True,\n        skip_zeros=skip_zeros,\n        skip_consolidated_cells=skip_consolidated_cells,\n        skip_rule_derived_cells=skip_rule_derived_cells,\n        delete_cellset=delete_cellset,\n        sandbox_name=sandbox_name,\n        elem_properties=[\"Name\"],\n        member_properties=[\"Name\", \"Attributes\"] if include_attributes else None,\n        use_compact_json=use_compact_json,\n        **kwargs,\n    )\n\n    return build_csv_from_cellset_dict(\n        row_dimensions=rows,\n        column_dimensions=columns,\n        raw_cellset_as_dict=cellset_dict,\n        csv_dialect=csv_dialect,\n        line_separator=line_separator,\n        value_separator=value_separator,\n        top=top,\n        include_attributes=include_attributes,\n        include_headers=include_headers,\n        mdx_headers=mdx_headers,\n    )\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.extract_cellset_csv_iter_json","title":"<code>extract_cellset_csv_iter_json(cellset_id, top=None, skip=None, skip_zeros=True, skip_consolidated_cells=False, skip_rule_derived_cells=False, csv_dialect=None, line_separator='\\r\\n', value_separator=',', sandbox_name=None, include_attributes=False, mdx_headers=False, **kwargs)</code>","text":"<p>Execute cellset and return only the 'Content', in csv format</p> <p>Parameters:</p> Name Type Description Default <code>cellset_id</code> <code>str</code> <p>String; ID of existing cellset</p> required <code>top</code> <code>int</code> <p>Int, number of cells to return (counting from top)</p> <code>None</code> <code>skip</code> <code>int</code> <p>Int, number of cells to skip (counting from top)</p> <code>None</code> <code>skip_zeros</code> <code>bool</code> <p>skip zeros in cellset (irrespective of zero suppression in MDX / view)</p> <code>True</code> <code>skip_consolidated_cells</code> <code>bool</code> <p>skip consolidated cells in cellset</p> <code>False</code> <code>skip_rule_derived_cells</code> <code>bool</code> <p>skip rule derived cells in cellset</p> <code>False</code> <code>csv_dialect</code> <code>Dialect</code> <p>provide all csv output settings through standard library csv.Dialect If not provided dialect is created based on line_separator and value_separator arguments.</p> <code>None</code> <code>line_separator</code> <code>str</code> <code>'\\r\\n'</code> <code>value_separator</code> <code>str</code> <code>','</code> <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <code>include_attributes</code> <code>bool</code> <p>boolean</p> <code>False</code> <code>mdx_headers</code> <code>bool</code> <p>boolean. Fully qualified hierarchy name as header instead of simple dimension name</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>Raw format from TM1.</p> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def extract_cellset_csv_iter_json(\n    self,\n    cellset_id: str,\n    top: int = None,\n    skip: int = None,\n    skip_zeros: bool = True,\n    skip_consolidated_cells: bool = False,\n    skip_rule_derived_cells: bool = False,\n    csv_dialect: \"csv.Dialect\" = None,\n    line_separator: str = \"\\r\\n\",\n    value_separator: str = \",\",\n    sandbox_name: str = None,\n    include_attributes: bool = False,\n    mdx_headers: bool = False,\n    **kwargs,\n) -&gt; str:\n    \"\"\"Execute cellset and return only the 'Content', in csv format\n\n    :param cellset_id: String; ID of existing cellset\n    :param top: Int, number of cells to return (counting from top)\n    :param skip: Int, number of cells to skip (counting from top)\n    :param skip_zeros: skip zeros in cellset (irrespective of zero suppression in MDX / view)\n    :param skip_consolidated_cells: skip consolidated cells in cellset\n    :param skip_rule_derived_cells: skip rule derived cells in cellset\n    :param csv_dialect: provide all csv output settings through standard library csv.Dialect\n        If not provided dialect is created based on line_separator and value_separator arguments.\n    :param line_separator:\n    :param value_separator:\n    :param sandbox_name: str\n    :param include_attributes: boolean\n    :param mdx_headers: boolean. Fully qualified hierarchy name as header instead of simple dimension name\n    :return: Raw format from TM1.\n    \"\"\"\n    cube, _, rows, columns = self.extract_cellset_composition(\n        cellset_id, delete_cellset=False, sandbox_name=sandbox_name, **kwargs\n    )\n\n    cellset_response = self.extract_cellset_raw_response(\n        cellset_id,\n        cell_properties=[\"Value\", \"Ordinal\"],\n        top=top,\n        skip=skip,\n        skip_contexts=True,\n        skip_zeros=skip_zeros,\n        skip_consolidated_cells=skip_consolidated_cells,\n        skip_rule_derived_cells=skip_rule_derived_cells,\n        delete_cellset=True,\n        sandbox_name=sandbox_name,\n        member_properties=[\"Name\", \"Attributes\"] if include_attributes else [\"Name\"],\n        **kwargs,\n    )\n\n    if not mdx_headers:\n        row_headers = list(dimension_names_from_element_unique_names(rows))\n        column_headers = list(dimension_names_from_element_unique_names(columns))\n    else:\n        row_headers = rows\n        column_headers = columns\n\n    if csv_dialect is None:\n        csv.register_dialect(\"TM1py\", delimiter=value_separator, lineterminator=line_separator)\n        csv_dialect = csv.get_dialect(\"TM1py\")\n\n    # start parsing of JSON directly into CSV\n    axes0_list = []\n    axes1_list = []\n    current_axes = 0\n    current_tuple = 0\n    current_cell_ordinal = 0\n    csv_body = StringIO()\n    csv_writer = csv.writer(csv_body, dialect=csv_dialect)\n    # handle potential imbalance between number of headers and entries in row\n    max_entries_per_row = 0\n    least_entries_per_row = 1_000\n\n    parser = ijson.parse(cellset_response.content)\n    prefixes_of_interest = [\n        \"Cells.item.Value\",\n        \"Axes.item.Tuples.item.Members.item.Name\",\n        \"Cells.item.Ordinal\",\n        \"Axes.item.Tuples.item.Ordinal\",\n        \"Cube.Dimensions.item.Name\",\n        \"Axes.item.Ordinal\",\n    ]\n\n    attributes_prefixes = set()\n    attributes_by_dimension = None\n    if include_attributes:\n        attributes_by_dimension = self._get_attributes_by_dimension(cube)\n        for _, attributes in attributes_by_dimension.items():\n            for attribute in attributes:\n                prefix = f\"Axes.item.Tuples.item.Members.item.Attributes.{attribute}\"\n                prefixes_of_interest.append(prefix)\n                attributes_prefixes.add(prefix)\n\n    gen = ((prefix, event, value) for prefix, event, value in parser if prefix in prefixes_of_interest)\n    for prefix, event, value in gen:\n        if prefix == \"Cells.item.Value\":\n            q, r = divmod(current_cell_ordinal, len(axes0_list))\n            axes0_index = r\n            axes1_index = q\n            if len(axes0_list) == 1 and len(axes0_list[0]) == 0:\n                row = axes1_list[axes1_index] + [str(value)]\n            # case of no row selection\n            elif len(axes1_list) == 0:\n                row = axes0_list[axes0_index] + [str(value)]\n            else:\n                row = axes1_list[axes1_index] + axes0_list[axes0_index] + [str(value)]\n\n            if len(row) &gt; max_entries_per_row:\n                max_entries_per_row = len(row)\n            if len(row) &lt; least_entries_per_row:\n                least_entries_per_row = len(row)\n\n            csv_writer.writerow(row)\n\n        elif (prefix, event) == (\"Axes.item.Tuples.item.Members.item.Name\", \"string\"):\n            if current_axes == 0:\n                axes0_list[current_tuple].append(value)\n            else:\n                axes1_list[current_tuple].append(value)\n\n        if prefix in attributes_prefixes:\n            if event not in (\"string\", \"number\"):\n                continue\n\n            attribute_name = prefix.split(\".\")[-1]\n            value = str(value)\n\n            if current_axes == 0:\n                axes0_list[current_tuple].append(value)\n            else:\n                axes1_list[current_tuple].append(value)\n\n            # Add header entry for attribute if necessary\n            if current_tuple == 0:\n                if current_axes == 0:\n                    column_headers.insert(len(axes0_list[current_tuple]) - 1, attribute_name)\n                else:\n                    row_headers.insert(len(axes1_list[current_tuple]) - 1, attribute_name)\n\n        elif (prefix, event) == (\"Cells.item.Ordinal\", \"number\"):\n            current_cell_ordinal = value\n\n        elif (prefix, event) == (\"Axes.item.Tuples.item.Ordinal\", \"number\"):\n            current_tuple = value\n            if current_axes == 0:\n                axes0_list.append(list())\n            else:\n                axes1_list.append(list())\n\n        elif (prefix, event) == (\"Axes.item.Ordinal\", \"number\"):\n            current_axes = value\n\n    # comply with prior implementations: return empty string when cellset is empty\n    if csv_body.getvalue() == \"\":\n        return \"\"\n\n    # prepare header\n    if include_attributes:\n        if not least_entries_per_row == max_entries_per_row == len(row_headers) + len(column_headers) + 1:\n            raise ValueError(\n                \"Invalid response. With 'include_attributes' as True,\"\n                \" Attributes must be requested explicitly as PROPERTIES in the MDX\"\n            )\n\n    csv_header = StringIO()\n    csv_header_writer = csv.writer(csv_header, dialect=csv_dialect)\n    csv_header_writer.writerow(row_headers + column_headers + [\"Value\"])\n\n    cellset_response.close()\n    return csv_header.getvalue() + csv_body.getvalue().strip()\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.extract_cellset_cube_with_dimensions","title":"<code>extract_cellset_cube_with_dimensions(cellset_id, **kwargs)</code>","text":"Source code in <code>TM1py/Services/CellService.py</code> <pre><code>@tidy_cellset\ndef extract_cellset_cube_with_dimensions(self, cellset_id: str, **kwargs):\n    url = format_url(\n        \"/Cellsets('{}')?$expand=Cube($select=Dimensions;$expand=Dimensions($select=Name))\", cellset_id\n    )\n\n    response = self._rest.GET(url=url, **kwargs)\n\n    return response.json()\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.extract_cellset_dataframe","title":"<code>extract_cellset_dataframe(cellset_id, top=None, skip=None, skip_zeros=True, skip_consolidated_cells=False, skip_rule_derived_cells=False, sandbox_name=None, include_attributes=False, use_iterative_json=False, use_compact_json=False, shaped=False, mdx_headers=False, fillna_numeric_attributes=False, fillna_numeric_attributes_value=0, fillna_string_attributes=False, fillna_string_attributes_value='', **kwargs)</code>","text":"<p>Build pandas data frame from cellset_id</p> <p>Parameters:</p> Name Type Description Default <code>cellset_id</code> <code>str</code> required <code>top</code> <code>int</code> <p>Int, number of cells to return (counting from top)</p> <code>None</code> <code>skip</code> <code>int</code> <p>Int, number of cells to skip (counting from top)</p> <code>None</code> <code>skip_zeros</code> <code>bool</code> <p>skip zeros in cellset (irrespective of zero suppression in MDX / view)</p> <code>True</code> <code>skip_consolidated_cells</code> <code>bool</code> <p>skip consolidated cells in cellset</p> <code>False</code> <code>skip_rule_derived_cells</code> <code>bool</code> <p>skip rule derived cells in cellset</p> <code>False</code> <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <code>include_attributes</code> <code>bool</code> <p>include attribute columns</p> <code>False</code> <code>use_iterative_json</code> <code>bool</code> <p>use iterative json parsing to reduce memory consumption significantly. Comes at a cost of 3-5% performance.</p> <code>False</code> <code>use_compact_json</code> <code>bool</code> <p>bool</p> <code>False</code> <code>kwargs</code> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>@require_pandas\ndef extract_cellset_dataframe(\n    self,\n    cellset_id: str,\n    top: int = None,\n    skip: int = None,\n    skip_zeros: bool = True,\n    skip_consolidated_cells: bool = False,\n    skip_rule_derived_cells: bool = False,\n    sandbox_name: str = None,\n    include_attributes: bool = False,\n    use_iterative_json: bool = False,\n    use_compact_json: bool = False,\n    shaped: bool = False,\n    mdx_headers: bool = False,\n    fillna_numeric_attributes: bool = False,\n    fillna_numeric_attributes_value: Any = 0,\n    fillna_string_attributes: bool = False,\n    fillna_string_attributes_value: Any = \"\",\n    **kwargs,\n) -&gt; \"pd.DataFrame\":\n    \"\"\"Build pandas data frame from cellset_id\n\n    :param cellset_id:\n    :param top: Int, number of cells to return (counting from top)\n    :param skip: Int, number of cells to skip (counting from top)\n    :param skip_zeros: skip zeros in cellset (irrespective of zero suppression in MDX / view)\n    :param skip_consolidated_cells: skip consolidated cells in cellset\n    :param skip_rule_derived_cells: skip rule derived cells in cellset\n    :param sandbox_name: str\n    :param include_attributes: include attribute columns\n    :param use_iterative_json: use iterative json parsing to reduce memory consumption significantly.\n    Comes at a cost of 3-5% performance.\n    :param use_compact_json: bool\n    :param kwargs:\n    :return:\n    \"\"\"\n    if use_iterative_json and use_compact_json:\n        raise ValueError(\"Iterative JSON parsing must not be used together with compact JSON\")\n\n    if use_iterative_json:\n        raw_csv = self.extract_cellset_csv_iter_json(\n            cellset_id=cellset_id,\n            top=top,\n            skip=skip,\n            skip_zeros=skip_zeros,\n            skip_rule_derived_cells=skip_rule_derived_cells,\n            skip_consolidated_cells=skip_consolidated_cells,\n            value_separator=\"~\",\n            sandbox_name=sandbox_name,\n            include_attributes=include_attributes,\n            mdx_headers=mdx_headers,\n            **kwargs,\n        )\n    else:\n        raw_csv = self.extract_cellset_csv(\n            cellset_id=cellset_id,\n            top=top,\n            skip=skip,\n            skip_zeros=skip_zeros,\n            skip_rule_derived_cells=skip_rule_derived_cells,\n            skip_consolidated_cells=skip_consolidated_cells,\n            value_separator=\"~\",\n            sandbox_name=sandbox_name,\n            include_attributes=include_attributes,\n            use_compact_json=use_compact_json,\n            mdx_headers=mdx_headers,\n            # dont delete cellset if attribute types must be retrieved later\n            delete_cellset=not any([fillna_string_attributes, fillna_string_attributes]),\n            **kwargs,\n        )\n\n    attribute_types_by_dimension = None\n    if fillna_string_attributes or fillna_string_attributes:\n        attribute_types_by_dimension = self._extract_attribute_types_by_dimension(\n            cellset_id=cellset_id, sandbox_name=sandbox_name, delete_cellset=True, **kwargs\n        )\n\n    return build_dataframe_from_csv(\n        raw_csv,\n        sep=\"~\",\n        shaped=shaped,\n        fillna_numeric_attributes=fillna_numeric_attributes,\n        fillna_string_attributes=fillna_string_attributes,\n        fillna_numeric_attributes_value=fillna_numeric_attributes_value,\n        fillna_string_attributes_value=fillna_string_attributes_value,\n        attribute_types_by_dimension=attribute_types_by_dimension,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.extract_cellset_dataframe_pivot","title":"<code>extract_cellset_dataframe_pivot(cellset_id, dropna=False, fill_value=False, sandbox_name=None, use_compact_json=False, **kwargs)</code>","text":"<p>Extract a pivot table (pandas dataframe) from a cellset in TM1</p> <p>Parameters:</p> Name Type Description Default <code>cellset_id</code> <code>str</code> required <code>dropna</code> <code>bool</code> <code>False</code> <code>fill_value</code> <code>bool</code> <code>False</code> <code>kwargs</code> <code>{}</code> <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <code>use_compact_json</code> <code>bool</code> <p>bool</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>@require_pandas\ndef extract_cellset_dataframe_pivot(\n    self,\n    cellset_id: str,\n    dropna: bool = False,\n    fill_value: bool = False,\n    sandbox_name: str = None,\n    use_compact_json: bool = False,\n    **kwargs,\n) -&gt; \"pd.DataFrame\":\n    \"\"\"Extract a pivot table (pandas dataframe) from a cellset in TM1\n\n    :param cellset_id:\n    :param dropna:\n    :param fill_value:\n    :param kwargs:\n    :param sandbox_name: str\n    :param use_compact_json: bool\n    :return:\n    \"\"\"\n\n    data = self.extract_cellset(\n        cellset_id=cellset_id,\n        delete_cellset=False,\n        sandbox_name=sandbox_name,\n        use_compact_json=use_compact_json,\n        **kwargs,\n    )\n\n    cube, titles, rows, columns = self.extract_cellset_composition(\n        cellset_id=cellset_id, delete_cellset=True, sandbox_name=sandbox_name, **kwargs\n    )\n\n    df = build_pandas_dataframe_from_cellset(data, multiindex=False)\n    return pd.pivot_table(\n        data=df,\n        index=[dimension_name_from_element_unique_name(hierarchy_unique_name) for hierarchy_unique_name in rows],\n        columns=[\n            dimension_name_from_element_unique_name(hierarchy_unique_name) for hierarchy_unique_name in columns\n        ],\n        values=[\"Values\"],\n        dropna=dropna,\n        fill_value=fill_value,\n        aggfunc=\"sum\",\n    )\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.extract_cellset_dataframe_shaped","title":"<code>extract_cellset_dataframe_shaped(cellset_id, sandbox_name=None, display_attribute=False, infer_dtype=False, mdx_headers=False, **kwargs)</code>","text":"<p>Retrieves data from cellset in the shape of the query. Dimensions on rows can be stacked. One dimension must be placed on columns. Title selections are ignored.</p> <p>Parameters:</p> Name Type Description Default <code>cellset_id</code> <code>str</code> <p>cellset_id</p> required <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <code>display_attribute</code> <code>bool</code> <p>bool, show element name or first attribute from MDX PROPERTIES clause</p> <code>False</code> <code>infer_dtype</code> <code>bool</code> <p>bool, if True, lets pandas infer dtypes, otherwise all columns will be of type str.</p> <code>False</code> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>@tidy_cellset\n@require_pandas\ndef extract_cellset_dataframe_shaped(\n    self,\n    cellset_id: str,\n    sandbox_name: str = None,\n    display_attribute: bool = False,\n    infer_dtype: bool = False,\n    mdx_headers: bool = False,\n    **kwargs,\n) -&gt; \"pd.DataFrame\":\n    \"\"\"Retrieves data from cellset in the shape of the query.\n    Dimensions on rows can be stacked. One dimension must be placed on columns. Title selections are ignored.\n\n    :param cellset_id: cellset_id\n    :param sandbox_name: str\n    :param display_attribute: bool, show element name or first attribute from MDX PROPERTIES clause\n    :param infer_dtype: bool, if True, lets pandas infer dtypes, otherwise all columns will be of type str.\n\n    \"\"\"\n    url = (\n        \"/Cellsets('{}')?$expand=\"\n        \"Axes($filter=Ordinal eq 0 or Ordinal eq 1;$expand=Tuples(\"\n        \"$expand=Members($select=Name{})),Hierarchies($select=Name,Dimension;$expand=Dimension($select=Name))),\"\n        \"Cells($select=Value)\".format(cellset_id, \",Attributes\" if display_attribute else \"\")\n    )\n\n    url = add_url_parameters(url, **{\"!sandbox\": sandbox_name})\n    response = self._rest.GET(url=url, **kwargs)\n    response_json = response.json()\n\n    column_headers = list()\n    for column_tuple in response_json[\"Axes\"][0][\"Tuples\"]:\n        member = column_tuple[\"Members\"][0]\n        if display_attribute and member[\"Attributes\"]:\n            attribute_values = list(member[\"Attributes\"].values())\n            column_headers.append(attribute_values[0])\n        else:\n            column_headers.append(member[\"Name\"])\n\n    rows = response_json[\"Axes\"][1][\"Tuples\"]\n    if mdx_headers:\n        row_headers = [\n            f\"[{hierarchy['Dimension']['Name']}].[{hierarchy['Name']}]\"\n            for hierarchy in response_json[\"Axes\"][1][\"Hierarchies\"]\n        ]\n    else:\n        row_headers = [hierarchy[\"Dimension\"][\"Name\"] for hierarchy in response_json[\"Axes\"][1][\"Hierarchies\"]]\n    cell_values = [cell[\"Value\"] for cell in response_json[\"Cells\"]]\n\n    headers = row_headers + column_headers\n    body = []\n\n    number_rows = len(rows)\n    # avoid division by zero\n    if not number_rows:\n        return pd.DataFrame(body, columns=headers)\n\n    number_cells = len(cell_values)\n    number_columns = int(number_cells / number_rows)\n\n    element_names_by_row = list()\n    for row_tuple in rows:\n        row = list()\n        for member in row_tuple[\"Members\"]:\n            if display_attribute and member[\"Attributes\"]:\n                attribute_values = list(member[\"Attributes\"].values())\n                row.append(attribute_values[0])\n            else:\n                row.append(member[\"Name\"])\n\n        element_names_by_row.append(tuple(row))\n\n    if not number_columns:\n        return pd.DataFrame(data=element_names_by_row, columns=headers)\n\n    cell_values_by_row = [\n        cell_values[cell_counter : cell_counter + number_columns]\n        for cell_counter in range(0, number_cells, number_columns)\n    ]\n\n    for element_tuple, cells in zip(element_names_by_row, cell_values_by_row):\n        body.append(list(element_tuple) + cells)\n    if infer_dtype:\n        return pd.DataFrame(body, columns=headers)\n    else:\n        return pd.DataFrame(body, columns=headers, dtype=str)\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.extract_cellset_metadata_raw","title":"<code>extract_cellset_metadata_raw(cellset_id, elem_properties=None, member_properties=None, top=None, skip=None, skip_contexts=False, include_hierarchies=False, sandbox_name=None, delete_cellset=False, **kwargs)</code>","text":"Source code in <code>TM1py/Services/CellService.py</code> <pre><code>@tidy_cellset\ndef extract_cellset_metadata_raw(\n    self,\n    cellset_id: str,\n    elem_properties: Iterable[str] = None,\n    member_properties: Iterable[str] = None,\n    top: int = None,\n    skip: int = None,\n    skip_contexts: bool = False,\n    include_hierarchies: bool = False,\n    sandbox_name: str = None,\n    delete_cellset: bool = False,\n    **kwargs,\n):\n\n    # select Name property if member_properties is None or empty.\n    # Necessary, as tm1 default behaviour is to return all properties if no $select is specified in the request.\n    if member_properties is None or len(list(member_properties)) == 0:\n        member_properties = [\"Name\"]\n    select_member_properties = \"$select={}\".format(\",\".join(member_properties))\n\n    expand_elem_properties = (\n        \";$expand=Element($select={elem_properties})\".format(elem_properties=\",\".join(elem_properties))\n        if elem_properties is not None and len(list(elem_properties)) &gt; 0\n        else \"\"\n    )\n\n    if include_hierarchies:\n        expand_hierarchies = \"Hierarchies($select=Name;$expand=Dimension($select=Name)),\"\n    else:\n        expand_hierarchies = \"\"\n\n    filter_axis = \"$filter=Ordinal ne 2;\" if skip_contexts else \"\"\n\n    # top_tuples parameter is used as an optimization trick:\n    # if top_cells is set to N =&gt; it will be sufficient to get only the first N tuples in Axes, top_tuples does this\n    # if skip_cells is used =&gt; trick not applicable, all tuples must be extracted\n\n    url = (\n        \"/Cellsets('{cellset_id}')?$expand=\"\n        \"Cube($select=Name;$expand=Dimensions($select=Name)),\"\n        \"Axes({filter_axis}$expand={hierarchies}Tuples($expand=Members({select_member_properties}\"\n        \"{expand_elem_properties}){top_tuples}))\".format(\n            cellset_id=cellset_id,\n            top_tuples=f\";$top={top}\" if top and not skip else \"\",\n            filter_axis=filter_axis,\n            hierarchies=expand_hierarchies,\n            select_member_properties=select_member_properties,\n            expand_elem_properties=expand_elem_properties,\n        )\n    )\n\n    url = add_url_parameters(url, **{\"!sandbox\": sandbox_name})\n    response = self._rest.GET(url=url, **kwargs)\n    return response.json()\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.extract_cellset_partition","title":"<code>extract_cellset_partition(cellset_id, partition_start_ordinal, partition_end_ordinal, cell_properties=None, top=None, skip=None, skip_zeros=False, skip_consolidated_cells=False, skip_rule_derived_cells=False, sandbox_name=None)</code>","text":"<p>Method to extract a cellset partition. Cellset partitions are a collection of cellset cells where they have a defined top left boundary, and bottom right boundary. Read More: https://www.ibm.com/docs/en/planning-analytics/2.0.0?topic=data-cellsets#dg_tm1_odata_get_cells__title__1</p> <p>Parameters:</p> Name Type Description Default <code>partition_start_ordinal</code> <code>int</code> <p>top left cell boundary</p> required <code>partition_end_ordinal</code> <code>int</code> <p>bottom right cell boundary</p> required <code>cell_properties</code> <code>Iterable[str]</code> <p>cell properties to include, default: Orginal, Value</p> <code>None</code> <code>top</code> <code>int</code> <p>Integer limiting the number of cells and the number or rows returned</p> <code>None</code> <code>skip</code> <code>int</code> <p>Integer limiting the number of cells and the number or rows returned</p> <code>None</code> <code>skip_zeros</code> <code>bool</code> <p>skip zeros in cellset (irrespective of zero suppression in MDX / view)</p> <code>False</code> <code>skip_consolidated_cells</code> <code>bool</code> <p>skip consolidated cells in cellset</p> <code>False</code> <code>skip_rule_derived_cells</code> <code>bool</code> <p>skip rule derived cells in cellset</p> <code>False</code> <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict</code> <p>CellSet Dictionary</p> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def extract_cellset_partition(\n    self,\n    cellset_id: str,\n    partition_start_ordinal: int,\n    partition_end_ordinal: int,\n    cell_properties: Iterable[str] = None,\n    top: int = None,\n    skip: int = None,\n    skip_zeros: bool = False,\n    skip_consolidated_cells: bool = False,\n    skip_rule_derived_cells: bool = False,\n    sandbox_name: str = None,\n) -&gt; Dict:\n    \"\"\"\n    Method to extract a cellset partition. Cellset partitions are a collection of cellset cells where they have\n    a defined top left boundary, and bottom right boundary.\n    Read More: https://www.ibm.com/docs/en/planning-analytics/2.0.0?topic=data-cellsets#dg_tm1_odata_get_cells__title__1\n    :param partition_start_ordinal: top left cell boundary\n    :param partition_end_ordinal: bottom right cell boundary\n    :param cell_properties: cell properties to include, default: Orginal, Value\n    :param top: Integer limiting the number of cells and the number or rows returned\n    :param skip: Integer limiting the number of cells and the number or rows returned\n    :param skip_zeros: skip zeros in cellset (irrespective of zero suppression in MDX / view)\n    :param skip_consolidated_cells: skip consolidated cells in cellset\n    :param skip_rule_derived_cells: skip rule derived cells in cellset\n    :param sandbox_name: str\n    :return: CellSet Dictionary\n    \"\"\"\n\n    if not cell_properties:\n        cell_properties = [\"Value\", \"Ordinal\"]\n\n    if skip_rule_derived_cells:\n        cell_properties.append(\"RuleDerived\")\n        # necessary due to bug in TM1 11.8: If only RuleDerived is retrieved it occasionally produces wrong results\n        cell_properties.append(\"Updateable\")\n\n    if skip_consolidated_cells:\n        cell_properties.append(\"Consolidated\")\n\n    filter_cells = \"\"\n    if skip_zeros or skip_consolidated_cells or skip_rule_derived_cells:\n        filters = []\n        if skip_zeros:\n            filters.append(\"Value ne 0 and Value ne null and Value ne ''\")\n        if skip_consolidated_cells:\n            filters.append(\"Consolidated eq false\")\n        if skip_rule_derived_cells:\n            filters.append(\"RuleDerived eq false\")\n\n        filter_cells = \" and \".join(filters)\n\n    url = (\n        \"/Cellsets('{cellset_id}')/tm1.GetPartition{cell_partition}?$select={cell_properties}{\"\n        \"top_cells}{skip_cells}{filter_cells}\"\n    ).format(\n        cellset_id=cellset_id,\n        cell_partition=f\"(Begin={partition_start_ordinal}, End={partition_end_ordinal})\",\n        cell_properties=\",\".join(cell_properties),\n        top_cells=f\"&amp;$top={top}\" if top else \"\",\n        skip_cells=f\"&amp;$skip={skip}\" if skip else \"\",\n        filter_cells=f\"&amp;$filter={filter_cells}\" if filter_cells else \"\",\n    )\n\n    url = add_url_parameters(url, **{\"!sandbox\": sandbox_name})\n    response = self._rest.GET(url=url)\n    return response.json()[\"value\"]\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.extract_cellset_raw","title":"<code>extract_cellset_raw(cellset_id, cell_properties=None, elem_properties=None, member_properties=None, top=None, skip=None, skip_contexts=False, skip_zeros=False, skip_consolidated_cells=False, skip_rule_derived_cells=False, sandbox_name=None, include_hierarchies=False, use_compact_json=False, **kwargs)</code>","text":"<p>Extract full cellset data and return the raw data from TM1</p> <p>Parameters:</p> Name Type Description Default <code>cellset_id</code> <code>str</code> <p>String; ID of existing cellset</p> required <code>cell_properties</code> <code>Iterable[str]</code> <p>List of properties to be queried from cells. E.g. ['Value', 'RuleDerived', ...]</p> <code>None</code> <code>elem_properties</code> <code>Iterable[str]</code> <p>List of properties to be queried from elements. E.g. ['UniqueName','Attributes', ...]</p> <code>None</code> <code>member_properties</code> <code>Iterable[str]</code> <p>List properties to be queried from the member. E.g. ['Name', 'UniqueName']</p> <code>None</code> <code>top</code> <code>int</code> <p>Integer limiting the number of cells and the number or rows returned</p> <code>None</code> <code>skip</code> <code>int</code> <p>Integer limiting the number of cells and the number or rows returned</p> <code>None</code> <code>skip_contexts</code> <code>bool</code> <code>False</code> <code>skip_zeros</code> <code>bool</code> <p>skip zeros in cellset (irrespective of zero suppression in MDX / view)</p> <code>False</code> <code>skip_consolidated_cells</code> <code>bool</code> <p>skip consolidated cells in cellset</p> <code>False</code> <code>skip_rule_derived_cells</code> <code>bool</code> <p>skip rule derived cells in cellset</p> <code>False</code> <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <code>include_hierarchies</code> <code>bool</code> <p>retrieve Hierarchies property on Axes</p> <code>False</code> <code>use_compact_json</code> <code>bool</code> <p>bool</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict</code> <p>Raw format from TM1.</p> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>@tidy_cellset\ndef extract_cellset_raw(\n    self,\n    cellset_id: str,\n    cell_properties: Iterable[str] = None,\n    elem_properties: Iterable[str] = None,\n    member_properties: Iterable[str] = None,\n    top: int = None,\n    skip: int = None,\n    skip_contexts: bool = False,\n    skip_zeros: bool = False,\n    skip_consolidated_cells: bool = False,\n    skip_rule_derived_cells: bool = False,\n    sandbox_name: str = None,\n    include_hierarchies: bool = False,\n    use_compact_json: bool = False,\n    **kwargs,\n) -&gt; Dict:\n    \"\"\"Extract full cellset data and return the raw data from TM1\n\n    :param cellset_id: String; ID of existing cellset\n    :param cell_properties: List of properties to be queried from cells. E.g. ['Value', 'RuleDerived', ...]\n    :param elem_properties: List of properties to be queried from elements. E.g. ['UniqueName','Attributes', ...]\n    :param member_properties: List properties to be queried from the member. E.g. ['Name', 'UniqueName']\n    :param top: Integer limiting the number of cells and the number or rows returned\n    :param skip: Integer limiting the number of cells and the number or rows returned\n    :param skip_contexts:\n    :param skip_zeros: skip zeros in cellset (irrespective of zero suppression in MDX / view)\n    :param skip_consolidated_cells: skip consolidated cells in cellset\n    :param skip_rule_derived_cells: skip rule derived cells in cellset\n    :param sandbox_name: str\n    :param include_hierarchies: retrieve Hierarchies property on Axes\n    :param use_compact_json: bool\n    :return: Raw format from TM1.\n    \"\"\"\n    if not use_compact_json:\n        cellset_response = self.extract_cellset_raw_response(\n            cellset_id,\n            cell_properties,\n            elem_properties,\n            member_properties,\n            top,\n            skip,\n            skip_contexts,\n            skip_zeros,\n            skip_consolidated_cells,\n            skip_rule_derived_cells,\n            sandbox_name,\n            include_hierarchies,\n            **kwargs,\n        )\n\n        return cellset_response.json()\n\n    metadata = self.extract_cellset_metadata_raw(\n        cellset_id=cellset_id,\n        elem_properties=elem_properties,\n        member_properties=member_properties,\n        top=top,\n        skip=skip,\n        skip_contexts=skip_contexts,\n        include_hierarchies=include_hierarchies,\n        sandbox_name=sandbox_name,\n        **{**kwargs, \"delete_cellset\": False},\n    )\n    cells = self.extract_cellset_cells_raw(\n        cellset_id=cellset_id,\n        cell_properties=cell_properties,\n        top=top,\n        skip=skip,\n        skip_zeros=skip_zeros,\n        skip_consolidated_cells=skip_consolidated_cells,\n        skip_rule_derived_cells=skip_rule_derived_cells,\n        sandbox_name=sandbox_name,\n        use_compact_json=use_compact_json,\n        **kwargs,\n    )\n\n    # Combine metadata and cells back into a single object\n    return {**metadata, **cells}\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.extract_cellset_raw_response","title":"<code>extract_cellset_raw_response(cellset_id, cell_properties=None, elem_properties=None, member_properties=None, top=None, skip=None, skip_contexts=False, skip_zeros=False, skip_consolidated_cells=False, skip_rule_derived_cells=False, sandbox_name=None, include_hierarchies=False, **kwargs)</code>","text":"<p>Extract full cellset data and return the raw data from TM1</p> <p>Parameters:</p> Name Type Description Default <code>cellset_id</code> <code>str</code> <p>String; ID of existing cellset</p> required <code>cell_properties</code> <code>Iterable[str]</code> <p>List of properties to be queried from cells. E.g. ['Value', 'RuleDerived', ...]</p> <code>None</code> <code>elem_properties</code> <code>Iterable[str]</code> <p>List of properties to be queried from elements. E.g. ['UniqueName','Attributes', ...]</p> <code>None</code> <code>member_properties</code> <code>Iterable[str]</code> <p>List properties to be queried from the member. E.g. ['Name', 'UniqueName']</p> <code>None</code> <code>top</code> <code>int</code> <p>Integer limiting the number of cells and the number or rows returned</p> <code>None</code> <code>skip</code> <code>int</code> <p>Integer limiting the number of cells and the number or rows returned</p> <code>None</code> <code>skip_contexts</code> <code>bool</code> <code>False</code> <code>skip_zeros</code> <code>bool</code> <p>skip zeros in cellset (irrespective of zero suppression in MDX / view)</p> <code>False</code> <code>skip_consolidated_cells</code> <code>bool</code> <p>skip consolidated cells in cellset</p> <code>False</code> <code>skip_rule_derived_cells</code> <code>bool</code> <p>skip rule derived cells in cellset</p> <code>False</code> <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <code>include_hierarchies</code> <code>bool</code> <p>retrieve Hierarchies property on Axes</p> <code>False</code> <p>Returns:</p> Type Description <code>Response</code> <p>Raw format from TM1.</p> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def extract_cellset_raw_response(\n    self,\n    cellset_id: str,\n    cell_properties: Iterable[str] = None,\n    elem_properties: Iterable[str] = None,\n    member_properties: Iterable[str] = None,\n    top: int = None,\n    skip: int = None,\n    skip_contexts: bool = False,\n    skip_zeros: bool = False,\n    skip_consolidated_cells: bool = False,\n    skip_rule_derived_cells: bool = False,\n    sandbox_name: str = None,\n    include_hierarchies: bool = False,\n    **kwargs,\n) -&gt; Response:\n    \"\"\"Extract full cellset data and return the raw data from TM1\n\n    :param cellset_id: String; ID of existing cellset\n    :param cell_properties: List of properties to be queried from cells. E.g. ['Value', 'RuleDerived', ...]\n    :param elem_properties: List of properties to be queried from elements. E.g. ['UniqueName','Attributes', ...]\n    :param member_properties: List properties to be queried from the member. E.g. ['Name', 'UniqueName']\n    :param top: Integer limiting the number of cells and the number or rows returned\n    :param skip: Integer limiting the number of cells and the number or rows returned\n    :param skip_contexts:\n    :param skip_zeros: skip zeros in cellset (irrespective of zero suppression in MDX / view)\n    :param skip_consolidated_cells: skip consolidated cells in cellset\n    :param skip_rule_derived_cells: skip rule derived cells in cellset\n    :param sandbox_name: str\n    :param include_hierarchies: retrieve Hierarchies property on Axes\n    :return: Raw format from TM1.\n    \"\"\"\n    if not cell_properties:\n        cell_properties = [\"Value\"]\n\n    if skip_rule_derived_cells:\n        cell_properties.append(\"RuleDerived\")\n        # necessary due to bug in TM1 11.8: If only RuleDerived is retrieved it occasionally produces wrong results\n        cell_properties.append(\"Updateable\")\n\n    if skip_consolidated_cells:\n        cell_properties.append(\"Consolidated\")\n\n    if skip or skip_zeros or skip_rule_derived_cells or skip_consolidated_cells:\n        if \"Ordinal\" not in cell_properties:\n            cell_properties.append(\"Ordinal\")\n\n    # select Name property if member_properties is None or empty.\n    # Necessary, as tm1 default behaviour is to return all properties if no $select is specified in the request.\n    if member_properties is None or len(list(member_properties)) == 0:\n        member_properties = [\"Name\"]\n    select_member_properties = \"$select={}\".format(\",\".join(member_properties))\n\n    expand_elem_properties = (\n        \";$expand=Element($select={elem_properties})\".format(elem_properties=\",\".join(elem_properties))\n        if elem_properties is not None and len(list(elem_properties)) &gt; 0\n        else \"\"\n    )\n\n    filter_axis = \"$filter=Ordinal ne 2;\" if skip_contexts else \"\"\n\n    filter_cells = \"\"\n    if skip_zeros or skip_consolidated_cells or skip_rule_derived_cells:\n        filters = []\n        if skip_zeros:\n            filters.append(\"Value ne 0 and Value ne null and Value ne ''\")\n        if skip_consolidated_cells:\n            filters.append(\"Consolidated eq false\")\n        if skip_rule_derived_cells:\n            filters.append(\"RuleDerived eq false\")\n\n        filter_cells = \" and \".join(filters)\n\n    if include_hierarchies:\n        expand_hierarchies = \"Hierarchies($select=Name;$expand=Dimension($select=Name)),\"\n    else:\n        expand_hierarchies = \"\"\n\n    # top_tuples parameter is used as an optimization trick:\n    # if top_cells is set to N =&gt; it will be sufficient to get only the first N tuples in Axes, top_tuples does this\n    # if skip_cells is used =&gt; trick not applicable, all tuples must be extracted\n\n    url = (\n        \"/Cellsets('{cellset_id}')?$expand=\"\n        \"Cube($select=Name;$expand=Dimensions($select=Name)),\"\n        \"Axes({filter_axis}$expand={hierarchies}Tuples($expand=Members({select_member_properties}\"\n        \"{expand_elem_properties}){top_tuples})),\"\n        \"Cells($select={cell_properties}{top_cells}{skip_cells}{filter_cells})\".format(\n            cellset_id=cellset_id,\n            top_tuples=f\";$top={top}\" if top and not skip else \"\",\n            cell_properties=\",\".join(cell_properties),\n            filter_axis=filter_axis,\n            hierarchies=expand_hierarchies,\n            select_member_properties=select_member_properties,\n            expand_elem_properties=expand_elem_properties,\n            top_cells=f\";$top={top}\" if top else \"\",\n            skip_cells=f\";$skip={skip}\" if skip else \"\",\n            filter_cells=f\";$filter={filter_cells}\" if filter_cells else \"\",\n        )\n    )\n    url = add_url_parameters(url, **{\"!sandbox\": sandbox_name})\n    response = self._rest.GET(url=url, **kwargs)\n    return response\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.extract_cellset_rows_and_values","title":"<code>extract_cellset_rows_and_values(cellset_id, element_unique_names=True, sandbox_name=None, **kwargs)</code>","text":"<p>Retrieve row element names and values in a case and space insensitive dictionary</p> <p>Parameters:</p> Name Type Description Default <code>cellset_id</code> <code>str</code> required <code>element_unique_names</code> <code>bool</code> <code>True</code> <code>kwargs</code> <code>{}</code> <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <p>Returns:</p> Type Description <code>CaseAndSpaceInsensitiveTuplesDict</code> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>@tidy_cellset\ndef extract_cellset_rows_and_values(\n    self, cellset_id: str, element_unique_names: bool = True, sandbox_name: str = None, **kwargs\n) -&gt; CaseAndSpaceInsensitiveTuplesDict:\n    \"\"\"Retrieve row element names and values in a case and space insensitive dictionary\n\n    :param cellset_id:\n    :param element_unique_names:\n    :param kwargs:\n    :param sandbox_name: str\n    :return:\n    \"\"\"\n    url = (\n        \"/Cellsets('{}')?$expand=\"\n        \"Axes($filter=Ordinal eq 1;$expand=Tuples(\"\n        \"$expand=Members($select=Element;$expand=Element($select={})))),\"\n        \"Cells($select=Value)\".format(cellset_id, \"UniqueName\" if element_unique_names else \"Name\")\n    )\n    url = add_url_parameters(url, **{\"!sandbox\": sandbox_name})\n    response = self._rest.GET(url=url, **kwargs)\n    response_json = response.json()\n    rows = response_json[\"Axes\"][0][\"Tuples\"]\n    cell_values = [cell[\"Value\"] for cell in response_json[\"Cells\"]]\n\n    result = CaseAndSpaceInsensitiveTuplesDict()\n\n    number_rows = len(rows)\n    # avoid division by zero\n    if not number_rows:\n        return result\n    number_cells = len(cell_values)\n    number_columns = int(number_cells / number_rows)\n\n    cell_values_by_row = [\n        cell_values[cell_counter : cell_counter + number_columns]\n        for cell_counter in range(0, number_cells, number_columns)\n    ]\n    element_names_by_row = [\n        tuple(member[\"Element\"][\"UniqueName\" if element_unique_names else \"Name\"] for member in tupl[\"Members\"])\n        for tupl in rows\n    ]\n    for element_tuple, cells in zip(element_names_by_row, cell_values_by_row):\n        result[element_tuple] = cells\n    return result\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.extract_cellset_values","title":"<code>extract_cellset_values(cellset_id, sandbox_name=None, use_compact_json=False, skip_zeros=False, skip_consolidated_cells=False, skip_rule_derived_cells=False, **kwargs)</code>","text":"<p>Extract cellset data and return only the cells and values</p> <p>Parameters:</p> Name Type Description Default <code>cellset_id</code> <code>str</code> <p>String; ID of existing cellset</p> required <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <code>use_compact_json</code> <code>bool</code> <p>bool</p> <code>False</code> <code>skip_zeros</code> <code>bool</code> <p>bool</p> <code>False</code> <code>skip_consolidated_cells</code> <code>bool</code> <p>bool</p> <code>False</code> <code>skip_rule_derived_cells</code> <code>bool</code> <p>bool</p> <code>False</code> <p>Returns:</p> Type Description <code>List[Union[str, float]]</code> <p>Raw format from TM1.</p> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>@tidy_cellset\n@odata_compact_json(return_as_dict=False)\ndef extract_cellset_values(\n    self,\n    cellset_id: str,\n    sandbox_name: str = None,\n    use_compact_json: bool = False,\n    skip_zeros: bool = False,\n    skip_consolidated_cells: bool = False,\n    skip_rule_derived_cells: bool = False,\n    **kwargs,\n) -&gt; List[Union[str, float]]:\n    \"\"\"Extract cellset data and return only the cells and values\n\n    :param cellset_id: String; ID of existing cellset\n    :param sandbox_name: str\n    :param use_compact_json: bool\n    :param skip_zeros: bool\n    :param skip_consolidated_cells: bool\n    :param skip_rule_derived_cells: bool\n    :return: Raw format from TM1.\n    \"\"\"\n\n    filter_cells = \"\"\n    if skip_zeros or skip_consolidated_cells or skip_rule_derived_cells:\n        filters = []\n        if skip_zeros:\n            filters.append(\"Value ne 0 and Value ne null and Value ne ''\")\n        if skip_consolidated_cells:\n            filters.append(\"Consolidated eq false\")\n        if skip_rule_derived_cells:\n            filters.append(\"RuleDerived eq false\")\n\n        filter_cells = \" and \".join(filters)\n\n    url = format_url(\n        \"/Cellsets('{}')?$expand=Cells($select=Value{})\",\n        cellset_id,\n        f\";$filter={filter_cells}\" if filter_cells else \"\",\n    )\n    if sandbox_name:\n        url = add_url_parameters(url, **{\"!sandbox\": sandbox_name})\n    response = self._rest.GET(url=url, **kwargs)\n\n    if not use_compact_json:\n        return [cell[\"Value\"] for cell in response.json()[\"Cells\"]]\n\n    return response.json()\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.generate_enable_sandbox_ti","title":"<code>generate_enable_sandbox_ti(sandbox_name)</code>","text":"Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def generate_enable_sandbox_ti(self, sandbox_name):\n    if self._rest.sandboxing_disabled:\n        enable_sandbox = \"\"\n\n    elif sandbox_name:\n        if not self.sandbox_exists(sandbox_name):\n            raise ValueError(f\"Sandbox '{sandbox_name}' does not exist\")\n\n        enable_sandbox = f\"ServerActiveSandboxSet('{sandbox_name}');SetUseActiveSandboxProperty(1);\"\n\n    else:\n        enable_sandbox = \"ServerActiveSandboxSet('');SetUseActiveSandboxProperty(0);\"\n    return enable_sandbox\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.get_cellset_cells_count","title":"<code>get_cellset_cells_count(mdx)</code>","text":"<p>Execute MDX in order to understand how many cells are in a cellset</p> <p>Parameters:</p> Name Type Description Default <code>mdx</code> <code>str</code> <p>MDX Query, as string</p> required <p>Returns:</p> Type Description <code>int</code> <p>Number of Cells in the CellSet</p> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def get_cellset_cells_count(self, mdx: str) -&gt; int:\n    \"\"\"Execute MDX in order to understand how many cells are in a cellset\n\n    :param mdx: MDX Query, as string\n    :return: Number of Cells in the CellSet\n    \"\"\"\n    warnings.simplefilter(\"always\", PendingDeprecationWarning)\n    warnings.warn(\"Function deprecated. Use execute_mdx_cellcount(self, mdx) instead.\", PendingDeprecationWarning)\n    warnings.simplefilter(\"default\", PendingDeprecationWarning)\n    return self.execute_mdx_cellcount(mdx)\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.get_cube_service","title":"<code>get_cube_service()</code>","text":"Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def get_cube_service(self):\n    from TM1py import CubeService\n\n    return CubeService(self._rest)\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.get_dimension_names_for_writing","title":"<code>get_dimension_names_for_writing(cube_name, **kwargs)</code>","text":"<p>Get dimensions of a cube. Skip sandbox dimension</p> <p>Parameters:</p> Name Type Description Default <code>cube_name</code> <code>str</code> required <code>kwargs</code> <code>{}</code> <p>Returns:</p> Type Description <code>List[str]</code> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def get_dimension_names_for_writing(self, cube_name: str, **kwargs) -&gt; List[str]:\n    \"\"\"Get dimensions of a cube. Skip sandbox dimension\n\n    :param cube_name:\n    :param kwargs:\n    :return:\n    \"\"\"\n    from TM1py.Services import CubeService\n\n    cube_service = CubeService(self._rest)\n    dimensions = cube_service.get_dimension_names(cube_name, True, **kwargs)\n    return dimensions\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.get_element_service","title":"<code>get_element_service()</code>","text":"Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def get_element_service(self):\n    from TM1py import ElementService\n\n    return ElementService(self._rest)\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.get_elements_from_all_measure_hierarchies","title":"<code>get_elements_from_all_measure_hierarchies(cube_name)</code>","text":"Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def get_elements_from_all_measure_hierarchies(self, cube_name: str) -&gt; Dict[str, str]:\n    from TM1py.Services.CubeService import CubeService\n    from TM1py.Services.ElementService import ElementService\n\n    cube_service = CubeService(self._rest)\n    element_service = ElementService(self._rest)\n\n    measure_dimension = cube_service.get_measure_dimension(cube_name=cube_name)\n    return element_service.get_element_types_from_all_hierarchies(dimension_name=measure_dimension)\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.get_error_log_file_content","title":"<code>get_error_log_file_content(file_name, **kwargs)</code>","text":"Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def get_error_log_file_content(self, file_name: str, **kwargs) -&gt; str:\n    from TM1py import ProcessService\n\n    process_service = ProcessService(self._rest)\n\n    return process_service.get_error_log_file_content(file_name, **kwargs)\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.get_value","title":"<code>get_value(cube_name, elements=None, dimensions=None, sandbox_name=None, element_separator=',', hierarchy_separator='&amp;&amp;', hierarchy_element_separator='::', **kwargs)</code>","text":"<p>Returns cube value from specified coordinates</p> <p>Parameters:</p> Name Type Description Default <code>cube_name</code> <code>str</code> <p>Name of the cube</p> required <code>elements</code> <code>Union[str, Iterable]</code> <p>Describes the Dimension-Hierarchy-Element arrangement - Example: \"Hierarchy1::Element1 &amp;&amp; Hierarchy2::Element4, Element9, Element2\" - Dimensions are not specified! They are derived from the position. - The , separates the element-selections - If more than one hierarchy is selected per dimension &amp;&amp; splits the elementselections - If no Hierarchy is specified. Default Hierarchy will be addressed or Iterable of type mdxpy.Member or similar - Dimension names must be provided in this case! Example: [(Dimension1, Element1), (Dimension2, Element2), (Dimension3, Element3)] - Hierarchys can be included. Example: [(Dimension1, Hierarchy1, Element1), (Dimension1, Hierarchy2, Element2), (Dimension2, Element3)]</p> <code>None</code> <code>dimensions</code> <code>List[str]</code> <p>List of dimension names in correct order</p> <code>None</code> <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <code>element_separator</code> <code>str</code> <p>Alternative separator for the element selections</p> <code>','</code> <code>hierarchy_separator</code> <code>str</code> <p>Alternative separator for multiple hierarchies</p> <code>'&amp;&amp;'</code> <code>hierarchy_element_separator</code> <code>str</code> <p>Alternative separator between hierarchy name and element name</p> <code>'::'</code> <p>Returns:</p> Type Description <code>Union[str, float]</code> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def get_value(\n    self,\n    cube_name: str,\n    elements: Union[str, Iterable] = None,\n    dimensions: List[str] = None,\n    sandbox_name: str = None,\n    element_separator: str = \",\",\n    hierarchy_separator: str = \"&amp;&amp;\",\n    hierarchy_element_separator: str = \"::\",\n    **kwargs,\n) -&gt; Union[str, float]:\n    \"\"\"Returns cube value from specified coordinates\n\n    :param cube_name: Name of the cube\n    :param elements: Describes the Dimension-Hierarchy-Element arrangement\n        - Example: \"Hierarchy1::Element1 &amp;&amp; Hierarchy2::Element4, Element9, Element2\"\n        - Dimensions are not specified! They are derived from the position.\n        - The , separates the element-selections\n        - If more than one hierarchy is selected per dimension &amp;&amp; splits the elementselections\n        - If no Hierarchy is specified. Default Hierarchy will be addressed\n    or\n    Iterable of type mdxpy.Member or similar\n        - Dimension names must be provided in this case! Example: [(Dimension1, Element1), (Dimension2, Element2), (Dimension3, Element3)]\n        - Hierarchys can be included. Example: [(Dimension1, Hierarchy1, Element1), (Dimension1, Hierarchy2, Element2), (Dimension2, Element3)]\n    :param dimensions: List of dimension names in correct order\n    :param sandbox_name: str\n    :param element_separator: Alternative separator for the element selections\n    :param hierarchy_separator: Alternative separator for multiple hierarchies\n    :param hierarchy_element_separator: Alternative separator between hierarchy name and element name\n    :return:\n    \"\"\"\n    mdx_template = \"SELECT {} ON ROWS, {} ON COLUMNS FROM [{}]\"\n    mdx_strings_list = []\n\n    # Keep backward compatibility with the earlier used \"element_string\" parameter\n    if elements is None and \"element_string\" in kwargs:\n        elements = kwargs.pop(\"element_string\")\n\n    if not dimensions:\n        dimensions = self.get_dimension_names_for_writing(cube_name=cube_name)\n\n    # Create MDXpy Member from the element string and get the unique name\n    # The unique name can be used to build the MDX query directly\n    if isinstance(elements, str):\n        element_selections = elements.split(element_separator)\n        for dimension_name, element_selection in zip(dimensions, element_selections):\n            if hierarchy_separator not in element_selection:\n                if hierarchy_element_separator in element_selection:\n                    hierarchy_name, element_name = element_selection.split(hierarchy_element_separator)\n                else:\n                    hierarchy_name = dimension_name\n                    element_name = element_selection\n\n                element_definition = Member.of(dimension_name, hierarchy_name, element_name)\n                mdx_strings_list.append(\"{\" + element_definition.unique_name + \"}\")\n\n            else:\n                for element_selection_part in element_selection.split(hierarchy_separator):\n                    hierarchy_name, element_name = element_selection_part.split(hierarchy_element_separator)\n                    element_definition = Member.of(dimension_name, hierarchy_name, element_name)\n                    mdx_strings_list.append(\"{\" + element_definition.unique_name + \"}\")\n\n    else:\n        # Create MDXpy Member from the Iterator entries\n        for element_definition in elements:\n            if not isinstance(element_definition, Member):\n                element_definition = Member.of(*element_definition)\n            mdx_strings_list.append(\"{\" + element_definition.unique_name + \"}\")\n\n    # Build the MDX query\n    # Only the last element is used as the MDX ON COLUMN statement\n    mdx_rows = \"*\".join(mdx_strings_list[:-1])\n    mdx_columns = mdx_strings_list[-1]\n    mdx = mdx_template.format(mdx_rows, mdx_columns, cube_name)\n\n    # Execute MDX\n    cellset = dict(self.execute_mdx(mdx=mdx, sandbox_name=sandbox_name, **kwargs))\n    return next(iter(cellset.values()))[\"Value\"]\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.get_values","title":"<code>get_values(cube_name, element_sets=None, dimensions=None, sandbox_name=None, element_separator=',', hierarchy_separator='&amp;&amp;', hierarchy_element_separator='::', **kwargs)</code>","text":"<p>Returns list of cube values from specified coordinates list.  will be in same order as original list</p> <p>Parameters:</p> Name Type Description Default <code>cube_name</code> <code>str</code> <p>Name of the cube</p> required <code>element_sets</code> <code>Iterable[Iterable[str]]</code> <p>Set of coordinates where each element is provided in the correct dimension order. [('2024', 'Actual', 'London', 'P02), ('2024', 'Forecast', 'Berlin', 'P03)]</p> <code>None</code> <code>dimensions</code> <code>List[str]</code> <p>Dimension names in correct order</p> <code>None</code> <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <code>element_separator</code> <code>str</code> <p>Alternative separator for the element selections</p> <code>','</code> <code>hierarchy_separator</code> <code>str</code> <p>Alternative separator for multiple hierarchies</p> <code>'&amp;&amp;'</code> <code>hierarchy_element_separator</code> <code>str</code> <p>Alternative separator between hierarchy name and element name</p> <code>'::'</code> <p>Returns:</p> Type Description <code>List</code> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def get_values(\n    self,\n    cube_name: str,\n    element_sets: Iterable[Iterable[str]] = None,\n    dimensions: List[str] = None,\n    sandbox_name: str = None,\n    element_separator: str = \",\",\n    hierarchy_separator: str = \"&amp;&amp;\",\n    hierarchy_element_separator: str = \"::\",\n    **kwargs,\n) -&gt; List:\n    \"\"\"Returns list of cube values from specified coordinates list.  will be in same order as original list\n\n    :param cube_name: Name of the cube\n    :param element_sets: Set of coordinates where each element is provided in the correct dimension order.\n    [('2024', 'Actual', 'London', 'P02), ('2024', 'Forecast', 'Berlin', 'P03)]\n    :param dimensions: Dimension names in correct order\n    :param sandbox_name: str\n    :param element_separator: Alternative separator for the element selections\n    :param hierarchy_separator: Alternative separator for multiple hierarchies\n    :param hierarchy_element_separator: Alternative separator between hierarchy name and element name\n    :return:\n    \"\"\"\n\n    if not dimensions:\n        dimensions = self.get_dimension_names_for_writing(cube_name=cube_name)\n\n    q = MdxBuilder.from_cube(cube_name)\n\n    for elements in element_sets:\n        members = []\n        element_selections = elements.split(element_separator)\n        for dimension_name, element_selection in zip(dimensions, element_selections):\n            if hierarchy_separator not in element_selection:\n                if hierarchy_element_separator in element_selection:\n                    hierarchy_name, element_name = element_selection.split(hierarchy_element_separator)\n                else:\n                    hierarchy_name = dimension_name\n                    element_name = element_selection\n\n                member = Member.of(dimension_name, hierarchy_name, element_name)\n                members.append(member)\n            else:\n                for element_selection_part in element_selection.split(hierarchy_separator):\n                    hierarchy_name, element_name = element_selection_part.split(hierarchy_element_separator)\n                    member = Member.of(dimension_name, hierarchy_name, element_name)\n                    members.append(member)\n\n        q.add_member_tuple_to_columns(MdxTuple(members))\n\n    # Execute MDX\n    return self.execute_mdx_values(mdx=q.to_mdx(), sandbox_name=sandbox_name, **kwargs)\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.get_view_content","title":"<code>get_view_content(cube_name, view_name, cell_properties=None, private=False, top=None)</code>","text":"Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def get_view_content(\n    self,\n    cube_name: str,\n    view_name: str,\n    cell_properties: Iterable[str] = None,\n    private: bool = False,\n    top: int = None,\n):\n    warnings.simplefilter(\"always\", PendingDeprecationWarning)\n    warnings.warn(\"Function deprecated. Use execute_view instead.\", PendingDeprecationWarning)\n    warnings.simplefilter(\"default\", PendingDeprecationWarning)\n    return self.execute_view(cube_name, view_name, private, cell_properties, top)\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.relative_proportional_spread","title":"<code>relative_proportional_spread(value, cube, unique_element_names, reference_unique_element_names, reference_cube=None, sandbox_name=None, **kwargs)</code>","text":"<p>Execute relative proportional spread</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>value to be spread</p> required <code>cube</code> <code>str</code> <p>name of the cube</p> required <code>unique_element_names</code> <code>Iterable[str]</code> <p>target cell coordinates as unique element names (e.g. [\"[d1].[c1]\",\"[d2].[e3]\"])</p> required <code>reference_cube</code> <code>str</code> <p>name of the reference cube. Can be None</p> <code>None</code> <code>reference_unique_element_names</code> <code>Iterable[str]</code> <p>reference cell coordinates as unique element names</p> required <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def relative_proportional_spread(\n    self,\n    value: float,\n    cube: str,\n    unique_element_names: Iterable[str],\n    reference_unique_element_names: Iterable[str],\n    reference_cube: str = None,\n    sandbox_name: str = None,\n    **kwargs,\n) -&gt; Response:\n    \"\"\"Execute relative proportional spread\n\n    :param value: value to be spread\n    :param cube: name of the cube\n    :param unique_element_names: target cell coordinates as unique element names (e.g. [\"[d1].[c1]\",\"[d2].[e3]\"])\n    :param reference_cube: name of the reference cube. Can be None\n    :param reference_unique_element_names: reference cell coordinates as unique element names\n    :param sandbox_name: str\n    :return:\n    \"\"\"\n    mdx = \"\"\"\n    SELECT\n    {{ {rows} }} ON 0\n    FROM [{cube}]\n    \"\"\".format(\n        rows=\"}*{\".join(unique_element_names), cube=cube\n    )\n    cellset_id = self.create_cellset(mdx=mdx, sandbox_name=sandbox_name, **kwargs)\n\n    payload = {\n        \"BeginOrdinal\": 0,\n        \"Value\": \"RP\" + str(value),\n        \"ReferenceCell@odata.bind\": list(),\n        \"ReferenceCube@odata.bind\": format_url(\"Cubes('{}')\", reference_cube if reference_cube else cube),\n    }\n    for unique_element_name in reference_unique_element_names:\n        payload[\"ReferenceCell@odata.bind\"].append(\n            format_url(\n                \"Dimensions('{}')/Hierarchies('{}')/Elements('{}')\",\n                *Utils.dimension_hierarchy_element_tuple_from_unique_name(unique_element_name),\n            )\n        )\n\n    return self._post_against_cellset(\n        cellset_id=cellset_id, payload=payload, delete_cellset=True, sandbox_name=sandbox_name, **kwargs\n    )\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.sandbox_exists","title":"<code>sandbox_exists(sandbox_name)</code>","text":"Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def sandbox_exists(self, sandbox_name) -&gt; bool:\n    sandbox_service = SandboxService(self._rest)\n    return sandbox_service.exists(sandbox_name)\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.trace_cell_calculation","title":"<code>trace_cell_calculation(cube_name, elements, dimensions=None, sandbox_name=None, depth=1, element_separator=',', hierarchy_separator='&amp;&amp;', hierarchy_element_separator='::', **kwargs)</code>","text":"<p>Trace cell calculation at specified coordinates</p> <p>Parameters:</p> Name Type Description Default <code>cube_name</code> <code>str</code> <p>name of the target cube</p> required <code>elements</code> <code>Union[Iterable, str]</code> <p>string \"Hierarchy1::Element1 &amp;&amp; Hierarchy2::Element4, Element9, Element2\" - Dimensions are not specified! They are derived from the position. - The , separates the element-selections - If more than one hierarchy is selected per dimension &amp;&amp; splits the elementselections - If no Hierarchy is specified. Default Hierarchy will be addressed or Iterable [Element1, Element2, Element3]</p> required <code>dimensions</code> <code>Iterable[str]</code> <p>optional. Dimension names in their natural order. Will speed up the execution!</p> <code>None</code> <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <code>depth</code> <code>int</code> <p>optional. Depth of the component trace that will be returned. Deeper traces take longer</p> <code>1</code> <code>element_separator</code> <code>str</code> <p>Alternative separator for the elements, if elements are passed as string</p> <code>','</code> <code>hierarchy_separator</code> <code>str</code> <p>Alternative separator for multiple hierarchies, if elements are passed as string</p> <code>'&amp;&amp;'</code> <code>hierarchy_element_separator</code> <code>str</code> <p>Alternative separator between hierarchy name and element name, if elements are passed as string</p> <code>'::'</code> <p>Returns:</p> Type Description <code>Dict</code> <p>trace json string</p> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def trace_cell_calculation(\n    self,\n    cube_name: str,\n    elements: Union[Iterable, str],\n    dimensions: Iterable[str] = None,\n    sandbox_name: str = None,\n    depth: int = 1,\n    element_separator: str = \",\",\n    hierarchy_separator: str = \"&amp;&amp;\",\n    hierarchy_element_separator: str = \"::\",\n    **kwargs,\n) -&gt; Dict:\n    \"\"\"Trace cell calculation at specified coordinates\n\n    :param cube_name: name of the target cube\n    :param elements:\n    string \"Hierarchy1::Element1 &amp;&amp; Hierarchy2::Element4, Element9, Element2\"\n        - Dimensions are not specified! They are derived from the position.\n        - The , separates the element-selections\n        - If more than one hierarchy is selected per dimension &amp;&amp; splits the elementselections\n        - If no Hierarchy is specified. Default Hierarchy will be addressed\n    or\n    Iterable [Element1, Element2, Element3]\n    :param dimensions: optional. Dimension names in their natural order. Will speed up the execution!\n    :param sandbox_name: str\n    :param depth: optional. Depth of the component trace that will be returned. Deeper traces take longer\n    :param element_separator: Alternative separator for the elements, if elements are passed as string\n    :param hierarchy_separator: Alternative separator for multiple hierarchies, if elements are passed as string\n    :param hierarchy_element_separator: Alternative separator between hierarchy name and element name, if elements are passed as string\n    :return: trace json string\n    \"\"\"\n\n    expand_query = \"\"\n    select_query = \"\"\n    if depth:\n        for x in range(1, depth + 1):\n            component_depth = \"/\".join([\"Components\"] * x)\n            components_tuple_cube = (\n                f\"{component_depth}/Tuple($select=Name, UniqueName, Type), {component_depth}/Cube($select=Name)\"\n            )\n            expand_query = \",\".join([expand_query, components_tuple_cube])\n\n            component_fields = f\"{component_depth}/Type, {component_depth}/Value, {component_depth}/Statements\"\n            select_query = \",\".join([select_query, component_fields])\n\n    url = format_url(\n        \"/Cubes('{}')/tm1.TraceCellCalculation?$select=Type,Value,Statements\"\n        \"{}&amp;$expand=Tuple($select=Name, UniqueName, Type) {}\",\n        cube_name,\n        select_query,\n        expand_query,\n    )\n\n    url = add_url_parameters(url, **{\"!sandbox\": sandbox_name})\n    if isinstance(elements, str):\n        body_as_dict = self._compose_odata_tuple_from_string(\n            cube_name, elements, dimensions, element_separator, hierarchy_separator, hierarchy_element_separator\n        )\n    else:\n        body_as_dict = self._compose_odata_tuple_from_iterable(cube_name, elements, dimensions)\n    data = json.dumps(body_as_dict, ensure_ascii=False)\n\n    return json.loads(self._rest.POST(url=url, data=data, **kwargs).content)\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.trace_cell_feeders","title":"<code>trace_cell_feeders(cube_name, elements, dimensions=None, sandbox_name=None, element_separator=',', hierarchy_separator='&amp;&amp;', hierarchy_element_separator='::', **kwargs)</code>","text":"<p>Trace feeders from a cell</p> <p>Parameters:</p> Name Type Description Default <code>cube_name</code> <code>str</code> <p>name of the target cube</p> required <code>elements</code> <code>Union[Iterable, str]</code> <p>string \"Hierarchy1::Element1 &amp;&amp; Hierarchy2::Element4, Element9, Element2\" - Dimensions are not specified! They are derived from the position. - The , separates the element-selections - If more than one hierarchy is selected per dimension &amp;&amp; splits the elementselections - If no Hierarchy is specified. Default Hierarchy will be addressed or Iterable [Element1, Element2, Element3]</p> required <code>dimensions</code> <code>Iterable[str]</code> <p>optional. Dimension names in their natural order. Will speed up the execution!</p> <code>None</code> <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <code>element_separator</code> <code>str</code> <p>Alternative separator for the elements, if elements are passed as string</p> <code>','</code> <code>hierarchy_separator</code> <code>str</code> <p>Alternative separator for multiple hierarchies, if elements are passed as string</p> <code>'&amp;&amp;'</code> <code>hierarchy_element_separator</code> <code>str</code> <p>Alternative separator between hierarchy name and element name, if elements are passed as string</p> <code>'::'</code> <p>Returns:</p> Type Description <code>Dict</code> <p>feeder trace</p> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def trace_cell_feeders(\n    self,\n    cube_name: str,\n    elements: Union[Iterable, str],\n    dimensions: Iterable[str] = None,\n    sandbox_name: str = None,\n    element_separator: str = \",\",\n    hierarchy_separator: str = \"&amp;&amp;\",\n    hierarchy_element_separator: str = \"::\",\n    **kwargs,\n) -&gt; Dict:\n    \"\"\"Trace feeders from a cell\n\n    :param cube_name: name of the target cube\n    :param elements:\n    string \"Hierarchy1::Element1 &amp;&amp; Hierarchy2::Element4, Element9, Element2\"\n        - Dimensions are not specified! They are derived from the position.\n        - The , separates the element-selections\n        - If more than one hierarchy is selected per dimension &amp;&amp; splits the elementselections\n        - If no Hierarchy is specified. Default Hierarchy will be addressed\n    or\n    Iterable [Element1, Element2, Element3]\n    :param dimensions: optional. Dimension names in their natural order. Will speed up the execution!\n    :param sandbox_name: str\n    :param element_separator: Alternative separator for the elements, if elements are passed as string\n    :param hierarchy_separator: Alternative separator for multiple hierarchies, if elements are passed as string\n    :param hierarchy_element_separator: Alternative separator between hierarchy name and element name, if elements are passed as string\n    :return: feeder trace\n    \"\"\"\n\n    url = format_url(\n        \"/Cubes('{}')/tm1.TraceFeeders?$select=Statements,FedCells\"\n        \"&amp;$expand=FedCells/Tuple($select=Name,UniqueName,Type), \"\n        \"FedCells/Cube($select=Name)\",\n        cube_name,\n    )\n\n    url = add_url_parameters(url, **{\"!sandbox\": sandbox_name})\n    if isinstance(elements, str):\n        body_as_dict = self._compose_odata_tuple_from_string(\n            cube_name, elements, dimensions, element_separator, hierarchy_separator, hierarchy_element_separator\n        )\n    else:\n        body_as_dict = self._compose_odata_tuple_from_iterable(cube_name, elements, dimensions)\n    data = json.dumps(body_as_dict, ensure_ascii=False)\n\n    return json.loads(self._rest.POST(url=url, data=data, **kwargs).content)\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.transaction_log_is_active","title":"<code>transaction_log_is_active(cube_name)</code>","text":"Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def transaction_log_is_active(self, cube_name: str) -&gt; bool:\n    mdx = f\"\"\"\n    SELECT {{[}}Cubes].[{cube_name}]}} ON 0, {{[}}CubeProperties].[LOGGING]}} ON 1 FROM [}}CubeProperties]\n    \"\"\"\n    values = self.execute_mdx_values(mdx)\n    return case_and_space_insensitive_equals(values[0], \"YES\")\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.undo_changeset","title":"<code>undo_changeset(changeset)</code>","text":"<p>undo a changeset. Similar to rolling back transactions.</p> <p>Returns:</p> Type Description <code>Response</code> <p>Change set ID</p> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def undo_changeset(self, changeset: str) -&gt; Response:\n    \"\"\"undo a changeset. Similar to rolling back transactions.\n\n    :return: Change set ID\n    \"\"\"\n\n    url = \"/UndoChangeSet\"\n    data = {\"ChangeSetID\": changeset}\n    return self._rest.POST(url, data=json.dumps(data, ensure_ascii=False))\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.update_cellset","title":"<code>update_cellset(cellset_id, values, sandbox_name=None, changeset=None, **kwargs)</code>","text":"<p>Write values into cellset</p> <p>Number of values must match the number of cells in the cellset</p> <p>Parameters:</p> Name Type Description Default <code>cellset_id</code> <code>str</code> required <code>values</code> <code>Iterable</code> <p>iterable with Numeric and String values</p> required <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <code>changeset</code> <code>str</code> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>@tidy_cellset\ndef update_cellset(\n    self, cellset_id: str, values: Iterable, sandbox_name: str = None, changeset: str = None, **kwargs\n) -&gt; Response:\n    \"\"\"Write values into cellset\n\n    Number of values must match the number of cells in the cellset\n\n    :param cellset_id:\n    :param values: iterable with Numeric and String values\n    :param sandbox_name: str\n    :param changeset:\n    :return:\n    \"\"\"\n\n    url = format_url(\"/Cellsets('{}')/Cells\", cellset_id)\n    url = add_url_parameters(url, **{\"!sandbox\": sandbox_name})\n    url = add_url_parameters(url, **{\"!ChangeSet\": changeset})\n    data = []\n    for o, value in enumerate(values):\n        data.append({\"Ordinal\": o, \"Value\": value})\n\n    return self._rest.PATCH(url, json.dumps(data, ensure_ascii=False), **kwargs)\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.write","title":"<code>write(cube_name, cellset_as_dict, dimensions=None, increment=False, deactivate_transaction_log=False, reactivate_transaction_log=False, sandbox_name=None, use_ti=False, use_blob=False, use_changeset=False, precision=None, skip_non_updateable=False, measure_dimension_elements=None, remove_blob=True, allow_spread=False, clear_view=None, **kwargs)</code>","text":"<p>Write values to a cube</p> <p>Same signature as <code>write_values</code> method, but faster since it uses <code>write_values_through_cellset</code> behind the scenes.</p> <p>Supports incrementing cell values through optional <code>increment</code> argument Spreading through spreading shortcuts is not supported!</p> <p>Parameters:</p> Name Type Description Default <code>cube_name</code> <code>str</code> <p>name of the cube</p> required <code>cellset_as_dict</code> <code>Dict</code> <p>{(elem_a, elem_b, elem_c): 243, (elem_d, elem_e, elem_f) : 109}</p> required <code>dimensions</code> <code>Iterable[str]</code> <p>optional. Dimension names in their natural order. Will speed up the execution!</p> <code>None</code> <code>increment</code> <code>bool</code> <p>increment or update cell values</p> <code>False</code> <code>deactivate_transaction_log</code> <code>bool</code> <p>deactivate before writing</p> <code>False</code> <code>reactivate_transaction_log</code> <code>bool</code> <p>reactivate after writing</p> <code>False</code> <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <code>use_ti</code> <code>bool</code> <p>Use unbound process to write. Requires admin permissions. causes massive performance improvement.</p> <code>False</code> <code>use_blob</code> <code>bool</code> <p>Uses blob to write. Requires admin permissions. 10x faster compared to use_ti</p> <code>False</code> <code>use_changeset</code> <code>bool</code> <p>Enable ChangesetID: True or False</p> <code>False</code> <code>precision</code> <code>int</code> <p>max precision when writhing through unbound process. Necessary when dealing with large numbers to avoid \"number too long\" TI syntax error.</p> <code>None</code> <code>skip_non_updateable</code> <code>bool</code> <p>skip cells that are not updateable (e.g. rule derived or consolidated)</p> <code>False</code> <code>measure_dimension_elements</code> <code>Dict</code> <p>dictionary of measure elements and their types to improve performance when <code>use_ti</code> is <code>True</code>. When all written values are numeric you can pass a default dict with default key 'Numeric'</p> <code>None</code> <code>remove_blob</code> <code>bool</code> <p>remove blob file after writing with use_blob=True</p> <code>True</code> <code>allow_spread</code> <code>bool</code> <p>allow TI process in use_blob or use_ti to use CellPutProportionalSpread on C elements</p> <code>False</code> <code>clear_view</code> <code>str</code> <p>name of cube view to clear before writing</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>changeset or None</p> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def write(\n    self,\n    cube_name: str,\n    cellset_as_dict: Dict,\n    dimensions: Iterable[str] = None,\n    increment: bool = False,\n    deactivate_transaction_log: bool = False,\n    reactivate_transaction_log: bool = False,\n    sandbox_name: str = None,\n    use_ti: bool = False,\n    use_blob: bool = False,\n    use_changeset: bool = False,\n    precision: int = None,\n    skip_non_updateable: bool = False,\n    measure_dimension_elements: Dict = None,\n    remove_blob: bool = True,\n    allow_spread: bool = False,\n    clear_view: str = None,\n    **kwargs,\n) -&gt; Optional[str]:\n    \"\"\"Write values to a cube\n\n    Same signature as `write_values` method, but faster since it uses `write_values_through_cellset`\n    behind the scenes.\n\n    Supports incrementing cell values through optional `increment` argument\n    Spreading through spreading shortcuts is not supported!\n\n    :param cube_name: name of the cube\n    :param cellset_as_dict: {(elem_a, elem_b, elem_c): 243, (elem_d, elem_e, elem_f) : 109}\n    :param dimensions: optional. Dimension names in their natural order. Will speed up the execution!\n    :param increment: increment or update cell values\n    :param deactivate_transaction_log: deactivate before writing\n    :param reactivate_transaction_log: reactivate after writing\n    :param sandbox_name: str\n    :param use_ti: Use unbound process to write. Requires admin permissions. causes massive performance improvement.\n    :param use_blob: Uses blob to write. Requires admin permissions. 10x faster compared to use_ti\n    :param use_changeset: Enable ChangesetID: True or False\n    :param precision: max precision when writhing through unbound process.\n    Necessary when dealing with large numbers to avoid \"number too long\" TI syntax error.\n    :param skip_non_updateable: skip cells that are not updateable (e.g. rule derived or consolidated)\n    :param measure_dimension_elements: dictionary of measure elements and their types to improve\n    performance when `use_ti` is `True`.\n    When all written values are numeric you can pass a default dict with default key 'Numeric'\n    :param remove_blob: remove blob file after writing with use_blob=True\n    :param allow_spread: allow TI process in use_blob or use_ti to use CellPutProportionalSpread on C elements\n    :param clear_view: name of cube view to clear before writing\n    :return: changeset or None\n    \"\"\"\n\n    if clear_view and not use_blob:\n        raise ValueError(\"'clear_view' can only be used in conjunction with 'use_blob'\")\n\n    if use_ti:\n        return self.write_through_unbound_process(\n            cube_name=cube_name,\n            cellset_as_dict=cellset_as_dict,\n            increment=increment,\n            sandbox_name=sandbox_name,\n            deactivate_transaction_log=deactivate_transaction_log,\n            reactivate_transaction_log=reactivate_transaction_log,\n            precision=precision,\n            skip_non_updateable=skip_non_updateable,\n            measure_dimension_elements=measure_dimension_elements,\n            dimensions=dimensions,\n            allow_spread=allow_spread,\n            **kwargs,\n        )\n\n    if use_blob:\n        return self.write_through_blob(\n            cube_name=cube_name,\n            cellset_as_dict=cellset_as_dict,\n            increment=increment,\n            sandbox_name=sandbox_name,\n            deactivate_transaction_log=deactivate_transaction_log,\n            reactivate_transaction_log=reactivate_transaction_log,\n            skip_non_updateable=skip_non_updateable,\n            dimensions=dimensions,\n            remove_blob=remove_blob,\n            allow_spread=allow_spread,\n            clear_view=clear_view,\n            **kwargs,\n        )\n\n    return self.write_through_cellset(\n        cube_name,\n        cellset_as_dict,\n        dimensions,\n        increment,\n        deactivate_transaction_log,\n        reactivate_transaction_log,\n        sandbox_name,\n        use_changeset,\n        skip_non_updateable,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.write_async","title":"<code>write_async(cube_name, cells, slice_size=250000, max_workers=8, dimensions=None, increment=False, deactivate_transaction_log=False, reactivate_transaction_log=False, sandbox_name=None, precision=None, measure_dimension_elements=None, **kwargs)</code>","text":"<p>Write asynchronously</p> <p>Parameters:</p> Name Type Description Default <code>cube_name</code> <code>str</code> required <code>cells</code> <code>Dict</code> required <code>slice_size</code> <code>int</code> <code>250000</code> <code>max_workers</code> <code>int</code> <code>8</code> <code>dimensions</code> <code>Iterable[str]</code> <code>None</code> <code>increment</code> <code>bool</code> <code>False</code> <code>deactivate_transaction_log</code> <code>bool</code> <code>False</code> <code>reactivate_transaction_log</code> <code>bool</code> <code>False</code> <code>sandbox_name</code> <code>str</code> <code>None</code> <code>precision</code> <code>int</code> <p>max precision when writhing through unbound process. Necessary to decrease when dealing with large numbers to avoid \"number too long\" TI syntax error.</p> <code>None</code> <code>measure_dimension_elements</code> <code>Dict</code> <p>dictionary of measure elements and their types to improve performance when <code>use_ti</code> is <code>True</code>.</p> <code>None</code> <code>kwargs</code> <code>{}</code> <p>Returns:</p> Type Description <code>Optional[str]</code> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>@manage_transaction_log\ndef write_async(\n    self,\n    cube_name: str,\n    cells: Dict,\n    slice_size: int = 250_000,\n    max_workers: int = 8,\n    dimensions: Iterable[str] = None,\n    increment: bool = False,\n    deactivate_transaction_log: bool = False,\n    reactivate_transaction_log: bool = False,\n    sandbox_name: str = None,\n    precision: int = None,\n    measure_dimension_elements: Dict = None,\n    **kwargs,\n) -&gt; Optional[str]:\n    \"\"\"Write asynchronously\n\n    :param cube_name:\n    :param cells:\n    :param slice_size:\n    :param max_workers:\n    :param dimensions:\n    :param increment:\n    :param deactivate_transaction_log:\n    :param reactivate_transaction_log:\n    :param sandbox_name:\n    :param precision: max precision when writhing through unbound process.\n    Necessary to decrease when dealing with large numbers to avoid \"number too long\" TI syntax error.\n    :param measure_dimension_elements: dictionary of measure elements and their types to improve\n    performance when `use_ti` is `True`.\n    :param kwargs:\n    :return:\n    \"\"\"\n\n    if not dimensions:\n        dimensions = self.get_dimension_names_for_writing(cube_name=cube_name)\n\n    if not measure_dimension_elements:\n        measure_dimension_elements = self.get_elements_from_all_measure_hierarchies(cube_name=cube_name)\n\n    def _chunks(data: Dict):\n        it = iter(data)\n        for _ in range(0, len(data), slice_size):\n            yield {k: data[k] for k in itertools.islice(it, slice_size)}\n\n    def _write(chunk: Dict):\n        return self.write(\n            cube_name=cube_name,\n            cellset_as_dict=chunk,\n            dimensions=dimensions,\n            increment=increment,\n            use_blob=True,\n            sandbox_name=sandbox_name,\n            precision=precision,\n            measure_dimension_elements=measure_dimension_elements,\n            **kwargs,\n        )\n\n    async def _write_async(data: Dict):\n        loop = asyncio.get_event_loop()\n        failures = []\n\n        with ThreadPoolExecutor(max_workers) as executor:\n            futures = [loop.run_in_executor(executor, _write, chunk) for chunk in _chunks(data)]\n\n            for future in futures:\n                try:\n                    await future\n                except (TM1pyWritePartialFailureException, TM1pyWriteFailureException) as exception:\n                    failures.append(exception)\n\n        return failures\n\n    exceptions = asyncio.run(_write_async(cells))\n    if not exceptions:\n        return\n\n    # merge all failures into one combined Exception\n    raise TM1pyWritePartialFailureException(\n        statuses=list(itertools.chain(*[exception.statuses for exception in exceptions])),\n        error_log_files=list(itertools.chain(*[exception.error_log_files for exception in exceptions])),\n        attempts=sum(\n            [\n                exception.attempts if isinstance(exception, TM1pyWritePartialFailureException) else 1\n                for exception in exceptions\n            ]\n        ),\n    )\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.write_dataframe","title":"<code>write_dataframe(cube_name, data, dimensions=None, increment=False, deactivate_transaction_log=False, reactivate_transaction_log=False, sandbox_name=None, use_ti=False, use_blob=False, use_changeset=False, precision=None, skip_non_updateable=False, measure_dimension_elements=None, sum_numeric_duplicates=True, remove_blob=True, allow_spread=False, clear_view=None, static_dimension_elements=None, infer_column_order=False, **kwargs)</code>","text":"<p>Function expects same shape as <code>execute_mdx_dataframe</code> returns. Column order must match dimensions in the target cube with an additional column for the values. Column names are not relevant.</p> <p>Parameters:</p> Name Type Description Default <code>cube_name</code> <code>str</code> required <code>data</code> <code>DataFrame</code> <p>Pandas Data Frame</p> required <code>dimensions</code> <code>Iterable[str]</code> <code>None</code> <code>increment</code> <code>bool</code> <code>False</code> <code>deactivate_transaction_log</code> <code>bool</code> <code>False</code> <code>reactivate_transaction_log</code> <code>bool</code> <code>False</code> <code>sandbox_name</code> <code>str</code> <code>None</code> <code>use_ti</code> <code>bool</code> <code>False</code> <code>use_blob</code> <code>bool</code> <p>Uses blob to write. Requires admin permissions. 10x faster compared to use_ti</p> <code>False</code> <code>use_changeset</code> <code>bool</code> <p>Enable ChangesetID: True or False</p> <code>False</code> <code>precision</code> <code>int</code> <p>max precision when writhing through unbound process. Necessary when dealing with large numbers to avoid \"number too long\" TI syntax error</p> <code>None</code> <code>skip_non_updateable</code> <code>bool</code> <p>skip cells that are not updateable (e.g. rule derived or consolidated)</p> <code>False</code> <code>measure_dimension_elements</code> <code>Dict</code> <p>dictionary of measure elements and their types to improve performance when <code>use_ti</code> is <code>True</code>. When all written values are numeric you can pass a default dict with default key 'Numeric'</p> <code>None</code> <code>sum_numeric_duplicates</code> <code>bool</code> <p>Aggregate numerical values for duplicated intersections</p> <code>True</code> <code>remove_blob</code> <code>bool</code> <p>remove blob file after writing with use_blob=True</p> <code>True</code> <code>allow_spread</code> <code>bool</code> <p>allow TI process in use_blob or use_ti to use CellPutProportionalSpread on C elements</p> <code>False</code> <code>clear_view</code> <code>str</code> <p>name of cube view to clear before writing</p> <code>None</code> <code>static_dimension_elements</code> <code>Dict</code> <p>Dict of fixed dimension element pairs. Column is created for you.</p> <code>None</code> <code>infer_column_order</code> <code>bool</code> <p>bool indicating whether the column order of the dataframe should automatically be inferred and mapped to the dimension order in the cube.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>changeset or None</p> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>@require_pandas\ndef write_dataframe(\n    self,\n    cube_name: str,\n    data: \"pd.DataFrame\",\n    dimensions: Iterable[str] = None,\n    increment: bool = False,\n    deactivate_transaction_log: bool = False,\n    reactivate_transaction_log: bool = False,\n    sandbox_name: str = None,\n    use_ti: bool = False,\n    use_blob: bool = False,\n    use_changeset: bool = False,\n    precision: int = None,\n    skip_non_updateable: bool = False,\n    measure_dimension_elements: Dict = None,\n    sum_numeric_duplicates: bool = True,\n    remove_blob: bool = True,\n    allow_spread: bool = False,\n    clear_view: str = None,\n    static_dimension_elements: Dict = None,\n    infer_column_order: bool = False,\n    **kwargs,\n) -&gt; str:\n    \"\"\"\n    Function expects same shape as `execute_mdx_dataframe` returns.\n    Column order must match dimensions in the target cube with an additional column for the values.\n    Column names are not relevant.\n    :param cube_name:\n    :param data: Pandas Data Frame\n    :param dimensions:\n    :param increment:\n    :param deactivate_transaction_log:\n    :param reactivate_transaction_log:\n    :param sandbox_name:\n    :param use_ti:\n    :param use_blob: Uses blob to write. Requires admin permissions. 10x faster compared to use_ti\n    :param use_changeset: Enable ChangesetID: True or False\n    :param precision: max precision when writhing through unbound process.\n        Necessary when dealing with large numbers to avoid \"number too long\" TI syntax error\n    :param skip_non_updateable: skip cells that are not updateable (e.g. rule derived or consolidated)\n    :param measure_dimension_elements: dictionary of measure elements and their types to improve\n        performance when `use_ti` is `True`.\n        When all written values are numeric you can pass a default dict with default key 'Numeric'\n    :param sum_numeric_duplicates: Aggregate numerical values for duplicated intersections\n    :param remove_blob: remove blob file after writing with use_blob=True\n    :param allow_spread: allow TI process in use_blob or use_ti to use CellPutProportionalSpread on C elements\n    :param clear_view: name of cube view to clear before writing\n    :param static_dimension_elements: Dict of fixed dimension element pairs. Column is created for you.\n    :param infer_column_order: bool indicating whether the column order of the dataframe should automatically be\n        inferred and mapped to the dimension order in the cube.\n    :return: changeset or None\n    \"\"\"\n    if not isinstance(data, pd.DataFrame):\n        raise ValueError(\"argument 'data' must of type DataFrame\")\n\n    # don't mutate passed data frame. Work on a copy instead\n    data = data.copy()\n\n    if not dimensions:\n        dimensions = self.get_dimension_names_for_writing(cube_name=cube_name)\n\n    infer_column_order = True if static_dimension_elements else infer_column_order\n\n    # reorder columns in df to align with dimensions; CaseAndSpaceInsensitiveDict is a OrderedDict\n    if static_dimension_elements:\n        for dimension, element in static_dimension_elements.items():\n            if dimension in CaseAndSpaceInsensitiveSet(data.columns):\n                raise ValueError(\n                    \"one or more of the fixed_dimension_elements are passed as a dataframe column. \"\n                    f\"{dimension}: {element} is passed in fixed_dimension_elements. \"\n                    \"Either remove the key value pair from the fixed_dimension_elements dict or \"\n                    f\"avoid passing the {dimension} column in the dataframe.\"\n                )\n            data[dimension] = element\n\n    if infer_column_order:\n        data.columns = data.columns.map(lower_and_drop_spaces)\n\n        ordered_columns = list(map(lower_and_drop_spaces, dimensions))\n\n        columns_not_in_dimensions = data.columns.difference(ordered_columns).tolist()\n\n        data = data[ordered_columns + columns_not_in_dimensions]\n\n    if not len(data.columns) == len(dimensions) + 1:\n        raise ValueError(\"Number of columns in 'data' DataFrame must be number of dimensions in cube + 1\")\n\n    cells = build_cellset_from_pandas_dataframe(data, sum_numeric_duplicates=sum_numeric_duplicates)\n\n    return self.write(\n        cube_name=cube_name,\n        cellset_as_dict=cells,\n        dimensions=dimensions,\n        increment=increment,\n        deactivate_transaction_log=deactivate_transaction_log,\n        reactivate_transaction_log=reactivate_transaction_log,\n        sandbox_name=sandbox_name,\n        use_ti=use_ti,\n        use_blob=use_blob,\n        remove_blob=remove_blob,\n        use_changeset=use_changeset,\n        precision=precision,\n        skip_non_updateable=skip_non_updateable,\n        measure_dimension_elements=measure_dimension_elements,\n        allow_spread=allow_spread,\n        clear_view=clear_view,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.write_dataframe_async","title":"<code>write_dataframe_async(cube_name, data, slice_size_of_dataframe=250000, max_workers=8, dimensions=None, increment=True, sandbox_name=None, deactivate_transaction_log=False, reactivate_transaction_log=False, **kwargs)</code>","text":"<p>Write DataFrame into a cube using unbound TI processes in a multi-threading way. Requires admin permissions. For a DataFrame with &gt; 1,000,000 rows, this function will at least save half of runtime compared with <code>write_dataframe</code> function. Column order must match dimensions in the target cube with an additional column for the values. Column names are not relevant.</p> <p>Parameters:</p> Name Type Description Default <code>cube_name</code> <code>str</code> required <code>data</code> <code>DataFrame</code> <p>Pandas Data Frame</p> required <code>slice_size_of_dataframe</code> <code>int</code> <p>Number of rows for each DataFrame slice, e.g. 10000</p> <code>250000</code> <code>max_workers</code> <code>int</code> <p>Max number of threads, e.g. 14</p> <code>8</code> <code>dimensions</code> <code>Iterable[str]</code> <code>None</code> <code>increment</code> <code>bool</code> <p>increment or update cell values. Defaults to True.</p> <code>True</code> <code>sandbox_name</code> <code>str</code> <p>name of the sandbox or None</p> <code>None</code> <code>deactivate_transaction_log</code> <code>bool</code> <code>False</code> <code>reactivate_transaction_log</code> <code>bool</code> <code>False</code> <p>Returns:</p> Type Description <p>the Future\u2019s result or raise exception.</p> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>@require_pandas\n@manage_transaction_log\ndef write_dataframe_async(\n    self,\n    cube_name: str,\n    data: \"pd.DataFrame\",\n    slice_size_of_dataframe: int = 250_000,\n    max_workers: int = 8,\n    dimensions: Iterable[str] = None,\n    increment: bool = True,\n    sandbox_name: str = None,\n    deactivate_transaction_log: bool = False,\n    reactivate_transaction_log: bool = False,\n    **kwargs,\n):\n    \"\"\"Write DataFrame into a cube using unbound TI processes in a multi-threading way. Requires admin permissions.\n    For a DataFrame with &gt; 1,000,000 rows, this function will at least save half of runtime compared with `write_dataframe` function.\n    Column order must match dimensions in the target cube with an additional column for the values.\n    Column names are not relevant.\n    :param cube_name:\n    :param data: Pandas Data Frame\n    :param slice_size_of_dataframe: Number of rows for each DataFrame slice, e.g. 10000\n    :param max_workers: Max number of threads, e.g. 14\n    :param dimensions:\n    :param increment: increment or update cell values. Defaults to True.\n    :param sandbox_name: name of the sandbox or None\n    :param deactivate_transaction_log:\n    :param reactivate_transaction_log:\n    :return: the Future\u2019s result or raise exception.\n    \"\"\"\n    if not isinstance(data, pd.DataFrame):\n        raise ValueError(\"argument 'data' must of type DataFrame\")\n\n    if not dimensions:\n        dimensions = self.get_dimension_names_for_writing(cube_name=cube_name)\n\n    if not len(data.columns) == len(dimensions) + 1:\n        raise ValueError(\"Number of columns in 'data' DataFrame must be number of dimensions in cube + 1\")\n\n    def _chunks(df: \"pd.DataFrame\"):\n        return [df.iloc[i : i + slice_size_of_dataframe] for i in range(0, df.shape[0], slice_size_of_dataframe)]\n\n    def _write(chunk: \"pd.DataFrame\"):\n        return self.write_dataframe(\n            cube_name=cube_name,\n            data=chunk,\n            dimensions=dimensions,\n            increment=increment,\n            use_blob=True,\n            sandbox_name=sandbox_name,\n            **kwargs,\n        )\n\n    async def _write_async(df: \"pd.DataFrame\"):\n        loop = asyncio.get_event_loop()\n        failures = []\n\n        with ThreadPoolExecutor(max_workers) as executor:\n            futures = [loop.run_in_executor(executor, _write, chunk) for chunk in _chunks(df)]\n\n            for future in futures:\n                try:\n                    await future\n                except (TM1pyWritePartialFailureException, TM1pyWriteFailureException) as exception:\n                    failures.append(exception)\n\n        return failures\n\n    if increment:\n        data = build_dataframe_aggregate_intersections(data, sum_numeric_duplicates=True)\n\n    exceptions = asyncio.run(_write_async(data))\n    if not exceptions:\n        return\n\n    # merge all failures into one combined Exception\n    raise TM1pyWritePartialFailureException(\n        statuses=list(itertools.chain(*[exception.statuses for exception in exceptions])),\n        error_log_files=list(itertools.chain(*[exception.error_log_files for exception in exceptions])),\n        attempts=sum([exception.attempts if hasattr(exception, \"attempts\") else 1 for exception in exceptions]),\n    )\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.write_through_blob","title":"<code>write_through_blob(cube_name, cellset_as_dict, increment=False, sandbox_name=None, skip_non_updateable=False, remove_blob=True, dimensions=None, allow_spread=False, clear_view=None, **kwargs)</code>","text":"<p>Writes data back to TM1 via an unbound TI process having an uploaded CSV as data source</p> <p>Parameters:</p> Name Type Description Default <code>cube_name</code> <code>str</code> <p>str</p> required <code>cellset_as_dict</code> <code>dict</code> required <code>increment</code> <code>bool</code> <p>increment or update cell values</p> <code>False</code> <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <code>skip_non_updateable</code> <code>bool</code> <p>skip cells that are not updateable (e.g. rule derived or consolidated)</p> <code>False</code> <code>remove_blob</code> <p>choose False to persist blob after write. Can be helpful for troubleshooting.</p> <code>True</code> <code>dimensions</code> <code>str</code> <p>optional. Dimension names in their natural order. Will speed up the execution!</p> <code>None</code> <code>allow_spread</code> <code>bool</code> <p>allow TI process in use_blob or use_ti to use CellPutProportionalSpread on C elements.</p> <code>False</code> <code>clear_view</code> <code>str</code> <p>name of cube view to clear before writing</p> <code>None</code> <code>kwargs</code> <p>Additional arguments for the REST request</p> <code>{}</code> <p>Returns:</p> Type Description <p>Success: bool, Messages: list, ChangeSet: None</p> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>@require_data_admin\n@require_ops_admin\n@manage_transaction_log\n@require_pandas\ndef write_through_blob(\n    self,\n    cube_name: str,\n    cellset_as_dict: dict,\n    increment: bool = False,\n    sandbox_name: str = None,\n    skip_non_updateable: bool = False,\n    remove_blob=True,\n    dimensions: str = None,\n    allow_spread: bool = False,\n    clear_view: str = None,\n    **kwargs,\n):\n    \"\"\"\n    Writes data back to TM1 via an unbound TI process having an uploaded CSV as data source\n    :param cube_name: str\n    :param cellset_as_dict:\n    :param increment: increment or update cell values\n    :param sandbox_name: str\n    :param skip_non_updateable: skip cells that are not updateable (e.g. rule derived or consolidated)\n    :param remove_blob: choose False to persist blob after write. Can be helpful for troubleshooting.\n    :param dimensions: optional. Dimension names in their natural order. Will speed up the execution!\n    :param allow_spread: allow TI process in use_blob or use_ti to use CellPutProportionalSpread on C elements.\n    :param clear_view: name of cube view to clear before writing\n    :param kwargs: Additional arguments for the REST request\n    :return: Success: bool, Messages: list, ChangeSet: None\n    \"\"\"\n\n    process_service = ProcessService(self._rest)\n    cube_service = self.get_cube_service()\n    file_service = FileService(self._rest)\n\n    unique_name = self.suggest_unique_object_name()\n\n    # Transform cells to format that's consumable for TI\n    csv_content = StringIO()\n    csv_writer = csv.writer(csv_content, delimiter=\",\", quoting=csv.QUOTE_ALL)\n    csv_writer.writerows(\n        list(elements) + [value.replace(\"\\r\", \"\").replace(\"\\n\", \"\") if isinstance(value, str) else value]\n        for elements, value in cellset_as_dict.items()\n    )\n\n    file_name = f\"{unique_name}.csv\"\n    file_service.create(file_name=file_name, file_content=csv_content.getvalue().encode(\"utf-8\"), **kwargs)\n\n    try:\n        # Create and execute unbound TI process to load blob file to cube\n        process = self._build_blob_to_cube_process(\n            cube_name=cube_name,\n            process_name=unique_name,\n            blob_filename=file_name,\n            dimensions=dimensions or cube_service.get_dimension_names(cube_name),\n            increment=increment,\n            skip_non_updateable=skip_non_updateable,\n            sandbox_name=sandbox_name,\n            allow_spread=allow_spread,\n            clear_view=clear_view,\n        )\n\n        success, status, log_file = process_service.execute_process_with_return(process=process, **kwargs)\n        if not success:\n            if status in [\"HasMinorErrors\"]:\n                raise TM1pyWritePartialFailureException([status], [log_file], 1)\n            else:\n                raise TM1pyWriteFailureException([status], [log_file])\n\n    finally:\n        if remove_blob:\n            file_service.delete(file_name=file_name)\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.write_through_cellset","title":"<code>write_through_cellset(cube_name, cellset_as_dict, dimensions=None, increment=False, deactivate_transaction_log=False, reactivate_transaction_log=False, sandbox_name=None, use_changeset=False, skip_non_updateable=False, **kwargs)</code>","text":"Source code in <code>TM1py/Services/CellService.py</code> <pre><code>def write_through_cellset(\n    self,\n    cube_name: str,\n    cellset_as_dict: Dict,\n    dimensions: Iterable[str] = None,\n    increment: bool = False,\n    deactivate_transaction_log: bool = False,\n    reactivate_transaction_log: bool = False,\n    sandbox_name: str = None,\n    use_changeset: bool = False,\n    skip_non_updateable: bool = False,\n    **kwargs,\n) -&gt; str:\n    if not dimensions:\n        dimensions = self.get_dimension_names_for_writing(cube_name=cube_name, **kwargs)\n\n    if skip_non_updateable:\n        cellset_as_dict = self.drop_non_updateable_cells(cellset_as_dict, cube_name, dimensions)\n\n    if cellset_as_dict:\n        mdx, values = build_mdx_and_values_from_cellset(cellset_as_dict, cube_name, dimensions)\n        return self.write_values_through_cellset(\n            mdx=mdx,\n            values=values,\n            increment=increment,\n            deactivate_transaction_log=deactivate_transaction_log,\n            reactivate_transaction_log=reactivate_transaction_log,\n            sandbox_name=sandbox_name,\n            use_changeset=use_changeset,\n            **kwargs,\n        )\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.write_through_unbound_process","title":"<code>write_through_unbound_process(cube_name, cellset_as_dict, increment=False, sandbox_name=None, precision=None, skip_non_updateable=False, measure_dimension_elements=None, is_attribute_cube=None, dimensions=None, allow_spread=False, **kwargs)</code>","text":"<p>Writes data back to TM1 via an unbound TI process</p> <p>Parameters:</p> Name Type Description Default <code>cube_name</code> <code>str</code> <p>str</p> required <code>cellset_as_dict</code> <code>Dict</code> <p>cellset_as_dict</p> required <code>increment</code> <code>bool</code> <p>increment or update cell values</p> <code>False</code> <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <code>precision</code> <code>int</code> <p>max precision when writhing through unbound process.</p> <code>None</code> <code>skip_non_updateable</code> <code>bool</code> <p>skip cells that are not updateable (e.g. rule derived or consolidated)</p> <code>False</code> <code>measure_dimension_elements</code> <code>Dict</code> <p>pass dictionary of measure elements and their types to improve performance. When all written values are numeric you can pass a defaultdict with default key: 'Numeric'</p> <code>None</code> <code>is_attribute_cube</code> <code>bool</code> <p>bool or None</p> <code>None</code> <code>allow_spread</code> <code>bool</code> <p>allow TI process in use_blob or use_ti to use CellPutProportionalSpread on C elements</p> <code>False</code> <code>kwargs</code> <p>Additional arguments for the REST request.</p> <code>{}</code> <p>Returns:</p> Type Description <p>Success: bool, Messages: list, ChangeSet: None</p> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>@require_data_admin\n@require_ops_admin\n@manage_transaction_log\ndef write_through_unbound_process(\n    self,\n    cube_name: str,\n    cellset_as_dict: Dict,\n    increment: bool = False,\n    sandbox_name: str = None,\n    precision: int = None,\n    skip_non_updateable: bool = False,\n    measure_dimension_elements: Dict = None,\n    is_attribute_cube: bool = None,\n    dimensions: List = None,\n    allow_spread: bool = False,\n    **kwargs,\n):\n    \"\"\"\n    Writes data back to TM1 via an unbound TI process\n    :param cube_name: str\n    :param cellset_as_dict: cellset_as_dict\n    :param increment: increment or update cell values\n    :param sandbox_name: str\n    :param precision: max precision when writhing through unbound process.\n    :param skip_non_updateable: skip cells that are not updateable (e.g. rule derived or consolidated)\n    :param measure_dimension_elements: pass dictionary of measure elements and their types to improve performance.\n        When all written values are numeric you can pass a defaultdict with default key: 'Numeric'\n    :param is_attribute_cube: bool or None\n    :param allow_spread: allow TI process in use_blob or use_ti to use CellPutProportionalSpread on C elements\n    :param kwargs: Additional arguments for the REST request.\n    :return: Success: bool, Messages: list, ChangeSet: None\n    \"\"\"\n    if is_attribute_cube is None:\n        is_attribute_cube = cube_name.lower().startswith(\"}elementattributes_\")\n\n    enable_sandbox = self.generate_enable_sandbox_ti(sandbox_name)\n\n    successes = list()\n    statuses = list()\n    log_files = list()\n\n    if not measure_dimension_elements:\n        measure_dimension_elements = self.get_elements_from_all_measure_hierarchies(cube_name)\n\n    if is_attribute_cube:\n        statements = self._build_attribute_update_statements(\n            cube_name=cube_name,\n            cellset_as_dict=cellset_as_dict,\n            precision=precision,\n            measure_dimension_elements=measure_dimension_elements,\n            skip_non_updateable=skip_non_updateable,\n        )\n\n    else:\n        if not dimensions and allow_spread:\n            dimensions = self.get_dimension_names_for_writing(cube_name=cube_name, **kwargs)\n        statements = self._build_cell_update_statements(\n            cube_name=cube_name,\n            cellset_as_dict=cellset_as_dict,\n            increment=increment,\n            measure_dimension_elements=measure_dimension_elements,\n            precision=precision,\n            skip_non_updateable=skip_non_updateable,\n            dimensions=dimensions,\n            allow_spread=allow_spread,\n        )\n\n    chunk = list()\n\n    max_statements = Process.max_statements(self.version)\n    for n, statement in enumerate(statements):\n        chunk.append(statement)\n        if n &gt; 0 and n % (max_statements * 2) == 0:\n            success, status, log_file = self._execute_write_statements(chunk, enable_sandbox, kwargs)\n            successes.append(success)\n            if not success:\n                statuses.append(status)\n                log_files.append(log_file)\n\n            chunk = list()\n\n    success, status, log_file = self._execute_write_statements(chunk, enable_sandbox, kwargs)\n    successes.append(success)\n    if not success:\n        statuses.append(status)\n        log_files.append(log_file)\n\n    if not any(successes):\n        if \"HasMinorErrors\" in statuses:\n            raise TM1pyWritePartialFailureException(statuses, log_files, len(successes))\n\n        raise TM1pyWriteFailureException(statuses, log_files)\n\n    if not all(successes):\n        raise TM1pyWritePartialFailureException(statuses, log_files, len(successes))\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.write_value","title":"<code>write_value(value, cube_name, element_tuple, dimensions=None, sandbox_name=None, **kwargs)</code>","text":"<p>Write value into cube at specified coordinates</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Union[str, float]</code> <p>the actual value</p> required <code>cube_name</code> <code>str</code> <p>name of the target cube</p> required <code>element_tuple</code> <code>Iterable</code> <p>target coordinates</p> required <code>dimensions</code> <code>Iterable[str]</code> <p>optional. Dimension names in their natural order. Will speed up the execution!</p> <code>None</code> <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>response</p> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>@manage_changeset\ndef write_value(\n    self,\n    value: Union[str, float],\n    cube_name: str,\n    element_tuple: Iterable,\n    dimensions: Iterable[str] = None,\n    sandbox_name: str = None,\n    **kwargs,\n) -&gt; Response:\n    \"\"\"Write value into cube at specified coordinates\n\n    :param value: the actual value\n    :param cube_name: name of the target cube\n    :param element_tuple: target coordinates\n    :param dimensions: optional. Dimension names in their natural order. Will speed up the execution!\n    :param sandbox_name: str\n    :return: response\n    \"\"\"\n    if not dimensions:\n        dimensions = self.get_dimension_names_for_writing(cube_name=cube_name)\n    url = format_url(\"/Cubes('{}')/tm1.Update\", cube_name)\n    url = add_url_parameters(url, **{\"!sandbox\": sandbox_name})\n    body_as_dict = OrderedDict()\n    body_as_dict[\"Cells\"] = [{}]\n    body_as_dict[\"Cells\"][0] = self._compose_odata_tuple_from_iterable(\n        cube_name, element_tuple, dimensions, **kwargs\n    )\n    body_as_dict[\"Value\"] = str(value) if value else \"\"\n    data = json.dumps(body_as_dict, ensure_ascii=False)\n    return self._rest.POST(url=url, data=data, **kwargs)\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.write_values","title":"<code>write_values(cube_name, cellset_as_dict, dimensions=None, sandbox_name=None, changeset=None, **kwargs)</code>","text":"<p>Write values to a cube</p> <p>For cellsets with &gt; 1000 cells look into <code>write</code> or <code>write_values_through_cellset</code> Supports spreading shortcuts</p> <p>Parameters:</p> Name Type Description Default <code>cube_name</code> <code>str</code> <p>name of the cube</p> required <code>cellset_as_dict</code> <code>Dict</code> <p>{(elem_a, elem_b, elem_c): 243, (elem_d, elem_e, elem_f) : 109}</p> required <code>dimensions</code> <code>Iterable[str]</code> <p>optional. Dimension names in their natural order. Will speed up the execution!</p> <code>None</code> <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <code>changeset</code> <code>str</code> <p>str</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Response</p> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>@manage_changeset\n@manage_transaction_log\ndef write_values(\n    self,\n    cube_name: str,\n    cellset_as_dict: Dict,\n    dimensions: Iterable[str] = None,\n    sandbox_name: str = None,\n    changeset: str = None,\n    **kwargs,\n) -&gt; str:\n    \"\"\"Write values to a cube\n\n    For cellsets with &gt; 1000 cells look into `write` or `write_values_through_cellset`\n    Supports spreading shortcuts\n\n    :param cube_name: name of the cube\n    :param cellset_as_dict: {(elem_a, elem_b, elem_c): 243, (elem_d, elem_e, elem_f) : 109}\n    :param dimensions: optional. Dimension names in their natural order. Will speed up the execution!\n    :param sandbox_name: str\n    :param changeset: str\n    :return: Response\n    \"\"\"\n    if not dimensions:\n        dimensions = self.get_dimension_names_for_writing(cube_name=cube_name, **kwargs)\n    url = format_url(\"/Cubes('{}')/tm1.Update\", cube_name)\n    url = add_url_parameters(url, **{\"!sandbox\": sandbox_name})\n    url = add_url_parameters(url, **{\"!ChangeSet\": changeset})\n\n    updates = []\n    for element_tuple, value in cellset_as_dict.items():\n        body_as_dict = OrderedDict()\n        body_as_dict[\"Cells\"] = [{}]\n        body_as_dict[\"Cells\"][0][\"Tuple@odata.bind\"] = [\n            format_url(\"Dimensions('{}')/Hierarchies('{}')/Elements('{}')\", dim, dim, elem)\n            for dim, elem in zip(dimensions, element_tuple)\n        ]\n        body_as_dict[\"Value\"] = value if value else \"\"\n        updates.append(json.dumps(body_as_dict, ensure_ascii=False))\n    updates = \"[\" + \",\".join(updates) + \"]\"\n    self._rest.POST(url=url, data=updates, **kwargs)\n\n    return changeset\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.CellService.write_values_through_cellset","title":"<code>write_values_through_cellset(mdx, values, increment=False, sandbox_name=None, **kwargs)</code>","text":"<p>Significantly faster than write_values function</p> <p>Cellset gets created according to MDX Expression. For instance: [[61, 29 ,13], [42, 54, 15], [17, 28, 81]]</p> <p>Each value in the cellset can be addressed through its position: The ordinal integer value. Ordinal-enumeration goes from top to bottom from left to right Number 61 has Ordinal 0, 29 has Ordinal 1, etc.</p> <p>The order of the iterable determines the insertion point in the cellset. For instance: [91, 85, 72, 68, 51, 42, 35, 28, 11]</p> <p>would lead to: [[91, 85 ,72], [68, 51, 42], [35, 28, 11]]</p> <p>When writing large datasets into TM1 Cubes it can be convenient to call this function asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>mdx</code> <code>str</code> <p>Valid MDX Expression.</p> required <code>values</code> <code>Iterable</code> <p>List of values. The Order of the List/ Iterable determines the insertion point in the cellset.</p> required <code>increment</code> <code>bool</code> <p>increment or update cells</p> <code>False</code> <code>sandbox_name</code> <code>str</code> <p>str</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>changeset: str</p> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>@manage_changeset\n@manage_transaction_log\ndef write_values_through_cellset(\n    self, mdx: str, values: Iterable, increment: bool = False, sandbox_name: str = None, **kwargs\n) -&gt; str:\n    \"\"\"Significantly faster than write_values function\n\n    Cellset gets created according to MDX Expression. For instance:\n    [[61, 29 ,13],\n    [42, 54, 15],\n    [17, 28, 81]]\n\n    Each value in the cellset can be addressed through its position: The ordinal integer value.\n    Ordinal-enumeration goes from top to bottom from left to right\n    Number 61 has Ordinal 0, 29 has Ordinal 1, etc.\n\n    The order of the iterable determines the insertion point in the cellset.\n    For instance:\n    [91, 85, 72, 68, 51, 42, 35, 28, 11]\n\n    would lead to:\n    [[91, 85 ,72],\n    [68, 51, 42],\n    [35, 28, 11]]\n\n    When writing large datasets into TM1 Cubes it can be convenient to call this function asynchronously.\n\n    :param mdx: Valid MDX Expression.\n    :param values: List of values. The Order of the List/ Iterable determines the insertion point in the cellset.\n    :param increment: increment or update cells\n    :param sandbox_name: str\n    :return: changeset: str\n    \"\"\"\n\n    changeset = kwargs.get(\"changeset\")\n\n    cellset_id = self.create_cellset(mdx=mdx, sandbox_name=sandbox_name, **kwargs)\n    if increment:\n        current_values = self.extract_cellset_values(\n            cellset_id, use_compact_json=True, delete_cellset=False, **kwargs\n        )\n        values = (float(x) + float(y or 0) for x, y in zip(values, current_values))\n\n    self.update_cellset(cellset_id=cellset_id, values=values, sandbox_name=sandbox_name, **kwargs)\n    return changeset\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.manage_changeset","title":"<code>manage_changeset(func)</code>","text":"<p>Control the start and end of change sets which goups write events together in the TM1 transaction log.</p> <p>Decorated function working with all non-TI based writing methods</p> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>@decohints\ndef manage_changeset(func):\n    \"\"\"Control the start and end of change sets which goups write events together in the TM1 transaction log.\n\n    Decorated function working with all non-TI based writing methods\n    \"\"\"\n\n    @functools.wraps(func)\n    def wrapper(self, *args, **kwargs):\n        use_changeset = kwargs.pop(\"use_changeset\", False)\n        if use_changeset:\n            changeset = self.begin_changeset()\n            try:\n                return func(self, changeset=changeset, *args, **kwargs)\n            finally:\n                self.end_changeset(changeset)\n        else:\n            return func(self, *args, **kwargs)\n\n    return wrapper\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.manage_transaction_log","title":"<code>manage_transaction_log(func)</code>","text":"<p>Control state of transaction log during and after write operation for a given cube through: <code>deactivate_transaction_log</code> and <code>reactivate_transaction_log</code>.</p> <p>Decorated function must have either <code>cube_name</code> or <code>mdx</code> as first argument or keyword argument</p> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>@decohints\ndef manage_transaction_log(func):\n    \"\"\"Control state of transaction log during and after write operation for a given cube through:\n    `deactivate_transaction_log` and `reactivate_transaction_log`.\n\n    Decorated function must have either `cube_name` or `mdx` as first argument or keyword argument\n    \"\"\"\n\n    @functools.wraps(func)\n    def wrapper(self, *args, **kwargs):\n        if \"cube_name\" in kwargs:\n            cube_name = kwargs[\"cube_name\"]\n        elif \"mdx\" in kwargs:\n            cube_name = get_cube(kwargs[\"mdx\"])\n        else:\n            arg = args[0]\n            if resembles_mdx(arg):\n                cube_name = get_cube(arg)\n            else:\n                cube_name = arg\n\n        deactivate_transaction_log = kwargs.pop(\"deactivate_transaction_log\", False)\n        reactivate_transaction_log = kwargs.pop(\"reactivate_transaction_log\", False)\n        try:\n\n            if deactivate_transaction_log:\n                self.deactivate_transactionlog(cube_name)\n            return func(self, *args, **kwargs)\n\n        finally:\n            if reactivate_transaction_log:\n                self.activate_transactionlog(cube_name)\n\n    return wrapper\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.odata_compact_json","title":"<code>odata_compact_json(return_as_dict)</code>","text":"<p>Higher order function to manage header and response when using compact JSON</p> <p>Applies when decorated function has <code>use_compact_json</code> argument set to True</p> <p>Currently only supports responses with only cell properties and where they are explicitly specified:     * Cellsets('...')?$expand=Axes(...),Cells($select=Ordinal,Value...) does NOT work !     * Cellsets('...')?$expand=Cells does NOT work !     * Cellsets('...')?$expand=Cells($select=Ordinal,Value...) works !</p> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>@decohints\ndef odata_compact_json(return_as_dict: bool):\n    \"\"\"Higher order function to manage header and response when using compact JSON\n\n    Applies when decorated function has `use_compact_json` argument set to True\n\n    Currently only supports responses with only cell properties and where they are explicitly specified:\n        * Cellsets('...')?$expand=Axes(...),Cells($select=Ordinal,Value...) does NOT work !\n        * Cellsets('...')?$expand=Cells does NOT work !\n        * Cellsets('...')?$expand=Cells($select=Ordinal,Value...) works !\n\n    \"\"\"\n\n    def wrap(func):\n        @functools.wraps(func)\n        def wrapper(self, *args, **kwargs):\n\n            if not kwargs.get(\"use_compact_json\", False):\n                return func(self, *args, **kwargs)\n\n            # Update Accept Header\n            original_header = self._rest.add_compact_json_header()\n\n            try:\n                response = func(self, *args, **kwargs)\n                context = response[\"@odata.context\"]\n\n                if context.startswith(\"$metadata#Cellsets\"):\n                    return extract_compact_json_cellset(context, response, return_as_dict)\n\n                else:\n                    raise NotImplementedError(\"odata_compact_json decorator must only be used on cellsets\")\n\n            finally:\n                # Restore original header\n                self._rest.add_http_header(\"Accept\", original_header)\n\n        return wrapper\n\n    return wrap\n</code></pre>"},{"location":"reference/services/cellservice/#TM1py.Services.CellService.tidy_cellset","title":"<code>tidy_cellset(func)</code>","text":"<p>Higher order function to tidy up cellset after usage</p> Source code in <code>TM1py/Services/CellService.py</code> <pre><code>@decohints\ndef tidy_cellset(func):\n    \"\"\"Higher order function to tidy up cellset after usage\"\"\"\n\n    @functools.wraps(func)\n    def wrapper(self, cellset_id, *args, **kwargs):\n        try:\n            return func(self, cellset_id, *args, **kwargs)\n\n        finally:\n            if kwargs.get(\"delete_cellset\", True):\n                sandbox_name = kwargs.get(\"sandbox_name\", None)\n                try:\n                    self.delete_cellset(cellset_id=cellset_id, sandbox_name=sandbox_name)\n\n                except TM1pyRestException as ex:\n                    # Fail silently if cellset is already removed\n                    if not ex.status_code == 404:\n                        raise ex\n\n    return wrapper\n</code></pre>"},{"location":"reference/services/choreservice/","title":"ChoreService","text":""},{"location":"reference/services/choreservice/#TM1py.Services.ChoreService.ChoreService","title":"<code>ChoreService(rest)</code>","text":"<p>               Bases: <code>ObjectService</code></p> <p>Service to handle Object Updates for TM1 Chores</p> Source code in <code>TM1py/Services/ChoreService.py</code> <pre><code>def __init__(self, rest: RestService):\n    super().__init__(rest)\n</code></pre>"},{"location":"reference/services/choreservice/#TM1py.Services.ChoreService.ChoreService.activate","title":"<code>activate(chore_name, **kwargs)</code>","text":"<p>activate chore on TM1 Server</p> <p>Parameters:</p> Name Type Description Default <code>chore_name</code> <code>str</code> required <p>Returns:</p> Type Description <code>Response</code> <p>response</p> Source code in <code>TM1py/Services/ChoreService.py</code> <pre><code>def activate(self, chore_name: str, **kwargs) -&gt; Response:\n    \"\"\"activate chore on TM1 Server\n    :param chore_name:\n    :return: response\n    \"\"\"\n    url = format_url(\"/Chores('{}')/tm1.Activate\", chore_name)\n    return self._rest.POST(url, \"\", **kwargs)\n</code></pre>"},{"location":"reference/services/choreservice/#TM1py.Services.ChoreService.ChoreService.create","title":"<code>create(chore, **kwargs)</code>","text":"<p>create a chore</p> <p>Parameters:</p> Name Type Description Default <code>chore</code> <code>Chore</code> <p>instance of TM1py.Chore</p> required <p>Returns:</p> Type Description <code>Response</code> Source code in <code>TM1py/Services/ChoreService.py</code> <pre><code>def create(self, chore: Chore, **kwargs) -&gt; Response:\n    \"\"\"create a chore\n    :param chore: instance of TM1py.Chore\n    :return:\n    \"\"\"\n    url = \"/Chores\"\n    response = self._rest.POST(url=url, data=chore.body, **kwargs)\n\n    if chore.dst_sensitivity:\n        self.set_local_start_time(chore.name, chore.start_time.datetime)\n\n    if chore.active:\n        self.activate(chore.name)\n    return response\n</code></pre>"},{"location":"reference/services/choreservice/#TM1py.Services.ChoreService.ChoreService.deactivate","title":"<code>deactivate(chore_name, **kwargs)</code>","text":"<p>deactivate chore on TM1 Server</p> <p>Parameters:</p> Name Type Description Default <code>chore_name</code> <code>str</code> required <p>Returns:</p> Type Description <code>Response</code> <p>response</p> Source code in <code>TM1py/Services/ChoreService.py</code> <pre><code>def deactivate(self, chore_name: str, **kwargs) -&gt; Response:\n    \"\"\"deactivate chore on TM1 Server\n    :param chore_name:\n    :return: response\n    \"\"\"\n    url = format_url(\"/Chores('{}')/tm1.Deactivate\", chore_name)\n    return self._rest.POST(url, \"\", **kwargs)\n</code></pre>"},{"location":"reference/services/choreservice/#TM1py.Services.ChoreService.ChoreService.delete","title":"<code>delete(chore_name, **kwargs)</code>","text":"<p>delete chore in TM1</p> <p>Parameters:</p> Name Type Description Default <code>chore_name</code> <code>str</code> required <p>Returns:</p> Type Description <code>Response</code> <p>response</p> Source code in <code>TM1py/Services/ChoreService.py</code> <pre><code>def delete(self, chore_name: str, **kwargs) -&gt; Response:\n    \"\"\"delete chore in TM1\n    :param chore_name:\n    :return: response\n    \"\"\"\n    url = format_url(\"/Chores('{}')\", chore_name)\n    response = self._rest.DELETE(url, **kwargs)\n    return response\n</code></pre>"},{"location":"reference/services/choreservice/#TM1py.Services.ChoreService.ChoreService.execute_chore","title":"<code>execute_chore(chore_name, **kwargs)</code>","text":"<p>Ask TM1 Server to execute a chore</p> <p>Parameters:</p> Name Type Description Default <code>chore_name</code> <code>str</code> <p>String, name of the chore to be executed</p> required <p>Returns:</p> Type Description <code>Response</code> <p>the response</p> Source code in <code>TM1py/Services/ChoreService.py</code> <pre><code>def execute_chore(self, chore_name: str, **kwargs) -&gt; Response:\n    \"\"\"Ask TM1 Server to execute a chore\n    :param chore_name: String, name of the chore to be executed\n    :return: the response\n    \"\"\"\n    return self._rest.POST(format_url(\"/Chores('{}')/tm1.Execute\", chore_name), \"\", **kwargs)\n</code></pre>"},{"location":"reference/services/choreservice/#TM1py.Services.ChoreService.ChoreService.exists","title":"<code>exists(chore_name, **kwargs)</code>","text":"<p>Check if Chore exists</p> <p>Parameters:</p> Name Type Description Default <code>chore_name</code> <code>str</code> required <p>Returns:</p> Type Description <code>bool</code> Source code in <code>TM1py/Services/ChoreService.py</code> <pre><code>def exists(self, chore_name: str, **kwargs) -&gt; bool:\n    \"\"\"Check if Chore exists\n\n    :param chore_name:\n    :return:\n    \"\"\"\n    url = format_url(\"/Chores('{}')\", chore_name)\n    return self._exists(url, **kwargs)\n</code></pre>"},{"location":"reference/services/choreservice/#TM1py.Services.ChoreService.ChoreService.get","title":"<code>get(chore_name, **kwargs)</code>","text":"<p>Get a chore from the TM1 Server</p> <p>Parameters:</p> Name Type Description Default <code>chore_name</code> <code>str</code> required <p>Returns:</p> Type Description <code>Chore</code> <p>instance of TM1py.Chore</p> Source code in <code>TM1py/Services/ChoreService.py</code> <pre><code>def get(self, chore_name: str, **kwargs) -&gt; Chore:\n    \"\"\"Get a chore from the TM1 Server\n    :param chore_name:\n    :return: instance of TM1py.Chore\n    \"\"\"\n    url = format_url(\"/Chores('{}')?$expand=Tasks($expand=*,Process($select=Name),Chore($select=Name))\", chore_name)\n    response = self._rest.GET(url, **kwargs)\n    return Chore.from_dict(response.json())\n</code></pre>"},{"location":"reference/services/choreservice/#TM1py.Services.ChoreService.ChoreService.get_all","title":"<code>get_all(**kwargs)</code>","text":"<p>get a List of all Chores</p> <p>Returns:</p> Type Description <code>List[Chore]</code> <p>List of TM1py.Chore</p> Source code in <code>TM1py/Services/ChoreService.py</code> <pre><code>def get_all(self, **kwargs) -&gt; List[Chore]:\n    \"\"\"get a List of all Chores\n    :return: List of TM1py.Chore\n    \"\"\"\n    url = \"/Chores?$expand=Tasks($expand=*,Process($select=Name),Chore($select=Name))\"\n    response = self._rest.GET(url, **kwargs)\n    return [Chore.from_dict(chore_as_dict) for chore_as_dict in response.json()[\"value\"]]\n</code></pre>"},{"location":"reference/services/choreservice/#TM1py.Services.ChoreService.ChoreService.get_all_names","title":"<code>get_all_names(**kwargs)</code>","text":"<p>get a List of all Chores</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of TM1py.Chore</p> Source code in <code>TM1py/Services/ChoreService.py</code> <pre><code>def get_all_names(self, **kwargs) -&gt; List[str]:\n    \"\"\"get a List of all Chores\n    :return: List of TM1py.Chore\n    \"\"\"\n    url = \"/Chores?$select=Name\"\n    response = self._rest.GET(url, **kwargs)\n    return [chore[\"Name\"] for chore in response.json()[\"value\"]]\n</code></pre>"},{"location":"reference/services/choreservice/#TM1py.Services.ChoreService.ChoreService.search_for_parameter_value","title":"<code>search_for_parameter_value(parameter_value, **kwargs)</code>","text":"<p>Return chore details for any/all chores that have a specified value set in the chore parameter settings     *this will NOT check the process parameter default, rather the defined parameter value saved in the chore</p> <p>Parameters:</p> Name Type Description Default <code>parameter_value</code> <code>str</code> <p>string, will search wildcard for string in parameter value using Contains(string)</p> required Source code in <code>TM1py/Services/ChoreService.py</code> <pre><code>def search_for_parameter_value(self, parameter_value: str, **kwargs) -&gt; List[Chore]:\n    \"\"\"Return chore details for any/all chores that have a specified value set in the chore parameter settings\n        *this will NOT check the process parameter default, rather the defined parameter value saved in the chore\n\n    :param parameter_value: string, will search wildcard for string in parameter value using Contains(string)\n    \"\"\"\n    url = format_url(\n        \"/Chores?\"\n        \"$filter=Tasks/any(t: t/Parameters/any(p: isof(p/Value, Edm.String) and contains(tolower(p/Value), '{}')))\"\n        \"&amp;$expand=Tasks($expand=*,Process($select=Name),Chore($select=Name))\",\n        parameter_value.lower(),\n    )\n    response = self._rest.GET(url, **kwargs)\n    return [Chore.from_dict(chore_as_dict) for chore_as_dict in response.json()[\"value\"]]\n</code></pre>"},{"location":"reference/services/choreservice/#TM1py.Services.ChoreService.ChoreService.search_for_process_name","title":"<code>search_for_process_name(process_name, **kwargs)</code>","text":"<p>Return chore details for any/all chores that contain specified process name in tasks</p> <p>Parameters:</p> Name Type Description Default <code>process_name</code> <code>str</code> <p>string, a valid ti process name; spaces will be elimniated</p> required Source code in <code>TM1py/Services/ChoreService.py</code> <pre><code>def search_for_process_name(self, process_name: str, **kwargs) -&gt; List[Chore]:\n    \"\"\"Return chore details for any/all chores that contain specified process name in tasks\n\n    :param process_name: string, a valid ti process name; spaces will be elimniated\n    \"\"\"\n    url = format_url(\n        \"/Chores?$filter=Tasks/any(t: replace(tolower(t/Process/Name), ' ', '') eq '{}')\"\n        \"&amp;$expand=Tasks($expand=*,Chore($select=Name),Process($select=Name))\",\n        process_name.lower().replace(\" \", \"\"),\n    )\n    response = self._rest.GET(url, **kwargs)\n    return [Chore.from_dict(chore_as_dict) for chore_as_dict in response.json()[\"value\"]]\n</code></pre>"},{"location":"reference/services/choreservice/#TM1py.Services.ChoreService.ChoreService.set_local_start_time","title":"<code>set_local_start_time(chore_name, date_time, **kwargs)</code>","text":"<p>Makes Server crash if chore is activated (10.2.2 FP6) :)</p> <p>Parameters:</p> Name Type Description Default <code>chore_name</code> <code>str</code> required <code>date_time</code> <code>datetime</code> required <p>Returns:</p> Type Description <code>Response</code> Source code in <code>TM1py/Services/ChoreService.py</code> <pre><code>@deactivate_activate\ndef set_local_start_time(self, chore_name: str, date_time: datetime, **kwargs) -&gt; Response:\n    \"\"\"Makes Server crash if chore is activated (10.2.2 FP6) :)\n    :param chore_name:\n    :param date_time:\n    :return:\n    \"\"\"\n    url = format_url(\"/Chores('{}')/tm1.SetServerLocalStartTime\", chore_name)\n    data = {\n        \"StartDate\": \"{}-{}-{}\".format(date_time.year, date_time.month, date_time.day),\n        \"StartTime\": \"{}:{}:{}\".format(\n            self.zfill_two(date_time.hour), self.zfill_two(date_time.minute), self.zfill_two(date_time.second)\n        ),\n    }\n    return self._rest.POST(url, json.dumps(data), **kwargs)\n</code></pre>"},{"location":"reference/services/choreservice/#TM1py.Services.ChoreService.ChoreService.update","title":"<code>update(chore, **kwargs)</code>","text":"<p>update chore on TM1 Server does not update: DST Sensitivity!</p> <p>Parameters:</p> Name Type Description Default <code>chore</code> <code>Chore</code> required <p>Returns:</p> Type Description Source code in <code>TM1py/Services/ChoreService.py</code> <pre><code>@deactivate_activate\ndef update(self, chore: Chore, **kwargs):\n    \"\"\"update chore on TM1 Server\n    does not update: DST Sensitivity!\n    :param chore:\n    :return:\n    \"\"\"\n    # Update StartTime, ExecutionMode, Frequency\n    url = format_url(\"/Chores('{}')\", chore.name)\n    # Remove Tasks from Body. Tasks to be managed individually\n    chore_dict_without_tasks = chore.body_as_dict\n    chore_dict_without_tasks.pop(\"Tasks\")\n    self._rest.PATCH(url, json.dumps(chore_dict_without_tasks), **kwargs)\n\n    # Update Tasks individually\n    task_old_count = self._get_tasks_count(chore.name)\n    i = -1\n    for i, task_new in enumerate(chore.tasks):\n        if i &gt;= task_old_count:\n            self._add_task(chore.name, task_new, **kwargs)\n        else:\n            task_old = self._get_task(chore.name, i)\n            if task_new != task_old:\n                task_new._step = i\n                self._update_task(chore.name, task_new, **kwargs)\n    for j in range(i + 1, task_old_count):\n        self._delete_task(chore.name, i + 1, **kwargs)\n\n    if chore.dst_sensitivity:\n        self.set_local_start_time(chore.name, chore.start_time.datetime)\n</code></pre>"},{"location":"reference/services/choreservice/#TM1py.Services.ChoreService.ChoreService.update_or_create","title":"<code>update_or_create(chore, **kwargs)</code>","text":"Source code in <code>TM1py/Services/ChoreService.py</code> <pre><code>def update_or_create(self, chore: Chore, **kwargs) -&gt; Response:\n    if self.exists(chore_name=chore.name, **kwargs):\n        return self.update(chore, **kwargs)\n\n    return self.create(chore=chore, **kwargs)\n</code></pre>"},{"location":"reference/services/choreservice/#TM1py.Services.ChoreService.ChoreService.zfill_two","title":"<code>zfill_two(number)</code>  <code>staticmethod</code>","text":"<p>Pad an int with zeros on the left two create two digit string</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>int</code> required <p>Returns:</p> Type Description <code>str</code> Source code in <code>TM1py/Services/ChoreService.py</code> <pre><code>@staticmethod\ndef zfill_two(number: int) -&gt; str:\n    \"\"\"Pad an int with zeros on the left two create two digit string\n\n    :param number:\n    :return:\n    \"\"\"\n    return str(number).zfill(2)\n</code></pre>"},{"location":"reference/services/choreservice/#TM1py.Services.ChoreService.deactivate_activate","title":"<code>deactivate_activate(func)</code>","text":"<p>Higher Order function to handle activation and deactivation of chores before updating them</p> <p>Parameters:</p> Name Type Description Default <code>func</code> required <p>Returns:</p> Type Description Source code in <code>TM1py/Services/ChoreService.py</code> <pre><code>@decohints\ndef deactivate_activate(func):\n    \"\"\"Higher Order function to handle activation and deactivation of chores before updating them\n\n    :param func:\n    :return:\n    \"\"\"\n\n    @functools.wraps(func)\n    def wrapper(self, *args, **kwargs):\n        # chore (type Chore) or chore_name (type str) is passed as first arg or kwargs\n        if \"chore\" in kwargs:\n            chore = kwargs.get(\"chore\").name\n        elif \"chore_name\" in kwargs:\n            chore = kwargs.get(\"chore_name\")\n        else:\n            chore = args[0]\n\n        reactivate = None\n        if isinstance(chore, Chore):\n            chore_name = chore.name\n            reactivate = chore.active\n        elif isinstance(chore, str):\n            chore_name = chore\n        else:\n            raise ValueError(\"Argument must be of type 'Chore' or 'str'\")\n\n        # Get current chore\n        chore_old = self.get(chore_name)\n        if reactivate is None:\n            reactivate = chore_old.active\n\n        # Deactivate\n        if chore_old.active:\n            self.deactivate(chore_name)\n        # Do stuff\n        try:\n            response = func(self, *args, **kwargs)\n        except Exception as e:\n            raise e\n        # Activate if necessary\n        finally:\n            if reactivate:\n                self.activate(chore_name)\n        return response\n\n    return wrapper\n</code></pre>"},{"location":"reference/services/configurationservice/","title":"ConfigurationService","text":""},{"location":"reference/services/configurationservice/#TM1py.Services.ConfigurationService.ConfigurationService","title":"<code>ConfigurationService(rest)</code>","text":"<p>               Bases: <code>ObjectService</code></p> Source code in <code>TM1py/Services/ConfigurationService.py</code> <pre><code>def __init__(self, rest: RestService):\n    super().__init__(rest)\n</code></pre>"},{"location":"reference/services/configurationservice/#TM1py.Services.ConfigurationService.ConfigurationService.get_active","title":"<code>get_active(**kwargs)</code>","text":"<p>Read effective(!) TM1 config settings as dictionary from TM1 Server</p> <p>Returns:</p> Type Description <code>Dict</code> <p>config as dictionary</p> Source code in <code>TM1py/Services/ConfigurationService.py</code> <pre><code>@require_ops_admin\ndef get_active(self, **kwargs) -&gt; Dict:\n    \"\"\"Read effective(!) TM1 config settings as dictionary from TM1 Server\n\n    :return: config as dictionary\n    \"\"\"\n    url = \"/ActiveConfiguration\"\n    config = self._rest.GET(url, **kwargs).json()\n    del config[\"@odata.context\"]\n    return config\n</code></pre>"},{"location":"reference/services/configurationservice/#TM1py.Services.ConfigurationService.ConfigurationService.get_admin_host","title":"<code>get_admin_host(**kwargs)</code>","text":"Source code in <code>TM1py/Services/ConfigurationService.py</code> <pre><code>@deprecated_in_version(version=\"12.0.0\")\ndef get_admin_host(self, **kwargs) -&gt; str:\n    url = \"/Configuration/AdminHost/$value\"\n    return self._rest.GET(url, **kwargs).text\n</code></pre>"},{"location":"reference/services/configurationservice/#TM1py.Services.ConfigurationService.ConfigurationService.get_all","title":"<code>get_all(**kwargs)</code>","text":"Source code in <code>TM1py/Services/ConfigurationService.py</code> <pre><code>def get_all(self, **kwargs) -&gt; Dict:\n    url = \"/Configuration\"\n    config = self._rest.GET(url, **kwargs).json()\n    del config[\"@odata.context\"]\n    return config\n</code></pre>"},{"location":"reference/services/configurationservice/#TM1py.Services.ConfigurationService.ConfigurationService.get_data_directory","title":"<code>get_data_directory(**kwargs)</code>","text":"Source code in <code>TM1py/Services/ConfigurationService.py</code> <pre><code>@deprecated_in_version(version=\"12.0.0\")\ndef get_data_directory(self, **kwargs) -&gt; str:\n    url = \"/Configuration/DataBaseDirectory/$value\"\n    return self._rest.GET(url, **kwargs).text\n</code></pre>"},{"location":"reference/services/configurationservice/#TM1py.Services.ConfigurationService.ConfigurationService.get_product_version","title":"<code>get_product_version(**kwargs)</code>","text":"<p>Ask TM1 Server for its version</p> <p>:Returns:     String, the version</p> Source code in <code>TM1py/Services/ConfigurationService.py</code> <pre><code>def get_product_version(self, **kwargs) -&gt; str:\n    \"\"\"Ask TM1 Server for its version\n\n    :Returns:\n        String, the version\n    \"\"\"\n    url = \"/Configuration/ProductVersion/$value\"\n    return self._rest.GET(url, **kwargs).text\n</code></pre>"},{"location":"reference/services/configurationservice/#TM1py.Services.ConfigurationService.ConfigurationService.get_server_name","title":"<code>get_server_name(**kwargs)</code>","text":"<p>Ask TM1 Server for its name</p> <p>:Returns:     String, the server name</p> Source code in <code>TM1py/Services/ConfigurationService.py</code> <pre><code>def get_server_name(self, **kwargs) -&gt; str:\n    \"\"\"Ask TM1 Server for its name\n\n    :Returns:\n        String, the server name\n    \"\"\"\n    url = \"/Configuration/ServerName/$value\"\n    return self._rest.GET(url, **kwargs).text\n</code></pre>"},{"location":"reference/services/configurationservice/#TM1py.Services.ConfigurationService.ConfigurationService.get_static","title":"<code>get_static(**kwargs)</code>","text":"<p>Read TM1 config settings as dictionary from TM1 Server</p> <p>Returns:</p> Type Description <code>Dict</code> <p>config as dictionary</p> Source code in <code>TM1py/Services/ConfigurationService.py</code> <pre><code>@require_ops_admin\ndef get_static(self, **kwargs) -&gt; Dict:\n    \"\"\"Read TM1 config settings as dictionary from TM1 Server\n\n    :return: config as dictionary\n    \"\"\"\n    url = \"/StaticConfiguration\"\n    config = self._rest.GET(url, **kwargs).json()\n    del config[\"@odata.context\"]\n    return config\n</code></pre>"},{"location":"reference/services/configurationservice/#TM1py.Services.ConfigurationService.ConfigurationService.update_static","title":"<code>update_static(configuration)</code>","text":"<p>Update the .cfg file and triggers TM1 to re-read the file.</p> <p>Parameters:</p> Name Type Description Default <code>configuration</code> <code>Dict</code> required <p>Returns:</p> Type Description <code>Response</code> <p>Response</p> Source code in <code>TM1py/Services/ConfigurationService.py</code> <pre><code>@require_ops_admin\ndef update_static(self, configuration: Dict) -&gt; Response:\n    \"\"\"Update the .cfg file and triggers TM1 to re-read the file.\n\n    :param configuration:\n    :return: Response\n    \"\"\"\n    url = \"/StaticConfiguration\"\n    return self._rest.PATCH(url, json.dumps(configuration))\n</code></pre>"},{"location":"reference/services/cubeservice/","title":"CubeService","text":""},{"location":"reference/services/cubeservice/#TM1py.Services.CubeService.CubeService","title":"<code>CubeService(rest)</code>","text":"<p>               Bases: <code>ObjectService</code></p> <p>Service to handle Object Updates for TM1 Cubes</p> Source code in <code>TM1py/Services/CubeService.py</code> <pre><code>def __init__(self, rest: RestService):\n    # to avoid Circular dependency of modules\n    from TM1py.Services.AnnotationService import AnnotationService\n\n    super().__init__(rest)\n    self.cells = CellService(rest)\n    self.views = ViewService(rest)\n    self.annotations = AnnotationService(rest)\n</code></pre>"},{"location":"reference/services/cubeservice/#TM1py.Services.CubeService.CubeService.annotations","title":"<code>annotations = AnnotationService(rest)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/services/cubeservice/#TM1py.Services.CubeService.CubeService.cells","title":"<code>cells = CellService(rest)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/services/cubeservice/#TM1py.Services.CubeService.CubeService.views","title":"<code>views = ViewService(rest)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/services/cubeservice/#TM1py.Services.CubeService.CubeService.check_rules","title":"<code>check_rules(cube_name, **kwargs)</code>","text":"<p>Check rules syntax for existing cube on TM1 Server</p> <p>Parameters:</p> Name Type Description Default <code>cube_name</code> <code>str</code> <p>name of a cube</p> required <p>Returns:</p> Type Description <code>Response</code> <p>response</p> Source code in <code>TM1py/Services/CubeService.py</code> <pre><code>def check_rules(self, cube_name: str, **kwargs) -&gt; Response:\n    \"\"\"Check rules syntax for existing cube on TM1 Server\n\n    :param cube_name: name of a cube\n    :return: response\n    \"\"\"\n    url = format_url(\"/Cubes('{}')/tm1.CheckRules\", cube_name)\n\n    response = self._rest.POST(url, **kwargs)\n    errors = response.json()[\"value\"]\n    return errors\n</code></pre>"},{"location":"reference/services/cubeservice/#TM1py.Services.CubeService.CubeService.create","title":"<code>create(cube, **kwargs)</code>","text":"<p>create new cube on TM1 Server</p> <p>Parameters:</p> Name Type Description Default <code>cube</code> <code>Cube</code> <p>instance of TM1py.Cube</p> required <p>Returns:</p> Type Description <code>Response</code> <p>response</p> Source code in <code>TM1py/Services/CubeService.py</code> <pre><code>def create(self, cube: Cube, **kwargs) -&gt; Response:\n    \"\"\"create new cube on TM1 Server\n\n    :param cube: instance of TM1py.Cube\n    :return: response\n    \"\"\"\n    url = \"/Cubes\"\n    return self._rest.POST(url=url, data=cube.body, **kwargs)\n</code></pre>"},{"location":"reference/services/cubeservice/#TM1py.Services.CubeService.CubeService.cube_save_data","title":"<code>cube_save_data(cube_name, **kwargs)</code>","text":"<p>Serializes a cube by saving data updates</p> <p>Parameters:</p> Name Type Description Default <code>cube_name</code> <code>str</code> required <p>Returns:</p> Type Description <code>Response</code> <p>Response</p> Source code in <code>TM1py/Services/CubeService.py</code> <pre><code>@require_data_admin\ndef cube_save_data(self, cube_name: str, **kwargs) -&gt; Response:\n    \"\"\"Serializes a cube by saving data updates\n\n    :param cube_name:\n    :return: Response\n    \"\"\"\n    from TM1py.Services import ProcessService\n\n    ti = \"CubeSaveData('{0}');\".format(cube_name)\n    process_service = ProcessService(self._rest)\n    return process_service.execute_ti_code(ti, **kwargs)\n</code></pre>"},{"location":"reference/services/cubeservice/#TM1py.Services.CubeService.CubeService.delete","title":"<code>delete(cube_name, **kwargs)</code>","text":"<p>Delete a cube in TM1</p> <p>Parameters:</p> Name Type Description Default <code>cube_name</code> <code>str</code> required <p>Returns:</p> Type Description <code>Response</code> <p>response</p> Source code in <code>TM1py/Services/CubeService.py</code> <pre><code>@require_data_admin\ndef delete(self, cube_name: str, **kwargs) -&gt; Response:\n    \"\"\"Delete a cube in TM1\n\n    :param cube_name:\n    :return: response\n    \"\"\"\n    url = format_url(\"/Cubes('{}')\", cube_name)\n    return self._rest.DELETE(url, **kwargs)\n</code></pre>"},{"location":"reference/services/cubeservice/#TM1py.Services.CubeService.CubeService.exists","title":"<code>exists(cube_name, **kwargs)</code>","text":"<p>Check if a cube exists. Return boolean.</p> <p>Parameters:</p> Name Type Description Default <code>cube_name</code> <code>str</code> required <p>Returns:</p> Type Description <code>bool</code> <p>Boolean</p> Source code in <code>TM1py/Services/CubeService.py</code> <pre><code>def exists(self, cube_name: str, **kwargs) -&gt; bool:\n    \"\"\"Check if a cube exists. Return boolean.\n\n    :param cube_name:\n    :return: Boolean\n    \"\"\"\n    url = format_url(\"/Cubes('{}')\", cube_name)\n    return self._exists(url, **kwargs)\n</code></pre>"},{"location":"reference/services/cubeservice/#TM1py.Services.CubeService.CubeService.get","title":"<code>get(cube_name, **kwargs)</code>","text":"<p>get cube from TM1 Server</p> <p>Parameters:</p> Name Type Description Default <code>cube_name</code> <code>str</code> required <p>Returns:</p> Type Description <code>Cube</code> <p>instance of TM1py.Cube</p> Source code in <code>TM1py/Services/CubeService.py</code> <pre><code>def get(self, cube_name: str, **kwargs) -&gt; Cube:\n    \"\"\"get cube from TM1 Server\n\n    :param cube_name:\n    :return: instance of TM1py.Cube\n    \"\"\"\n    url = format_url(\"/Cubes('{}')?$expand=Dimensions($select=Name)\", cube_name)\n    response = self._rest.GET(url=url, **kwargs)\n    cube = Cube.from_json(response.text)\n    # cater for potential EnableSandboxDimension=T setup\n    if case_and_space_insensitive_equals(cube.dimensions[0], \"Sandboxes\"):\n        cube.dimensions = cube.dimensions[1:]\n    return cube\n</code></pre>"},{"location":"reference/services/cubeservice/#TM1py.Services.CubeService.CubeService.get_all","title":"<code>get_all(**kwargs)</code>","text":"<p>get all cubes from TM1 Server as TM1py.Cube instances</p> <p>Returns:</p> Type Description <code>List[Cube]</code> <p>List of TM1py.Cube instances</p> Source code in <code>TM1py/Services/CubeService.py</code> <pre><code>def get_all(self, **kwargs) -&gt; List[Cube]:\n    \"\"\"get all cubes from TM1 Server as TM1py.Cube instances\n\n    :return: List of TM1py.Cube instances\n    \"\"\"\n    url = \"/Cubes?$expand=Dimensions($select=Name)\"\n    response = self._rest.GET(url, **kwargs)\n    cubes = [Cube.from_dict(cube_as_dict=cube) for cube in response.json()[\"value\"]]\n    return cubes\n</code></pre>"},{"location":"reference/services/cubeservice/#TM1py.Services.CubeService.CubeService.get_all_names","title":"<code>get_all_names(skip_control_cubes=False, **kwargs)</code>","text":"<p>Ask TM1 Server for list of all cube names</p> <p>:skip_control_cubes: bool, True will exclude control cubes from list</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of Strings</p> Source code in <code>TM1py/Services/CubeService.py</code> <pre><code>def get_all_names(self, skip_control_cubes: bool = False, **kwargs) -&gt; List[str]:\n    \"\"\"Ask TM1 Server for list of all cube names\n\n    :skip_control_cubes: bool, True will exclude control cubes from list\n    :return: List of Strings\n    \"\"\"\n    url = format_url(\"/{}?$select=Name\", \"ModelCubes()\" if skip_control_cubes else \"Cubes\")\n\n    response = self._rest.GET(url, **kwargs)\n    cubes = list(entry[\"Name\"] for entry in response.json()[\"value\"])\n    return cubes\n</code></pre>"},{"location":"reference/services/cubeservice/#TM1py.Services.CubeService.CubeService.get_all_names_with_rules","title":"<code>get_all_names_with_rules(skip_control_cubes=False, **kwargs)</code>","text":"<p>Ask TM1 Server for list of all cube names that have rules</p> <p>:skip_control_cubes: bool, True will exclude control cubes from list</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of Strings</p> Source code in <code>TM1py/Services/CubeService.py</code> <pre><code>def get_all_names_with_rules(self, skip_control_cubes: bool = False, **kwargs) -&gt; List[str]:\n    \"\"\"Ask TM1 Server for list of all cube names that have rules\n\n    :skip_control_cubes: bool, True will exclude control cubes from list\n    :return: List of Strings\n    \"\"\"\n    url = format_url(\n        \"/{}?$select=Name,Rules&amp;$filter=Rules ne null\", \"ModelCubes()\" if skip_control_cubes else \"Cubes\"\n    )\n\n    response = self._rest.GET(url, **kwargs)\n    cubes = list(cube[\"Name\"] for cube in response.json()[\"value\"])\n    return cubes\n</code></pre>"},{"location":"reference/services/cubeservice/#TM1py.Services.CubeService.CubeService.get_all_names_without_rules","title":"<code>get_all_names_without_rules(skip_control_cubes=False, **kwargs)</code>","text":"<p>Ask TM1 Server for list of all cube names that do not have rules :skip_control_cubes: bool, True will exclude control cubes from list</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of Strings</p> Source code in <code>TM1py/Services/CubeService.py</code> <pre><code>def get_all_names_without_rules(self, skip_control_cubes: bool = False, **kwargs) -&gt; List[str]:\n    \"\"\"Ask TM1 Server for list of all cube names that do not have rules\n    :skip_control_cubes: bool, True will exclude control cubes from list\n    :return: List of Strings\n    \"\"\"\n\n    url = format_url(\n        \"/{}?$select=Name,Rules&amp;$filter=Rules eq null\", \"ModelCubes()\" if skip_control_cubes else \"Cubes\"\n    )\n\n    response = self._rest.GET(url, **kwargs)\n    cubes = list(cube[\"Name\"] for cube in response.json()[\"value\"])\n    return cubes\n</code></pre>"},{"location":"reference/services/cubeservice/#TM1py.Services.CubeService.CubeService.get_control_cubes","title":"<code>get_control_cubes(**kwargs)</code>","text":"<p>Get all Cubes with } prefix from TM1 Server as TM1py.Cube instances</p> <p>Returns:</p> Type Description <code>List[Cube]</code> <p>List of TM1py.Cube instances</p> Source code in <code>TM1py/Services/CubeService.py</code> <pre><code>def get_control_cubes(self, **kwargs) -&gt; List[Cube]:\n    \"\"\"Get all Cubes with } prefix from TM1 Server as TM1py.Cube instances\n\n    :return: List of TM1py.Cube instances\n    \"\"\"\n    url = \"/ControlCubes()?$expand=Dimensions($select=Name)\"\n    response = self._rest.GET(url, **kwargs)\n    cubes = [Cube.from_dict(cube_as_dict=cube) for cube in response.json()[\"value\"]]\n    return cubes\n</code></pre>"},{"location":"reference/services/cubeservice/#TM1py.Services.CubeService.CubeService.get_dimension_names","title":"<code>get_dimension_names(cube_name, skip_sandbox_dimension=True, **kwargs)</code>","text":"<p>get name of the dimensions of a cube in their correct order</p> <p>Parameters:</p> Name Type Description Default <code>cube_name</code> <code>str</code> required <code>skip_sandbox_dimension</code> <code>bool</code> <code>True</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>List : [dim1, dim2, dim3, etc.]</p> Source code in <code>TM1py/Services/CubeService.py</code> <pre><code>def get_dimension_names(self, cube_name: str, skip_sandbox_dimension: bool = True, **kwargs) -&gt; List[str]:\n    \"\"\"get name of the dimensions of a cube in their correct order\n\n    :param cube_name:\n    :param skip_sandbox_dimension:\n    :return:  List : [dim1, dim2, dim3, etc.]\n    \"\"\"\n    url = format_url(\"/Cubes('{}')/Dimensions?$select=Name\", cube_name)\n    response = self._rest.GET(url, **kwargs)\n    dimension_names = [element[\"Name\"] for element in response.json()[\"value\"]]\n    if skip_sandbox_dimension and dimension_names[0] == CellService.SANDBOX_DIMENSION:\n        return dimension_names[1:]\n    return dimension_names\n</code></pre>"},{"location":"reference/services/cubeservice/#TM1py.Services.CubeService.CubeService.get_last_data_update","title":"<code>get_last_data_update(cube_name, **kwargs)</code>","text":"Source code in <code>TM1py/Services/CubeService.py</code> <pre><code>def get_last_data_update(self, cube_name: str, **kwargs) -&gt; str:\n    url = format_url(\"/Cubes('{}')/LastDataUpdate/$value\", cube_name)\n    response = self._rest.GET(url=url, **kwargs)\n    return response.text\n</code></pre>"},{"location":"reference/services/cubeservice/#TM1py.Services.CubeService.CubeService.get_measure_dimension","title":"<code>get_measure_dimension(cube_name, **kwargs)</code>","text":"Source code in <code>TM1py/Services/CubeService.py</code> <pre><code>def get_measure_dimension(self, cube_name: str, **kwargs) -&gt; str:\n    url = format_url(\"/Cubes('{}')/Dimensions?$select=Name\", cube_name)\n    response = self._rest.GET(url, **kwargs)\n    return response.json()[\"value\"][-1][\"Name\"]\n</code></pre>"},{"location":"reference/services/cubeservice/#TM1py.Services.CubeService.CubeService.get_model_cubes","title":"<code>get_model_cubes(**kwargs)</code>","text":"<p>Get all Cubes without } prefix from TM1 Server as TM1py.Cube instances</p> <p>Returns:</p> Type Description <code>List[Cube]</code> <p>List of TM1py.Cube instances</p> Source code in <code>TM1py/Services/CubeService.py</code> <pre><code>def get_model_cubes(self, **kwargs) -&gt; List[Cube]:\n    \"\"\"Get all Cubes without } prefix from TM1 Server as TM1py.Cube instances\n\n    :return: List of TM1py.Cube instances\n    \"\"\"\n    url = \"/ModelCubes()?$expand=Dimensions($select=Name)\"\n    response = self._rest.GET(url, **kwargs)\n    cubes = [Cube.from_dict(cube_as_dict=cube) for cube in response.json()[\"value\"]]\n    return cubes\n</code></pre>"},{"location":"reference/services/cubeservice/#TM1py.Services.CubeService.CubeService.get_number_of_cubes","title":"<code>get_number_of_cubes(skip_control_cubes=False, **kwargs)</code>","text":"<p>Ask TM1 Server for count of cubes</p> <p>:skip_control_cubes: bool, True will exclude control cubes from count</p> <p>Returns:</p> Type Description <code>int</code> <p>int, count</p> Source code in <code>TM1py/Services/CubeService.py</code> <pre><code>def get_number_of_cubes(self, skip_control_cubes: bool = False, **kwargs) -&gt; int:\n    \"\"\"Ask TM1 Server for count of cubes\n\n    :skip_control_cubes: bool, True will exclude control cubes from count\n    :return: int, count\n    \"\"\"\n    if skip_control_cubes:\n        response = self._rest.GET(url=format_url(\"/ModelCubes()?$select=Name&amp;$top=0&amp;$count\"), **kwargs)\n        return int(response.json()[\"@odata.count\"])\n\n    return int(self._rest.GET(url=format_url(\"/Cubes/$count\"), **kwargs).text)\n</code></pre>"},{"location":"reference/services/cubeservice/#TM1py.Services.CubeService.CubeService.get_random_intersection","title":"<code>get_random_intersection(cube_name, unique_names=False)</code>","text":"<p>Get a random Intersection in a cube used mostly for regression testing. Not optimized, in terms of performance. Function Loads ALL elements for EACH dim...</p> <p>Parameters:</p> Name Type Description Default <code>cube_name</code> <code>str</code> required <code>unique_names</code> <code>bool</code> <p>unique names instead of plain element names</p> <code>False</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of elements</p> Source code in <code>TM1py/Services/CubeService.py</code> <pre><code>def get_random_intersection(self, cube_name: str, unique_names: bool = False) -&gt; List[str]:\n    \"\"\"Get a random Intersection in a cube\n    used mostly for regression testing.\n    Not optimized, in terms of performance. Function Loads ALL elements for EACH dim...\n\n    :param cube_name:\n    :param unique_names: unique names instead of plain element names\n    :return: List of elements\n    \"\"\"\n    from TM1py.Services import DimensionService\n\n    dimension_service = DimensionService(self._rest)\n    dimensions = self.get_dimension_names(cube_name)\n    elements = []\n    for dimension in dimensions:\n        hierarchy = dimension_service.get(dimension).default_hierarchy\n        element = random.choice(list((hierarchy.elements.keys())))\n        if unique_names:\n            element = \"[{}].[{}]\".format(dimension, element)\n        elements.append(element)\n    return elements\n</code></pre>"},{"location":"reference/services/cubeservice/#TM1py.Services.CubeService.CubeService.get_storage_dimension_order","title":"<code>get_storage_dimension_order(cube_name, **kwargs)</code>","text":"<p>Get the storage dimension order of a cube</p> <p>Parameters:</p> Name Type Description Default <code>cube_name</code> <code>str</code> required <p>Returns:</p> Type Description <code>List[str]</code> <p>List of dimension names</p> Source code in <code>TM1py/Services/CubeService.py</code> <pre><code>@require_version(version=\"11.4\")\ndef get_storage_dimension_order(self, cube_name: str, **kwargs) -&gt; List[str]:\n    \"\"\"Get the storage dimension order of a cube\n\n    :param cube_name:\n    :return: List of dimension names\n    \"\"\"\n    url = format_url(\"/Cubes('{}')/tm1.DimensionsStorageOrder()?$select=Name\", cube_name)\n    response = self._rest.GET(url, **kwargs)\n    return [dimension[\"Name\"] for dimension in response.json()[\"value\"]]\n</code></pre>"},{"location":"reference/services/cubeservice/#TM1py.Services.CubeService.CubeService.get_vmm","title":"<code>get_vmm(cube_name)</code>","text":"Source code in <code>TM1py/Services/CubeService.py</code> <pre><code>@require_data_admin\n@require_version(version=\"11.8.20\")\ndef get_vmm(self, cube_name: str):\n    url = format_url(\"/Cubes('{}')?$select=ViewStorageMaxMemory\", cube_name)\n    response = self._rest.GET(url)\n    return response.json()[\"ViewStorageMaxMemory\"]\n</code></pre>"},{"location":"reference/services/cubeservice/#TM1py.Services.CubeService.CubeService.get_vmt","title":"<code>get_vmt(cube_name)</code>","text":"Source code in <code>TM1py/Services/CubeService.py</code> <pre><code>@require_data_admin\n@require_version(version=\"11.8.20\")\ndef get_vmt(self, cube_name: str):\n    url = format_url(\"/Cubes('{}')?$select=ViewStorageMinTime\", cube_name)\n    response = self._rest.GET(url)\n    return response.json()[\"ViewStorageMinTime\"]\n</code></pre>"},{"location":"reference/services/cubeservice/#TM1py.Services.CubeService.CubeService.load","title":"<code>load(cube_name, **kwargs)</code>","text":"<p>Load the cube into memory on the server</p> <p>Parameters:</p> Name Type Description Default <code>cube_name</code> <code>str</code> required <p>Returns:</p> Type Description <code>Response</code> Source code in <code>TM1py/Services/CubeService.py</code> <pre><code>@require_data_admin\n@require_version(version=\"11.6\")\ndef load(self, cube_name: str, **kwargs) -&gt; Response:\n    \"\"\"Load the cube into memory on the server\n\n    :param cube_name:\n    :return:\n    \"\"\"\n    url = format_url(\"/Cubes('{}')/tm1.Load\", cube_name)\n    return self._rest.POST(url=url, **kwargs)\n</code></pre>"},{"location":"reference/services/cubeservice/#TM1py.Services.CubeService.CubeService.lock","title":"<code>lock(cube_name, **kwargs)</code>","text":"<p>Locks the cube to prevent any users from modifying it</p> <p>Parameters:</p> Name Type Description Default <code>cube_name</code> <code>str</code> required <p>Returns:</p> Type Description <code>Response</code> Source code in <code>TM1py/Services/CubeService.py</code> <pre><code>def lock(self, cube_name: str, **kwargs) -&gt; Response:\n    \"\"\"Locks the cube to prevent any users from modifying it\n\n    :param cube_name:\n    :return:\n    \"\"\"\n    url = format_url(\"/Cubes('{}')/tm1.Lock\", cube_name)\n    return self._rest.POST(url=url, **kwargs)\n</code></pre>"},{"location":"reference/services/cubeservice/#TM1py.Services.CubeService.CubeService.search_for_dimension","title":"<code>search_for_dimension(dimension_name, skip_control_cubes=False, **kwargs)</code>","text":"<p>Ask TM1 Server for list of cube names that contain specific dimension</p> <p>Parameters:</p> Name Type Description Default <code>dimension_name</code> <code>str</code> <p>string, valid dimension name (case insensitive)</p> required <code>skip_control_cubes</code> <code>bool</code> <p>bool, True will exclude control cubes from result</p> <code>False</code> Source code in <code>TM1py/Services/CubeService.py</code> <pre><code>def search_for_dimension(self, dimension_name: str, skip_control_cubes: bool = False, **kwargs) -&gt; List[str]:\n    \"\"\"Ask TM1 Server for list of cube names that contain specific dimension\n\n    :param dimension_name: string, valid dimension name (case insensitive)\n    :param skip_control_cubes: bool, True will exclude control cubes from result\n    \"\"\"\n    url = format_url(\n        \"/{}?$select=Name&amp;$filter=Dimensions/any(d: replace(tolower(d/Name), ' ', '') eq '{}')\",\n        \"ModelCubes()\" if skip_control_cubes else \"Cubes\",\n        dimension_name.lower().replace(\" \", \"\"),\n    )\n    response = self._rest.GET(url, **kwargs)\n    cubes = list(entry[\"Name\"] for entry in response.json()[\"value\"])\n    return cubes\n</code></pre>"},{"location":"reference/services/cubeservice/#TM1py.Services.CubeService.CubeService.search_for_dimension_substring","title":"<code>search_for_dimension_substring(substring, skip_control_cubes=False, **kwargs)</code>","text":"<p>Ask TM1 Server for a dictinary of cube names with the dimension whose name contains the substring</p> <p>Parameters:</p> Name Type Description Default <code>substring</code> <code>str</code> <p>string to search for in dim name</p> required <code>skip_control_cubes</code> <code>bool</code> <p>bool, True will exclude control cubes from result</p> <code>False</code> Source code in <code>TM1py/Services/CubeService.py</code> <pre><code>def search_for_dimension_substring(\n    self, substring: str, skip_control_cubes: bool = False, **kwargs\n) -&gt; Dict[str, List[str]]:\n    \"\"\"Ask TM1 Server for a dictinary of cube names with the dimension whose name contains the substring\n\n    :param substring: string to search for in dim name\n    :param skip_control_cubes: bool, True will exclude control cubes from result\n    \"\"\"\n    substring = substring.lower().replace(\" \", \"\")\n\n    url = format_url(\n        \"/{}?$select=Name&amp;$filter=Dimensions/any(d: contains(replace(tolower(d/Name), ' ', ''),'{}'))\"\n        + \"&amp;$expand=Dimensions($select=Name;$filter=contains(replace(tolower(Name), ' ', ''), '{}'))\",\n        \"ModelCubes()\" if skip_control_cubes else \"Cubes\",\n        substring,\n        substring,\n    )\n\n    response = self._rest.GET(url, **kwargs)\n    cube_dict = {entry[\"Name\"]: [dim[\"Name\"] for dim in entry[\"Dimensions\"]] for entry in response.json()[\"value\"]}\n    return cube_dict\n</code></pre>"},{"location":"reference/services/cubeservice/#TM1py.Services.CubeService.CubeService.search_for_rule_substring","title":"<code>search_for_rule_substring(substring, skip_control_cubes=False, case_insensitive=True, space_insensitive=True, **kwargs)</code>","text":"<p>get all cubes from TM1 Server as TM1py.Cube instances where rules for given cube contain specified substring</p> <p>Parameters:</p> Name Type Description Default <code>substring</code> <code>str</code> <p>string to search for in rules</p> required <code>skip_control_cubes</code> <code>bool</code> <p>bool, True will exclude control cubes from result</p> <code>False</code> <code>case_insensitive</code> <p>case agnostic search</p> <code>True</code> <code>space_insensitive</code> <p>space agnostic search</p> <code>True</code> <p>Returns:</p> Type Description <code>List[Cube]</code> <p>List of TM1py.Cube instances</p> Source code in <code>TM1py/Services/CubeService.py</code> <pre><code>def search_for_rule_substring(\n    self, substring: str, skip_control_cubes: bool = False, case_insensitive=True, space_insensitive=True, **kwargs\n) -&gt; List[Cube]:\n    \"\"\"get all cubes from TM1 Server as TM1py.Cube instances where rules for given cube contain specified substring\n\n    :param substring: string to search for in rules\n    :param skip_control_cubes: bool, True will exclude control cubes from result\n    :param case_insensitive: case agnostic search\n    :param space_insensitive: space agnostic search\n    :return: List of TM1py.Cube instances\n    \"\"\"\n    substring = substring.lower().replace(\" \", \"\")\n\n    url_filter = \"Rules ne null and contains(\"\n    if case_insensitive and space_insensitive:\n        url_filter += format_url(\"tolower(replace(Rules, ' ', '')),'{}')\", substring)\n    elif case_insensitive:\n        url_filter += format_url(\"tolower(Rules),'{}')\", substring)\n    elif space_insensitive:\n        url_filter += format_url(\"replace(Rules, ' ', ''),'{}')\", substring)\n    else:\n        url_filter += format_url(\"Rules,'{}')\", substring)\n\n    url = (\n        f\"/{'ModelCubes()' if skip_control_cubes else 'Cubes'}?$filter={url_filter}\"\n        f\"&amp;$expand=Dimensions($select=Name)\"\n    )\n\n    response = self._rest.GET(url, **kwargs)\n    cubes = [Cube.from_dict(cube_as_dict=cube) for cube in response.json()[\"value\"]]\n    return cubes\n</code></pre>"},{"location":"reference/services/cubeservice/#TM1py.Services.CubeService.CubeService.set_vmm","title":"<code>set_vmm(cube_name, vmm)</code>","text":"Source code in <code>TM1py/Services/CubeService.py</code> <pre><code>@require_data_admin\n@require_version(version=\"11.8.20\")\ndef set_vmm(self, cube_name: str, vmm: int):\n    url = format_url(\"/Cubes('{}')\", cube_name)\n    payload = {\"ViewStorageMaxMemory\": vmm}\n    self._rest.PATCH(url=url, data=json.dumps(payload))\n</code></pre>"},{"location":"reference/services/cubeservice/#TM1py.Services.CubeService.CubeService.set_vmt","title":"<code>set_vmt(cube_name, vmt)</code>","text":"Source code in <code>TM1py/Services/CubeService.py</code> <pre><code>@require_data_admin\n@require_version(version=\"11.8.20\")\ndef set_vmt(self, cube_name: str, vmt: int):\n    url = format_url(\"/Cubes('{}')\", cube_name)\n    payload = {\"ViewStorageMinTime\": vmt}\n    self._rest.PATCH(url=url, data=json.dumps(payload))\n</code></pre>"},{"location":"reference/services/cubeservice/#TM1py.Services.CubeService.CubeService.unload","title":"<code>unload(cube_name, **kwargs)</code>","text":"<p>Unload the cube from memory</p> <p>Parameters:</p> Name Type Description Default <code>cube_name</code> <code>str</code> required <p>Returns:</p> Type Description <code>Response</code> Source code in <code>TM1py/Services/CubeService.py</code> <pre><code>@require_data_admin\n@require_version(version=\"11.6\")\ndef unload(self, cube_name: str, **kwargs) -&gt; Response:\n    \"\"\"Unload the cube from memory\n\n    :param cube_name:\n    :return:\n    \"\"\"\n    url = format_url(\"/Cubes('{}')/tm1.Unload\", cube_name)\n    return self._rest.POST(url=url, **kwargs)\n</code></pre>"},{"location":"reference/services/cubeservice/#TM1py.Services.CubeService.CubeService.unlock","title":"<code>unlock(cube_name, **kwargs)</code>","text":"<p>Unlocks the cube to allow modifications</p> <p>Parameters:</p> Name Type Description Default <code>cube_name</code> <code>str</code> required <p>Returns:</p> Type Description <code>Response</code> Source code in <code>TM1py/Services/CubeService.py</code> <pre><code>def unlock(self, cube_name: str, **kwargs) -&gt; Response:\n    \"\"\"Unlocks the cube to allow modifications\n\n    :param cube_name:\n    :return:\n    \"\"\"\n    url = format_url(\"/Cubes('{}')/tm1.Unlock\", cube_name)\n    return self._rest.POST(url=url, **kwargs)\n</code></pre>"},{"location":"reference/services/cubeservice/#TM1py.Services.CubeService.CubeService.update","title":"<code>update(cube, **kwargs)</code>","text":"<p>Update existing cube on TM1 Server</p> <p>Parameters:</p> Name Type Description Default <code>cube</code> <code>Cube</code> <p>instance of TM1py.Cube</p> required <p>Returns:</p> Type Description <code>Response</code> <p>response</p> Source code in <code>TM1py/Services/CubeService.py</code> <pre><code>def update(self, cube: Cube, **kwargs) -&gt; Response:\n    \"\"\"Update existing cube on TM1 Server\n\n    :param cube: instance of TM1py.Cube\n    :return: response\n    \"\"\"\n    url = format_url(\"/Cubes('{}')\", cube.name)\n    return self._rest.PATCH(url, cube.body, **kwargs)\n</code></pre>"},{"location":"reference/services/cubeservice/#TM1py.Services.CubeService.CubeService.update_or_create","title":"<code>update_or_create(cube, **kwargs)</code>","text":"<p>update if exists else create</p> <p>Parameters:</p> Name Type Description Default <code>cube</code> <code>Cube</code> required <p>Returns:</p> Type Description <code>Response</code> Source code in <code>TM1py/Services/CubeService.py</code> <pre><code>def update_or_create(self, cube: Cube, **kwargs) -&gt; Response:\n    \"\"\"update if exists else create\n\n    :param cube:\n    :return:\n    \"\"\"\n    if self.exists(cube_name=cube.name, **kwargs):\n        return self.update(cube=cube, **kwargs)\n\n    return self.create(cube=cube, **kwargs)\n</code></pre>"},{"location":"reference/services/cubeservice/#TM1py.Services.CubeService.CubeService.update_or_create_rules","title":"<code>update_or_create_rules(cube_name, rules, **kwargs)</code>","text":"<p>Update if exists, else create rules from a TM1 Server cube</p> <p>Parameters:</p> Name Type Description Default <code>cube_name</code> <code>str</code> <p>name of a cube</p> required <code>rules</code> <code>Union[str, Rules]</code> <p>rules content</p> required <p>Returns:</p> Type Description <code>Response</code> <p>response</p> Source code in <code>TM1py/Services/CubeService.py</code> <pre><code>def update_or_create_rules(self, cube_name: str, rules: Union[str, Rules], **kwargs) -&gt; Response:\n    \"\"\"Update if exists, else create rules from a TM1 Server cube\n\n    :param cube_name: name of a cube\n    :param rules: rules content\n    :return: response\n    \"\"\"\n    if isinstance(rules, str):\n        rules = Rules(rules=rules)\n    if not isinstance(rules, Rules):\n        raise ValueError(\"rules must be type str or Rules\")\n\n    url = format_url(\"/Cubes('{}')\", cube_name)\n    response = self._rest.PATCH(url=url, data=rules.body, **kwargs)\n    return response\n</code></pre>"},{"location":"reference/services/cubeservice/#TM1py.Services.CubeService.CubeService.update_storage_dimension_order","title":"<code>update_storage_dimension_order(cube_name, dimension_names)</code>","text":"<p>Update the storage dimension order of a cube</p> <p>Parameters:</p> Name Type Description Default <code>cube_name</code> <code>str</code> required <code>dimension_names</code> <code>Iterable[str]</code> required <p>Returns:</p> Type Description <code>float</code> <p>Float: -23.076489699337078 (percent change in memory usage)</p> Source code in <code>TM1py/Services/CubeService.py</code> <pre><code>@require_data_admin\n@require_version(version=\"11.4\")\ndef update_storage_dimension_order(self, cube_name: str, dimension_names: Iterable[str]) -&gt; float:\n    \"\"\"Update the storage dimension order of a cube\n\n    :param cube_name:\n    :param dimension_names:\n    :return:  Float: -23.076489699337078 (percent change in memory usage)\n    \"\"\"\n    url = format_url(\"/Cubes('{}')/tm1.ReorderDimensions\", cube_name)\n    payload = dict()\n    payload[\"Dimensions@odata.bind\"] = [format_url(\"Dimensions('{}')\", dimension) for dimension in dimension_names]\n    response = self._rest.POST(url=url, data=json.dumps(payload))\n    return response.json()[\"value\"]\n</code></pre>"},{"location":"reference/services/dimensionservice/","title":"DimensionService","text":""},{"location":"reference/services/dimensionservice/#TM1py.Services.DimensionService.DimensionService","title":"<code>DimensionService(rest)</code>","text":"<p>               Bases: <code>ObjectService</code></p> <p>Service to handle Object Updates for TM1 Dimensions</p> Source code in <code>TM1py/Services/DimensionService.py</code> <pre><code>def __init__(self, rest: RestService):\n    super().__init__(rest)\n    self.hierarchies = HierarchyService(rest)\n    self.subsets = SubsetService(rest)\n</code></pre>"},{"location":"reference/services/dimensionservice/#TM1py.Services.DimensionService.DimensionService.hierarchies","title":"<code>hierarchies = HierarchyService(rest)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/services/dimensionservice/#TM1py.Services.DimensionService.DimensionService.subsets","title":"<code>subsets = SubsetService(rest)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/services/dimensionservice/#TM1py.Services.DimensionService.DimensionService.create","title":"<code>create(dimension, **kwargs)</code>","text":"<p>Create a dimension</p> <p>Parameters:</p> Name Type Description Default <code>dimension</code> <code>Dimension</code> <p>instance of TM1py.Dimension</p> required <p>Returns:</p> Type Description <code>Response</code> <p>response</p> Source code in <code>TM1py/Services/DimensionService.py</code> <pre><code>def create(self, dimension: Dimension, **kwargs) -&gt; Response:\n    \"\"\"Create a dimension\n\n    :param dimension: instance of TM1py.Dimension\n    :return: response\n    \"\"\"\n    # If Dimension exists. throw Exception\n    if self.exists(dimension.name):\n        raise RuntimeError(\"Dimension '{}' already exists\".format(dimension.name))\n    # If not all subsequent calls successful -&gt; undo everything that has been done in this function\n    try:\n        # Create Dimension, Hierarchies, Elements, Edges.\n        url = \"/Dimensions\"\n        response = self._rest.POST(url, dimension.body, **kwargs)\n        # Create ElementAttributes\n        for hierarchy in dimension:\n            if not case_and_space_insensitive_equals(hierarchy.name, \"Leaves\"):\n                self.hierarchies.update_element_attributes(hierarchy, **kwargs)\n    except TM1pyException as e:\n        # undo everything if problem in step 1 or 2\n        if self.exists(dimension.name, **kwargs):\n            self.delete(dimension.name)\n        raise e\n    return response\n</code></pre>"},{"location":"reference/services/dimensionservice/#TM1py.Services.DimensionService.DimensionService.create_element_attributes_through_ti","title":"<code>create_element_attributes_through_ti(dimension, **kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>dimension</code> <code>Dimension</code> <p>Instance of TM1py.Objects.Dimension class</p> required <p>Returns:</p> Type Description Source code in <code>TM1py/Services/DimensionService.py</code> <pre><code>def create_element_attributes_through_ti(self, dimension: Dimension, **kwargs):\n    \"\"\"\n\n    :param dimension: Instance of TM1py.Objects.Dimension class\n    :return:\n    \"\"\"\n    process_service = ProcessService(self._rest)\n    for h in dimension:\n        statements = [\n            \"AttrInsert('{}', '', '{}', '{}');\".format(dimension.name, ea.name, ea.attribute_type[0])\n            for ea in h.element_attributes\n        ]\n        process_service.execute_ti_code(lines_prolog=statements, **kwargs)\n</code></pre>"},{"location":"reference/services/dimensionservice/#TM1py.Services.DimensionService.DimensionService.delete","title":"<code>delete(dimension_name, **kwargs)</code>","text":"<p>Delete a dimension</p> <p>Parameters:</p> Name Type Description Default <code>dimension_name</code> <code>str</code> <p>Name of the dimension</p> required <p>Returns:</p> Type Description <code>Response</code> Source code in <code>TM1py/Services/DimensionService.py</code> <pre><code>def delete(self, dimension_name: str, **kwargs) -&gt; Response:\n    \"\"\"Delete a dimension\n\n    :param dimension_name: Name of the dimension\n    :return:\n    \"\"\"\n    url = format_url(\"/Dimensions('{}')\", dimension_name)\n    return self._rest.DELETE(url, **kwargs)\n</code></pre>"},{"location":"reference/services/dimensionservice/#TM1py.Services.DimensionService.DimensionService.execute_mdx","title":"<code>execute_mdx(dimension_name, mdx, **kwargs)</code>","text":"<p>Execute MDX against Dimension. Requires }ElementAttributes_ Cube of the dimension to exist !</p> <p>Parameters:</p> Name Type Description Default <code>dimension_name</code> <code>str</code> <p>Name of the Dimension</p> required <code>mdx</code> <code>str</code> <p>valid Dimension-MDX Statement</p> required <p>Returns:</p> Type Description <code>List</code> <p>List of Element names</p> Source code in <code>TM1py/Services/DimensionService.py</code> <pre><code>def execute_mdx(self, dimension_name: str, mdx: str, **kwargs) -&gt; List:\n    \"\"\"Execute MDX against Dimension.\n    Requires }ElementAttributes_ Cube of the dimension to exist !\n\n    :param dimension_name: Name of the Dimension\n    :param mdx: valid Dimension-MDX Statement\n    :return: List of Element names\n    \"\"\"\n\n    warnings.warn(\n        \"execute_mdx() will be deprecated; use ElementService execute_set_mdx_element_names().\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n\n    mdx_skeleton = (\n        \"SELECT \"\n        \"{} ON ROWS, \"\n        \"{{ [}}ElementAttributes_{}].DefaultMember }} ON COLUMNS  \"\n        \"FROM [}}ElementAttributes_{}]\"\n    )\n    mdx_full = mdx_skeleton.format(mdx, dimension_name, dimension_name)\n    request = (\n        \"/ExecuteMDX?$expand=Axes(\"\n        \"$filter=Ordinal eq 1;\"\n        \"$expand=Tuples($expand=Members($select=Ordinal;$expand=Element($select=Name))))\"\n    )\n    payload = {\"MDX\": mdx_full}\n    response = self._rest.POST(request, json.dumps(payload, ensure_ascii=False), **kwargs)\n    raw_dict = response.json()\n    return [row_tuple[\"Members\"][0][\"Element\"][\"Name\"] for row_tuple in raw_dict[\"Axes\"][0][\"Tuples\"]]\n</code></pre>"},{"location":"reference/services/dimensionservice/#TM1py.Services.DimensionService.DimensionService.exists","title":"<code>exists(dimension_name, **kwargs)</code>","text":"<p>Check if dimension exists</p> <p>Returns:</p> Type Description <code>bool</code> Source code in <code>TM1py/Services/DimensionService.py</code> <pre><code>def exists(self, dimension_name: str, **kwargs) -&gt; bool:\n    \"\"\"Check if dimension exists\n\n    :return:\n    \"\"\"\n    url = format_url(\"/Dimensions('{}')\", dimension_name)\n    return self._exists(url, **kwargs)\n</code></pre>"},{"location":"reference/services/dimensionservice/#TM1py.Services.DimensionService.DimensionService.get","title":"<code>get(dimension_name, **kwargs)</code>","text":"<p>Get a Dimension</p> <p>Parameters:</p> Name Type Description Default <code>dimension_name</code> <code>str</code> required <p>Returns:</p> Type Description <code>Dimension</code> Source code in <code>TM1py/Services/DimensionService.py</code> <pre><code>def get(self, dimension_name: str, **kwargs) -&gt; Dimension:\n    \"\"\"Get a Dimension\n\n    :param dimension_name:\n    :return:\n    \"\"\"\n    url = format_url(\"/Dimensions('{}')?$expand=Hierarchies($expand=*)\", dimension_name)\n    response = self._rest.GET(url, **kwargs)\n    return Dimension.from_json(response.text)\n</code></pre>"},{"location":"reference/services/dimensionservice/#TM1py.Services.DimensionService.DimensionService.get_all_names","title":"<code>get_all_names(skip_control_dims=False, **kwargs)</code>","text":"<p>Ask TM1 Server for list of all dimension names</p> <p>:skip_control_dims: bool, True to skip control dims :Returns:     List of Strings</p> Source code in <code>TM1py/Services/DimensionService.py</code> <pre><code>def get_all_names(self, skip_control_dims: bool = False, **kwargs) -&gt; List[str]:\n    \"\"\"Ask TM1 Server for list of all dimension names\n\n    :skip_control_dims: bool, True to skip control dims\n    :Returns:\n        List of Strings\n    \"\"\"\n    url = format_url(\"/{}?$select=Name\", \"ModelDimensions()\" if skip_control_dims else \"Dimensions\")\n\n    response = self._rest.GET(url, **kwargs)\n\n    dimension_names = list(entry[\"Name\"] for entry in response.json()[\"value\"])\n    return dimension_names\n</code></pre>"},{"location":"reference/services/dimensionservice/#TM1py.Services.DimensionService.DimensionService.get_number_of_dimensions","title":"<code>get_number_of_dimensions(skip_control_dims=False, **kwargs)</code>","text":"<p>Ask TM1 Server for number of dimensions</p> <p>:skip_control_dims: bool, True to exclude control dims from count</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of dimensions</p> Source code in <code>TM1py/Services/DimensionService.py</code> <pre><code>def get_number_of_dimensions(self, skip_control_dims: bool = False, **kwargs) -&gt; int:\n    \"\"\"Ask TM1 Server for number of dimensions\n\n    :skip_control_dims: bool, True to exclude control dims from count\n    :return: Number of dimensions\n    \"\"\"\n\n    if skip_control_dims:\n        response = self._rest.GET(\"/ModelDimensions()?$select=Name&amp;$top=0&amp;$count\", **kwargs)\n        return response.json()[\"@odata.count\"]\n\n    return int(self._rest.GET(\"/Dimensions/$count\", **kwargs).text)\n</code></pre>"},{"location":"reference/services/dimensionservice/#TM1py.Services.DimensionService.DimensionService.update","title":"<code>update(dimension, keep_existing_attributes=False, **kwargs)</code>","text":"<p>Update an existing dimension</p> <p>Parameters:</p> Name Type Description Default <code>dimension</code> <code>Dimension</code> <p>instance of TM1py.Dimension</p> required <code>keep_existing_attributes</code> <p>True to make sure existing attributes are not removed</p> <code>False</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>TM1py/Services/DimensionService.py</code> <pre><code>def update(self, dimension: Dimension, keep_existing_attributes=False, **kwargs):\n    \"\"\"Update an existing dimension\n\n    :param dimension: instance of TM1py.Dimension\n    :param keep_existing_attributes: True to make sure existing attributes are not removed\n    :return: None\n    \"\"\"\n    # delete hierarchies that have been removed from the dimension object\n    hierarchies_to_be_removed = CaseAndSpaceInsensitiveSet(\n        *self.hierarchies.get_all_names(dimension.name, **kwargs)\n    )\n    for hierarchy in dimension.hierarchy_names:\n        hierarchies_to_be_removed.discard(hierarchy)\n\n    # update all Hierarchies except for the implicitly maintained 'Leaves' Hierarchy\n    for hierarchy in dimension:\n        if not case_and_space_insensitive_equals(hierarchy.name, \"Leaves\"):\n            if self.hierarchies.exists(hierarchy.dimension_name, hierarchy.name, **kwargs):\n                self.hierarchies.update(hierarchy, keep_existing_attributes=keep_existing_attributes, **kwargs)\n            else:\n                self.hierarchies.create(hierarchy, **kwargs)\n\n    # Edge case: elements in leaves hierarchy that do not exist in other hierarchies\n    if \"Leaves\" in dimension:\n        existing_leaves = CaseAndSpaceInsensitiveSet(\n            self.hierarchies.elements.get_leaf_element_names(dimension.name, \"Leaves\")\n        )\n\n        leaves_to_create = list()\n        for leaf in dimension.get_hierarchy(\"Leaves\"):\n            if leaf.name not in existing_leaves:\n                leaves_to_create.append(leaf)\n\n        if leaves_to_create:\n            self.hierarchies.elements.add_elements(\n                dimension_name=dimension.name, hierarchy_name=\"Leaves\", elements=leaves_to_create\n            )\n\n    for hierarchy_name in hierarchies_to_be_removed:\n        if not case_and_space_insensitive_equals(hierarchy_name, \"Leaves\"):\n            self.hierarchies.delete(dimension_name=dimension.name, hierarchy_name=hierarchy_name, **kwargs)\n</code></pre>"},{"location":"reference/services/dimensionservice/#TM1py.Services.DimensionService.DimensionService.update_or_create","title":"<code>update_or_create(dimension, **kwargs)</code>","text":"<p>update if exists else create</p> <p>Parameters:</p> Name Type Description Default <code>dimension</code> <code>Dimension</code> required <p>Returns:</p> Type Description Source code in <code>TM1py/Services/DimensionService.py</code> <pre><code>def update_or_create(self, dimension: Dimension, **kwargs):\n    \"\"\"update if exists else create\n\n    :param dimension:\n    :return:\n    \"\"\"\n    if self.exists(dimension_name=dimension.name, **kwargs):\n        self.update(dimension=dimension, **kwargs)\n    else:\n        self.create(dimension=dimension, **kwargs)\n</code></pre>"},{"location":"reference/services/dimensionservice/#TM1py.Services.DimensionService.DimensionService.uses_alternate_hierarchies","title":"<code>uses_alternate_hierarchies(dimension_name, **kwargs)</code>","text":"Source code in <code>TM1py/Services/DimensionService.py</code> <pre><code>def uses_alternate_hierarchies(self, dimension_name: str, **kwargs) -&gt; bool:\n    hierarchy_names = self.hierarchies.get_all_names(dimension_name, **kwargs)\n    if len(hierarchy_names) &gt; 1:\n        return True\n\n    return not case_and_space_insensitive_equals(dimension_name, hierarchy_names[0])\n</code></pre>"},{"location":"reference/services/elementservice/","title":"ElementService","text":""},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService","title":"<code>ElementService(rest)</code>","text":"<p>               Bases: <code>ObjectService</code></p> <p>Service to handle Object Updates for TM1 Dimension (resp. Hierarchy) Elements</p> Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def __init__(self, rest: RestService):\n    super().__init__(rest)\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.add_edges","title":"<code>add_edges(dimension_name, hierarchy_name=None, edges=None, **kwargs)</code>","text":"<p>Add Edges to hierarchy. Fails if one edge already exists.</p> <p>Parameters:</p> Name Type Description Default <code>dimension_name</code> <code>str</code> required <code>hierarchy_name</code> <code>str</code> <code>None</code> <code>edges</code> <code>Dict[Tuple[str, str], int]</code> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def add_edges(\n    self, dimension_name: str, hierarchy_name: str = None, edges: Dict[Tuple[str, str], int] = None, **kwargs\n) -&gt; Response:\n    \"\"\"Add Edges to hierarchy. Fails if one edge already exists.\n\n    :param dimension_name:\n    :param hierarchy_name:\n    :param edges:\n    :return:\n    \"\"\"\n    if not hierarchy_name:\n        hierarchy_name = dimension_name\n\n    url = format_url(\"/Dimensions('{}')/Hierarchies('{}')/Edges\", dimension_name, hierarchy_name)\n    body = [\n        {\"ParentName\": parent, \"ComponentName\": component, \"Weight\": float(weight)}\n        for (parent, component), weight in edges.items()\n    ]\n\n    return self._rest.POST(url=url, data=json.dumps(body), **kwargs)\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.add_element_attributes","title":"<code>add_element_attributes(dimension_name, hierarchy_name, element_attributes, **kwargs)</code>","text":"<p>Add element attributes to hierarchy. Fails if one element attribute already exists.</p> <p>Parameters:</p> Name Type Description Default <code>dimension_name</code> <code>str</code> required <code>hierarchy_name</code> <code>str</code> required <code>element_attributes</code> <code>List[ElementAttribute]</code> required <p>Returns:</p> Type Description Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def add_element_attributes(\n    self, dimension_name: str, hierarchy_name: str, element_attributes: List[ElementAttribute], **kwargs\n):\n    \"\"\"Add element attributes to hierarchy. Fails if one element attribute already exists.\n\n    :param dimension_name:\n    :param hierarchy_name:\n    :param element_attributes:\n    :return:\n    \"\"\"\n    url = format_url(\"/Dimensions('{}')/Hierarchies('{}')/ElementAttributes\", dimension_name, hierarchy_name)\n    body = [element_attribute.body_as_dict for element_attribute in element_attributes]\n\n    return self._rest.POST(url=url, data=json.dumps(body), **kwargs)\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.add_elements","title":"<code>add_elements(dimension_name, hierarchy_name, elements, **kwargs)</code>","text":"<p>Add elements to hierarchy. Fails if one element already exists.</p> <p>Parameters:</p> Name Type Description Default <code>dimension_name</code> <code>str</code> required <code>hierarchy_name</code> <code>str</code> required <code>elements</code> <code>Iterable[Element]</code> required <p>Returns:</p> Type Description Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def add_elements(self, dimension_name: str, hierarchy_name: str, elements: Iterable[Element], **kwargs):\n    \"\"\"Add elements to hierarchy. Fails if one element already exists.\n\n    :param dimension_name:\n    :param hierarchy_name:\n    :param elements:\n    :return:\n    \"\"\"\n    url = format_url(\"/Dimensions('{}')/Hierarchies('{}')/Elements\", dimension_name, hierarchy_name)\n    body = [element.body_as_dict for element in elements]\n\n    return self._rest.POST(url=url, data=json.dumps(body), **kwargs)\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.attribute_cube_exists","title":"<code>attribute_cube_exists(dimension_name, **kwargs)</code>","text":"Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def attribute_cube_exists(self, dimension_name: str, **kwargs) -&gt; bool:\n    url = format_url(\"/Cubes('{}')\", self.ELEMENT_ATTRIBUTES_PREFIX + dimension_name)\n    return self._exists(url, **kwargs)\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.create","title":"<code>create(dimension_name, hierarchy_name, element, **kwargs)</code>","text":"Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def create(self, dimension_name: str, hierarchy_name: str, element: Element, **kwargs) -&gt; Response:\n    url = format_url(\"/Dimensions('{}')/Hierarchies('{}')/Elements\", dimension_name, hierarchy_name)\n    return self._rest.POST(url, element.body, **kwargs)\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.create_element_attribute","title":"<code>create_element_attribute(dimension_name, hierarchy_name, element_attribute, **kwargs)</code>","text":"<p>like AttrInsert</p> <p>Parameters:</p> Name Type Description Default <code>dimension_name</code> <code>str</code> required <code>hierarchy_name</code> <code>str</code> required <code>element_attribute</code> <code>ElementAttribute</code> <p>instance of TM1py.ElementAttribute</p> required <p>Returns:</p> Type Description <code>Response</code> Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def create_element_attribute(\n    self, dimension_name: str, hierarchy_name: str, element_attribute: ElementAttribute, **kwargs\n) -&gt; Response:\n    \"\"\"like AttrInsert\n\n    :param dimension_name:\n    :param hierarchy_name:\n    :param element_attribute: instance of TM1py.ElementAttribute\n    :return:\n    \"\"\"\n    url = format_url(\"/Dimensions('{}')/Hierarchies('{}')/ElementAttributes\", dimension_name, hierarchy_name)\n    return self._rest.POST(url, element_attribute.body, **kwargs)\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.delete","title":"<code>delete(dimension_name, hierarchy_name, element_name, **kwargs)</code>","text":"Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def delete(self, dimension_name: str, hierarchy_name: str, element_name: str, **kwargs) -&gt; Response:\n    url = format_url(\n        \"/Dimensions('{}')/Hierarchies('{}')/Elements('{}')\", dimension_name, hierarchy_name, element_name\n    )\n    return self._rest.DELETE(url, **kwargs)\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.delete_edges","title":"<code>delete_edges(dimension_name, hierarchy_name, edges=None, use_ti=False, use_blob=False, remove_blob=True, **kwargs)</code>","text":"Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>@require_version(\"11.4\")\ndef delete_edges(\n    self,\n    dimension_name: str,\n    hierarchy_name: str,\n    edges: Iterable[Tuple[str, str]] = None,\n    use_ti: bool = False,\n    use_blob: bool = False,\n    remove_blob: bool = True,\n    **kwargs,\n):\n    if use_ti:\n        return self.delete_edges_use_ti(dimension_name, hierarchy_name, edges, **kwargs)\n\n    if use_blob:\n        return self.delete_edges_use_blob(dimension_name, hierarchy_name, edges, remove_blob, **kwargs)\n\n    h_service = self._get_hierarchy_service()\n    h = h_service.get(dimension_name, hierarchy_name, **kwargs)\n    for edge in edges:\n        h.remove_edge(parent=edge[0], component=edge[1])\n    h_service.update(h, **kwargs)\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.delete_edges_use_blob","title":"<code>delete_edges_use_blob(dimension_name, hierarchy_name, edges=None, remove_blob=True, **kwargs)</code>","text":"<p>Remove edges in TM1 via an unbound TI process having an uploaded CSV as the data source.</p> <p>Parameters:</p> Name Type Description Default <code>dimension_name</code> <code>str</code> <p>The name of the dimension.</p> required <code>hierarchy_name</code> <code>str</code> <p>The name of the hierarchy.</p> required <code>edges</code> <code>List[str]</code> <p>A list of tuples representing the edges to remove, where each tuple contains a parent and a child.</p> <code>None</code> <code>remove_blob</code> <code>bool</code> <p>A boolean indicating whether to remove the parent-child file after use (default: True).</p> <code>True</code> <code>kwargs</code> <p>Additional arguments for the process execution.</p> <code>{}</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>@require_data_admin\n@require_ops_admin\ndef delete_edges_use_blob(\n    self, dimension_name: str, hierarchy_name: str, edges: List[str] = None, remove_blob: bool = True, **kwargs\n):\n    \"\"\"\n    Remove edges in TM1 via an unbound TI process having an uploaded CSV as the data source.\n\n    :param dimension_name: The name of the dimension.\n    :param hierarchy_name: The name of the hierarchy.\n    :param edges: A list of tuples representing the edges to remove, where each tuple contains a parent and a child.\n    :param remove_blob: A boolean indicating whether to remove the parent-child file after use (default: True).\n    :param kwargs: Additional arguments for the process execution.\n    :return: None\n    \"\"\"\n    if not edges:\n        return\n\n    process_service = ProcessService(self._rest)\n    file_service = FileService(self._rest)\n\n    unique_name = self.suggest_unique_object_name()\n\n    # Transform cells to format that's consumable for TI\n    csv_content = StringIO()\n    csv_writer = csv.writer(csv_content, delimiter=\",\", quoting=csv.QUOTE_ALL)\n    csv_writer.writerows(list(edge) for edge in edges)\n\n    file_name = f\"{unique_name}.csv\"\n    file_service.create(file_name=file_name, file_content=csv_content.getvalue().encode(\"utf-8\"), **kwargs)\n\n    try:\n        # Create and execute unbound TI process to delete edges using blob file\n        process = self._build_unwind_hierarchy_edges_from_blob_process(\n            dimension_name=dimension_name,\n            hierarchy_name=hierarchy_name,\n            process_name=unique_name,\n            blob_filename=file_name,\n        )\n\n        success, status, log_file = process_service.execute_process_with_return(process=process, **kwargs)\n        if not success:\n            if status in [\"HasMinorErrors\"]:\n                raise TM1pyWritePartialFailureException([status], [log_file], 1)\n            else:\n                raise TM1pyWriteFailureException([status], [log_file])\n\n    finally:\n        if remove_blob:\n            file_service.delete(file_name=file_name)\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.delete_edges_use_ti","title":"<code>delete_edges_use_ti(dimension_name, hierarchy_name, edges=None, **kwargs)</code>","text":"Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def delete_edges_use_ti(self, dimension_name: str, hierarchy_name: str, edges: List[str] = None, **kwargs):\n    if not edges:\n        return\n\n    def escape_single_quote(text):\n        return text.replace(\"'\", \"''\")\n\n    statements = [\n        f\"HierarchyElementComponentDelete('{dimension_name}', '{hierarchy_name}', \"\n        f\"'{escape_single_quote(parent)}', '{escape_single_quote(child)}');\"\n        for (parent, child) in edges\n    ]\n\n    unbound_process_name = self.suggest_unique_object_name()\n\n    process_service = self._get_process_service()\n    process = Process(name=unbound_process_name, prolog_procedure=\"\\r\\n\".join(statements))\n    success, status, error_log_file = process_service.execute_process_with_return(process, **kwargs)\n    if not success:\n        raise TM1pyException(f\"Failed to delete edges through unbound process. Error: '{error_log_file}'\")\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.delete_element_attribute","title":"<code>delete_element_attribute(dimension_name, hierarchy_name, element_attribute, **kwargs)</code>","text":"<p>like AttrDelete</p> <p>Parameters:</p> Name Type Description Default <code>dimension_name</code> <code>str</code> required <code>hierarchy_name</code> <code>str</code> required <code>element_attribute</code> <code>str</code> <p>instance of TM1py.ElementAttribute</p> required <p>Returns:</p> Type Description <code>Response</code> Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def delete_element_attribute(\n    self, dimension_name: str, hierarchy_name: str, element_attribute: str, **kwargs\n) -&gt; Response:\n    \"\"\"like AttrDelete\n\n    :param dimension_name:\n    :param hierarchy_name:\n    :param element_attribute: instance of TM1py.ElementAttribute\n    :return:\n    \"\"\"\n    url = format_url(\n        \"/Dimensions('}}ElementAttributes_{}')/Hierarchies('}}ElementAttributes_{}')/Elements('{}')\",\n        dimension_name,\n        hierarchy_name,\n        element_attribute,\n    )\n    try:\n        return self._rest.DELETE(url, **kwargs)\n\n    # Fail silently if attribute hierarchy or attribute doesn't exist\n    except TM1pyRestException as ex:\n        if not ex.status_code == 404:\n            raise ex\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.delete_elements","title":"<code>delete_elements(dimension_name, hierarchy_name, element_names=None, use_ti=False, **kwargs)</code>","text":"Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>@require_version(\"11.4\")\ndef delete_elements(\n    self, dimension_name: str, hierarchy_name: str, element_names: List[str] = None, use_ti: bool = False, **kwargs\n):\n    if use_ti:\n        return self.delete_elements_use_ti(dimension_name, hierarchy_name, element_names, **kwargs)\n\n    h_service = self._get_hierarchy_service()\n    h = h_service.get(dimension_name, hierarchy_name, **kwargs)\n    for ele in element_names:\n        h.remove_element(ele)\n    h_service.update(h, **kwargs)\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.delete_elements_use_ti","title":"<code>delete_elements_use_ti(dimension_name, hierarchy_name, element_names=None, **kwargs)</code>","text":"Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def delete_elements_use_ti(\n    self, dimension_name: str, hierarchy_name: str, element_names: List[str] = None, **kwargs\n):\n    subset_service = self._get_subset_service()\n    unbound_process_name = subset_name = self.suggest_unique_object_name()\n    subset = Subset(subset_name, dimension_name, hierarchy_name, elements=element_names)\n    subset_service.update_or_create(subset, private=False, **kwargs)\n    try:\n        process_service = self._get_process_service()\n        process = Process(\n            name=unbound_process_name,\n            prolog_procedure=f\"HierarchyDeleteElements('{dimension_name}', '{hierarchy_name}', '{subset_name}');\",\n        )\n        success, status, error_log_file = process_service.execute_process_with_return(process, **kwargs)\n        if not success:\n            raise TM1pyException(f\"Failed to delete elements through unbound process. Error: '{error_log_file}'\")\n\n    finally:\n        subset_service.delete(subset_name, dimension_name, hierarchy_name, private=False, **kwargs)\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.element_is_ancestor","title":"<code>element_is_ancestor(dimension_name, hierarchy_name, ancestor_name, element_name, method=None)</code>","text":"<p>Element is Ancestor</p> <p>:Note, unlike the related function in TM1 (<code>ELISANC</code> or <code>ElementIsAncestor</code>), this function will return False if an invalid element is passed; but will raise an exception if an invalid dimension, or hierarchy is passed</p> <p>For <code>method</code> you can pass 3 three values value <code>TI</code> performs best, but requires admin permissions Value 'TM1DrillDownMember' performs well when element is a leaf. Value 'Descendants' performs well when <code>ancestor_name</code> and <code>element_name</code> are Consolidations.</p> <p>If no value is passed, function defaults to 'TI' for user with admin permissions and 'TM1DrillDownMember' for users without admin permissions</p> Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def element_is_ancestor(\n    self, dimension_name: str, hierarchy_name: str, ancestor_name: str, element_name: str, method: str = None\n) -&gt; bool:\n    \"\"\"Element is Ancestor\n\n    :Note, unlike the related function in TM1 (`ELISANC` or `ElementIsAncestor`), this function will return False\n    if an invalid element is passed; but will raise an exception if an invalid dimension, or hierarchy is passed\n\n    For `method` you can pass 3 three values\n    value `TI` performs best, but requires admin permissions\n    Value 'TM1DrillDownMember' performs well when element is a leaf.\n    Value 'Descendants' performs well when `ancestor_name` and `element_name` are Consolidations.\n\n    If no value is passed, function defaults to 'TI' for user with admin permissions\n    and 'TM1DrillDownMember' for users without admin permissions\n    \"\"\"\n    if not method:\n        method = \"TI\" if self.is_admin else \"TM1DrillDownMember\"\n\n    if method.upper() == \"TI\":\n        if self._element_is_ancestor_ti(dimension_name, hierarchy_name, element_name, ancestor_name):\n            return True\n\n        if self.hierarchy_exists(dimension_name, hierarchy_name):\n            return False\n\n        raise TM1pyException(f\"Hierarchy: '{hierarchy_name}' does not exist in dimension: '{dimension_name}'\")\n\n    # make sure DESCENDANTS behaves like default TM1DrillDownMember\n    if method.upper() == MDXDrillMethod.DESCENDANTS.name:\n        if not self.exists(dimension_name, hierarchy_name, element_name):\n\n            # case dimension or hierarchy doesn't exist\n            if not self.hierarchy_exists(dimension_name, hierarchy_name):\n                raise TM1pyException(f\"Hierarchy '{hierarchy_name}' does not exist in dimension '{dimension_name}'\")\n\n            # case element or ancestor doesn't exist\n            return False\n\n    if method.upper() == \"TM1DRILLDOWNMEMBER\":\n        if not self.exists(dimension_name, hierarchy_name, element_name):\n\n            # case dimension or hierarchy doesn't exist\n            if not self.hierarchy_exists(dimension_name, hierarchy_name):\n                raise TM1pyException(f\"Hierarchy '{hierarchy_name}' does not exist in dimension '{dimension_name}'\")\n\n            # case element or ancestor doesn't exist\n            return False\n\n    mdx = self._build_drill_intersection_mdx(\n        dimension_name=dimension_name,\n        hierarchy_name=hierarchy_name,\n        first_element_name=ancestor_name,\n        second_element_name=element_name,\n        mdx_method=method,\n        recursive=True,\n    )\n\n    cardinality = self._get_mdx_set_cardinality(mdx)\n    return bool(cardinality)\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.element_is_parent","title":"<code>element_is_parent(dimension_name, hierarchy_name, parent_name, element_name)</code>","text":"<p>Element is Parent :Note, unlike the related function in TM1 (ELISPAR or ElementIsParent), this function will return False :if an invalid element is passed; :but will raise an exception if an invalid dimension, or hierarchy is passed</p> Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def element_is_parent(self, dimension_name: str, hierarchy_name: str, parent_name: str, element_name: str) -&gt; bool:\n    \"\"\"Element is Parent\n    :Note, unlike the related function in TM1 (ELISPAR or ElementIsParent), this function will return False\n    :if an invalid element is passed;\n    :but will raise an exception if an invalid dimension, or hierarchy is passed\n    \"\"\"\n    mdx = self._build_drill_intersection_mdx(\n        dimension_name=dimension_name,\n        hierarchy_name=hierarchy_name,\n        first_element_name=parent_name,\n        second_element_name=element_name,\n        mdx_method=\"TM1DrillDownMember\",\n        recursive=False,\n    )\n\n    cardinality = self._get_mdx_set_cardinality(mdx)\n    return bool(cardinality)\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.element_lock","title":"<code>element_lock(dimension_name, hierarchy_name, element_name, **kwargs)</code>","text":"<p>Lock element</p> <p>Parameters:</p> Name Type Description Default <code>dimension_name</code> <code>str</code> <p>Name of dimension.</p> required <code>hierarchy_name</code> <code>str</code> <p>Name of hierarchy.</p> required <code>element_name</code> <code>str</code> <p>Name of element to lock.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>response</p> Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>@require_version(\"11.8.023\")\ndef element_lock(self, dimension_name: str, hierarchy_name: str, element_name: str, **kwargs) -&gt; Response:\n    \"\"\"Lock element\n    :param dimension_name: Name of dimension.\n    :param hierarchy_name: Name of hierarchy.\n    :param element_name: Name of element to lock.\n    :return: response\n    \"\"\"\n    url = format_url(\n        \"/Dimensions('{}')/Hierarchies('{}')/Elements('{}')/tm1.Lock\", dimension_name, hierarchy_name, element_name\n    )\n    return self._rest.POST(url, \"\", **kwargs)\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.element_unlock","title":"<code>element_unlock(dimension_name, hierarchy_name, element_name, **kwargs)</code>","text":"<p>Unlock element</p> <p>Parameters:</p> Name Type Description Default <code>dimension_name</code> <code>str</code> <p>Name of dimension.</p> required <code>hierarchy_name</code> <code>str</code> <p>Name of hierarchy.</p> required <code>element_name</code> <code>str</code> <p>Name of element to unlock.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>response</p> Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>@require_version(\"11.8.023\")\ndef element_unlock(self, dimension_name: str, hierarchy_name: str, element_name: str, **kwargs) -&gt; Response:\n    \"\"\"Unlock element\n    :param dimension_name: Name of dimension.\n    :param hierarchy_name: Name of hierarchy.\n    :param element_name: Name of element to unlock.\n    :return: response\n    \"\"\"\n    url = format_url(\n        \"/Dimensions('{}')/Hierarchies('{}')/Elements('{}')/tm1.Unlock\",\n        dimension_name,\n        hierarchy_name,\n        element_name,\n    )\n    return self._rest.POST(url, \"\", **kwargs)\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.execute_set_mdx","title":"<code>execute_set_mdx(mdx, top_records=None, member_properties=('Name', 'Weight'), parent_properties=('Name', 'UniqueName'), element_properties=('Type', 'Level'), **kwargs)</code>","text":"<p>:method to execute an MDX statement against a dimension</p> <p>Parameters:</p> Name Type Description Default <code>mdx</code> <code>str</code> <p>valid dimension mdx statement</p> required <code>top_records</code> <code>Optional[int]</code> <p>number of records to return, default: all elements no limit</p> <code>None</code> <code>member_properties</code> <code>Optional[Iterable[str]]</code> <p>list of member properties (e.g., Name, UniqueName, Type, Weight, Attributes/Color) to return, will always return the Name property</p> <code>('Name', 'Weight')</code> <code>parent_properties</code> <code>Optional[Iterable[str]]</code> <p>list of parent properties (e.g., Name, UniqueName, Type, Weight, Attributes/Color) to return, can be None or empty</p> <code>('Name', 'UniqueName')</code> <code>element_properties</code> <code>Optional[Iterable[str]]</code> <p>list of element properties (e.g., Name, UniqueName, Type, Level, Index, Attributes/Color) to return, can be empty</p> <code>('Type', 'Level')</code> <p>Returns:</p> Type Description <code>List</code> <p>dictionary of members, unique names, weights, types, and parents</p> Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def execute_set_mdx(\n    self,\n    mdx: str,\n    top_records: Optional[int] = None,\n    member_properties: Optional[Iterable[str]] = (\"Name\", \"Weight\"),\n    parent_properties: Optional[Iterable[str]] = (\"Name\", \"UniqueName\"),\n    element_properties: Optional[Iterable[str]] = (\"Type\", \"Level\"),\n    **kwargs,\n) -&gt; List:\n    \"\"\"\n    :method to execute an MDX statement against a dimension\n    :param mdx: valid dimension mdx statement\n    :param top_records: number of records to return, default: all elements no limit\n    :param member_properties: list of member properties (e.g., Name, UniqueName, Type, Weight, Attributes/Color)\n    to return, will always return the Name property\n    :param parent_properties: list of parent properties (e.g., Name, UniqueName, Type, Weight, Attributes/Color)\n     to return, can be None or empty\n    :param element_properties: list of element properties (e.g., Name, UniqueName, Type, Level, Index,\n    Attributes/Color) to return, can be empty\n    :return: dictionary of members, unique names, weights, types, and parents\n    \"\"\"\n\n    top = f\"$top={top_records};\" if top_records else \"\"\n\n    if not member_properties:\n        member_properties = [\"Name\"]\n\n    # drop spaces in Attribute names\n    else:\n        member_properties = [\n            member_property.replace(\" \", \"\") if member_property.startswith(\"Attributes/\") else member_property\n            for member_property in member_properties\n        ]\n\n    if element_properties:\n        element_properties = [\n            element_property.replace(\" \", \"\") if element_property.startswith(\"Attributes/\") else element_property\n            for element_property in element_properties\n        ]\n\n    if parent_properties:\n        parent_properties = [\n            parent_property.replace(\" \", \"\") if parent_property.startswith(\"Attributes/\") else parent_property\n            for parent_property in parent_properties\n        ]\n\n    member_properties = \",\".join(member_properties)\n    select_member_properties = f\"$select={member_properties}\"\n\n    properties_to_expand = []\n    if parent_properties:\n        parent_properties = \",\".join(parent_properties)\n        select_parent_properties = f\"Parent($select={parent_properties})\"\n        properties_to_expand.append(select_parent_properties)\n\n    if element_properties:\n        element_properties = \",\".join(element_properties)\n        select_element_properties = f\"Element($select={element_properties})\"\n        properties_to_expand.append(select_element_properties)\n\n    if properties_to_expand:\n        expand_properties = f';$expand={\",\".join(properties_to_expand)}'\n    else:\n        expand_properties = \"\"\n\n    url = (\n        f\"/ExecuteMDXSetExpression?$expand=Tuples({top}\"\n        f\"$expand=Members({select_member_properties}\"\n        f\"{expand_properties}))\"\n    )\n\n    payload = {\"MDX\": mdx}\n    response = self._rest.POST(url, json.dumps(payload, ensure_ascii=False), **kwargs)\n    raw_dict = response.json()\n    return [tuples[\"Members\"] for tuples in raw_dict[\"Tuples\"]]\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.execute_set_mdx_element_names","title":"<code>execute_set_mdx_element_names(mdx, top_records=None, **kwargs)</code>","text":"<p>:method to execute an MDX statement against a dimension and get a list with element names back</p> <p>Parameters:</p> Name Type Description Default <code>mdx</code> <code>str</code> <p>valid dimension mdx statement</p> required <code>top_records</code> <code>Optional[int]</code> <p>number of records to return, default: all elements no limit</p> <code>None</code> <p>Returns:</p> Type Description <code>List</code> <p>list of element names</p> Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def execute_set_mdx_element_names(self, mdx: str, top_records: Optional[int] = None, **kwargs) -&gt; List:\n    \"\"\"\n    :method to execute an MDX statement against a dimension and get a list with element names back\n    :param mdx: valid dimension mdx statement\n    :param top_records: number of records to return, default: all elements no limit\n    :return: list of element names\n    \"\"\"\n    elements = self.execute_set_mdx(\n        mdx,\n        member_properties=[\"Name\"],\n        parent_properties=None,\n        element_properties=None,\n    )\n    return [element[0][\"Name\"] for element in elements]\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.exists","title":"<code>exists(dimension_name, hierarchy_name, element_name, **kwargs)</code>","text":"Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def exists(self, dimension_name: str, hierarchy_name: str, element_name: str, **kwargs) -&gt; bool:\n    url = format_url(\n        \"/Dimensions('{}')/Hierarchies('{}')/Elements('{}')\", dimension_name, hierarchy_name, element_name\n    )\n    return self._exists(url, **kwargs)\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.get","title":"<code>get(dimension_name, hierarchy_name, element_name, **kwargs)</code>","text":"Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def get(self, dimension_name: str, hierarchy_name: str, element_name: str, **kwargs) -&gt; Element:\n    url = format_url(\n        \"/Dimensions('{}')/Hierarchies('{}')/Elements('{}')?$expand=*\", dimension_name, hierarchy_name, element_name\n    )\n    response = self._rest.GET(url, **kwargs)\n    return Element.from_dict(response.json())\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.get_alias_element_attributes","title":"<code>get_alias_element_attributes(dimension_name, hierarchy_name, **kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>dimension_name</code> <code>str</code> required <code>hierarchy_name</code> <code>str</code> required <p>Returns:</p> Type Description <code>List[str]</code> Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def get_alias_element_attributes(self, dimension_name: str, hierarchy_name: str, **kwargs) -&gt; List[str]:\n    \"\"\"\n\n    :param dimension_name:\n    :param hierarchy_name:\n    :return:\n    \"\"\"\n    attributes = self.get_element_attributes(dimension_name, hierarchy_name, **kwargs)\n    return [attr.name for attr in attributes if attr.attribute_type == \"Alias\"]\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.get_all_element_identifiers","title":"<code>get_all_element_identifiers(dimension_name, hierarchy_name, **kwargs)</code>","text":"<p>Get all element names and alias values in a hierarchy</p> <p>Parameters:</p> Name Type Description Default <code>dimension_name</code> <code>str</code> required <code>hierarchy_name</code> <code>str</code> required <p>Returns:</p> Type Description <code>CaseAndSpaceInsensitiveSet</code> Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def get_all_element_identifiers(\n    self, dimension_name: str, hierarchy_name: str, **kwargs\n) -&gt; CaseAndSpaceInsensitiveSet:\n    \"\"\"Get all element names and alias values in a hierarchy\n\n    :param dimension_name:\n    :param hierarchy_name:\n    :return:\n    \"\"\"\n\n    mdx_elements = f\"{{ Tm1SubsetAll ([{dimension_name}].[{hierarchy_name}]) }}\"\n    return self.get_element_identifiers(dimension_name, hierarchy_name, mdx_elements, **kwargs)\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.get_all_leaf_element_identifiers","title":"<code>get_all_leaf_element_identifiers(dimension_name, hierarchy_name, **kwargs)</code>","text":"<p>Get all element names and alias values for leaf elements in a hierarchy</p> <p>Parameters:</p> Name Type Description Default <code>dimension_name</code> <code>str</code> required <code>hierarchy_name</code> <code>str</code> required <p>Returns:</p> Type Description <code>CaseAndSpaceInsensitiveSet</code> Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def get_all_leaf_element_identifiers(\n    self, dimension_name: str, hierarchy_name: str, **kwargs\n) -&gt; CaseAndSpaceInsensitiveSet:\n    \"\"\"Get all element names and alias values for leaf elements in a hierarchy\n\n    :param dimension_name:\n    :param hierarchy_name:\n    :return:\n    \"\"\"\n    mdx_elements = f\"{{ Tm1FilterByLevel ( {{ Tm1SubsetAll ([{dimension_name}].[{hierarchy_name}]) }} , 0 ) }}\"\n    return self.get_element_identifiers(dimension_name, hierarchy_name, mdx_elements, **kwargs)\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.get_attribute_of_elements","title":"<code>get_attribute_of_elements(dimension_name, hierarchy_name, attribute, elements=None, exclude_empty_cells=True, element_unique_names=False)</code>","text":"<p>Get element name and attribute value for a set of elements in a hierarchy</p> <p>Parameters:</p> Name Type Description Default <code>dimension_name</code> <code>str</code> required <code>hierarchy_name</code> <code>str</code> required <code>attribute</code> <code>str</code> <p>Name of the Attribute</p> required <code>elements</code> <code>Union[str, List[str]]</code> <p>MDX (Set) expression or iterable of elements</p> <code>None</code> <code>exclude_empty_cells</code> <code>bool</code> <p>Boolean</p> <code>True</code> <code>element_unique_names</code> <code>bool</code> <p>Boolean</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dict {'01':'Jan', '02':'Feb'}</p> Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def get_attribute_of_elements(\n    self,\n    dimension_name: str,\n    hierarchy_name: str,\n    attribute: str,\n    elements: Union[str, List[str]] = None,\n    exclude_empty_cells: bool = True,\n    element_unique_names: bool = False,\n) -&gt; dict:\n    \"\"\"\n     Get element name and attribute value for a set of elements in a hierarchy\n\n    :param dimension_name:\n    :param hierarchy_name:\n    :param attribute: Name of the Attribute\n    :param elements:  MDX (Set) expression or iterable of elements\n    :param exclude_empty_cells: Boolean\n    :param element_unique_names: Boolean\n    :return: Dict {'01':'Jan', '02':'Feb'}\n    \"\"\"\n    if elements is None or not any(elements):\n        elements = self.get_element_names(dimension_name=dimension_name, hierarchy_name=hierarchy_name)\n\n    if isinstance(elements, str):\n        mdx_element_selection = elements\n    else:\n        mdx_element_selection = \",\".join(\n            build_element_unique_names([dimension_name] * len(elements), elements, [hierarchy_name] * len(elements))\n        )\n    mdx = \"\"\"\n         SELECT\n         {{ {elem_mdx} }} ON ROWS, \n         {{ {attr_mdx} }} ON COLUMNS\n         FROM [}}ElementAttributes_{dim}]\n         \"\"\".format(\n        elem_mdx=mdx_element_selection,\n        attr_mdx=\"[}ElementAttributes_\" + dimension_name + \"].[\" + attribute + \"]\",\n        dim=dimension_name,\n    )\n    rows_and_values = self._retrieve_mdx_rows_and_values(mdx, element_unique_names=element_unique_names)\n    return self._extract_dict_from_rows_and_values(rows_and_values, exclude_empty_cells=exclude_empty_cells)\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.get_consolidated_element_names","title":"<code>get_consolidated_element_names(dimension_name, hierarchy_name, **kwargs)</code>","text":"Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def get_consolidated_element_names(self, dimension_name: str, hierarchy_name: str, **kwargs) -&gt; List[str]:\n    url = format_url(\n        \"/Dimensions('{}')/Hierarchies('{}')/Elements?$select=Name&amp;$filter=Type eq 3\",\n        dimension_name,\n        hierarchy_name,\n    )\n    response = self._rest.GET(url, **kwargs)\n    return [e[\"Name\"] for e in response.json()[\"value\"]]\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.get_consolidated_elements","title":"<code>get_consolidated_elements(dimension_name, hierarchy_name, **kwargs)</code>","text":"Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def get_consolidated_elements(self, dimension_name: str, hierarchy_name: str, **kwargs) -&gt; List[Element]:\n    url = format_url(\n        \"/Dimensions('{}')/Hierarchies('{}')/Elements?$expand=*&amp;$filter=Type eq 3\", dimension_name, hierarchy_name\n    )\n    response = self._rest.GET(url, **kwargs)\n    return [Element.from_dict(element) for element in response.json()[\"value\"]]\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.get_edges","title":"<code>get_edges(dimension_name, hierarchy_name, **kwargs)</code>","text":"Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def get_edges(self, dimension_name: str, hierarchy_name: str, **kwargs) -&gt; Dict[Tuple[str, str], int]:\n    url = format_url(\n        \"/Dimensions('{}')/Hierarchies('{}')/Edges?select=ParentName,ComponentName,Weight\",\n        dimension_name,\n        hierarchy_name,\n    )\n    response = self._rest.GET(url, **kwargs)\n\n    return {(edge[\"ParentName\"], edge[\"ComponentName\"]): edge[\"Weight\"] for edge in response.json()[\"value\"]}\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.get_edges_under_consolidation","title":"<code>get_edges_under_consolidation(dimension_name, hierarchy_name, consolidation, max_depth=None, **kwargs)</code>","text":"<p>Get all members under a consolidated element</p> <p>Parameters:</p> Name Type Description Default <code>dimension_name</code> <code>str</code> <p>name of dimension</p> required <code>hierarchy_name</code> <code>str</code> <p>name of hierarchy</p> required <code>consolidation</code> <code>str</code> <p>name of consolidated Element</p> required <code>max_depth</code> <code>int</code> <p>99 if not passed</p> <code>None</code> <p>Returns:</p> Type Description <code>List[str]</code> Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def get_edges_under_consolidation(\n    self, dimension_name: str, hierarchy_name: str, consolidation: str, max_depth: int = None, **kwargs\n) -&gt; List[str]:\n    \"\"\"Get all members under a consolidated element\n\n    :param dimension_name: name of dimension\n    :param hierarchy_name: name of hierarchy\n    :param consolidation: name of consolidated Element\n    :param max_depth: 99 if not passed\n    :return:\n    \"\"\"\n    depth = max_depth or 99\n\n    # edges to return\n    edges = CaseAndSpaceInsensitiveTuplesDict()\n\n    # build url\n    bare_url = \"/Dimensions('{}')/Hierarchies('{}')/Elements('{}')?\"\n    url = format_url(bare_url, dimension_name, hierarchy_name, consolidation)\n    for d in range(depth):\n        if d == 0:\n            url += \"$select=Edges&amp;$expand=Edges($expand=Component(\"\n        else:\n            url += \"$select=Edges;$expand=Edges($expand=Component(\"\n\n    url = url[:-1] + \")\" * (depth * 2 - 1)\n\n    response = self._rest.GET(url, **kwargs)\n    consolidation_tree = response.json()\n    is_v12_or_higher = verify_version(\"12.0\", self.version)\n\n    # recursive function to parse consolidation sub_tree\n    def get_edges(sub_trees):\n        for sub_tree in sub_trees:\n            if is_v12_or_higher:\n                component_name = sub_tree[\"Component\"][\"Name\"]\n            else:\n                component_name = sub_tree[\"ComponentName\"]\n            edges[sub_tree[\"ParentName\"],component_name]  = sub_tree[\"Weight\"]\n\n            if \"Edges\" not in sub_tree[\"Component\"]:\n                continue\n\n            get_edges(sub_trees=sub_tree[\"Component\"][\"Edges\"])\n\n    get_edges(consolidation_tree[\"Edges\"])\n    return edges\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.get_element_attribute_names","title":"<code>get_element_attribute_names(dimension_name, hierarchy_name, **kwargs)</code>","text":"<p>Get element attributes from hierarchy</p> <p>Parameters:</p> Name Type Description Default <code>dimension_name</code> <code>str</code> required <code>hierarchy_name</code> <code>str</code> required <p>Returns:</p> Type Description <code>List[str]</code> Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def get_element_attribute_names(self, dimension_name: str, hierarchy_name: str, **kwargs) -&gt; List[str]:\n    \"\"\"Get element attributes from hierarchy\n\n    :param dimension_name:\n    :param hierarchy_name:\n    :return:\n    \"\"\"\n    url = format_url(\n        \"/Dimensions('{}')/Hierarchies('{}')/ElementAttributes?$select=Name\", dimension_name, hierarchy_name\n    )\n    response = self._rest.GET(url, **kwargs)\n    return [ea[\"Name\"] for ea in response.json()[\"value\"]]\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.get_element_attributes","title":"<code>get_element_attributes(dimension_name, hierarchy_name, **kwargs)</code>","text":"<p>Get element attributes from hierarchy</p> <p>Parameters:</p> Name Type Description Default <code>dimension_name</code> <code>str</code> required <code>hierarchy_name</code> <code>str</code> required <p>Returns:</p> Type Description <code>List[ElementAttribute]</code> Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def get_element_attributes(self, dimension_name: str, hierarchy_name: str, **kwargs) -&gt; List[ElementAttribute]:\n    \"\"\"Get element attributes from hierarchy\n\n    :param dimension_name:\n    :param hierarchy_name:\n    :return:\n    \"\"\"\n    url = format_url(\"/Dimensions('{}')/Hierarchies('{}')/ElementAttributes\", dimension_name, hierarchy_name)\n    response = self._rest.GET(url, **kwargs)\n    element_attributes = [ElementAttribute.from_dict(ea) for ea in response.json()[\"value\"]]\n    return element_attributes\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.get_element_identifiers","title":"<code>get_element_identifiers(dimension_name, hierarchy_name, elements, **kwargs)</code>","text":"<p>Get all element names and alias values for a set of elements in a hierarchy</p> <p>Parameters:</p> Name Type Description Default <code>dimension_name</code> <code>str</code> required <code>hierarchy_name</code> <code>str</code> required <code>elements</code> <code>Union[str, List[str]]</code> <p>MDX (Set) expression or iterable of elements</p> required <p>Returns:</p> Type Description <code>CaseAndSpaceInsensitiveSet</code> Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def get_element_identifiers(\n    self, dimension_name: str, hierarchy_name: str, elements: Union[str, List[str]], **kwargs\n) -&gt; CaseAndSpaceInsensitiveSet:\n    \"\"\"Get all element names and alias values for a set of elements in a hierarchy\n\n    :param dimension_name:\n    :param hierarchy_name:\n    :param elements: MDX (Set) expression or iterable of elements\n    :return:\n    \"\"\"\n\n    alias_attributes = self.get_alias_element_attributes(dimension_name, hierarchy_name, **kwargs)\n\n    if isinstance(elements, str):\n        mdx_element_selection = elements\n    else:\n        mdx_element_selection = \",\".join(\n            build_element_unique_names([dimension_name] * len(elements), elements, [hierarchy_name] * len(elements))\n        )\n\n    if not alias_attributes:\n        result = self.execute_set_mdx(\n            mdx=mdx_element_selection, member_properties=[\"Name\"], parent_properties=None, element_properties=None\n        )\n        return CaseAndSpaceInsensitiveSet([record[0][\"Name\"] for record in result])\n\n    mdx = \"\"\"\n         SELECT\n         {{ {elem_mdx} }} ON ROWS, \n         {{ {attr_mdx} }} ON COLUMNS\n         FROM [}}ElementAttributes_{dim}]\n         \"\"\".format(\n        elem_mdx=mdx_element_selection,\n        attr_mdx=\",\".join(\n            build_element_unique_names(\n                [\"}ElementAttributes_\" + dimension_name] * len(alias_attributes), alias_attributes\n            )\n        ),\n        dim=dimension_name,\n    )\n    return self._retrieve_mdx_rows_and_cell_values_as_string_set(mdx, **kwargs)\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.get_element_names","title":"<code>get_element_names(dimension_name, hierarchy_name, **kwargs)</code>","text":"<p>Get all element names</p> <p>Parameters:</p> Name Type Description Default <code>dimension_name</code> <code>str</code> required <code>hierarchy_name</code> <code>str</code> required <p>Returns:</p> Type Description <code>List[str]</code> <p>Generator of element-names</p> Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def get_element_names(self, dimension_name: str, hierarchy_name: str, **kwargs) -&gt; List[str]:\n    \"\"\"Get all element names\n\n    :param dimension_name:\n    :param hierarchy_name:\n    :return: Generator of element-names\n    \"\"\"\n    url = format_url(\"/Dimensions('{}')/Hierarchies('{}')/Elements?$select=Name\", dimension_name, hierarchy_name)\n    response = self._rest.GET(url, **kwargs)\n    return [e[\"Name\"] for e in response.json()[\"value\"]]\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.get_element_principal_name","title":"<code>get_element_principal_name(dimension_name, hierarchy_name, element_name, **kwargs)</code>","text":"Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def get_element_principal_name(self, dimension_name: str, hierarchy_name: str, element_name: str, **kwargs) -&gt; str:\n    element = self.get(dimension_name, hierarchy_name, element_name, **kwargs)\n    return element.name\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.get_element_types","title":"<code>get_element_types(dimension_name, hierarchy_name, skip_consolidations=False, **kwargs)</code>","text":"Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def get_element_types(\n    self, dimension_name: str, hierarchy_name: str, skip_consolidations: bool = False, **kwargs\n) -&gt; CaseAndSpaceInsensitiveDict:\n    url = format_url(\n        \"/Dimensions('{}')/Hierarchies('{}')/Elements?$select=Name,Type\", dimension_name, hierarchy_name\n    )\n    if skip_consolidations:\n        url += \"&amp;$filter=Type ne 3\"\n    response = self._rest.GET(url, **kwargs)\n\n    result = CaseAndSpaceInsensitiveDict()\n    for element in response.json()[\"value\"]:\n        result[element[\"Name\"]] = element[\"Type\"]\n    return result\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.get_element_types_from_all_hierarchies","title":"<code>get_element_types_from_all_hierarchies(dimension_name, skip_consolidations=False, **kwargs)</code>","text":"Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def get_element_types_from_all_hierarchies(\n    self, dimension_name: str, skip_consolidations: bool = False, **kwargs\n) -&gt; CaseAndSpaceInsensitiveDict:\n    url = format_url(\n        \"/Dimensions('{}')?$expand=Hierarchies($select=Elements;$expand=Elements($select=Name,Type\", dimension_name\n    )\n    url += \";$filter=Type ne 3))\" if skip_consolidations else \"))\"\n    response = self._rest.GET(url, **kwargs)\n\n    result = CaseAndSpaceInsensitiveDict()\n    for hierarchy in response.json()[\"Hierarchies\"]:\n        for element in hierarchy[\"Elements\"]:\n            result[element[\"Name\"]] = element[\"Type\"]\n    return result\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.get_elements","title":"<code>get_elements(dimension_name, hierarchy_name, **kwargs)</code>","text":"Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def get_elements(self, dimension_name: str, hierarchy_name: str, **kwargs) -&gt; List[Element]:\n    url = format_url(\n        \"/Dimensions('{}')/Hierarchies('{}')/Elements?select=Name,Type\", dimension_name, hierarchy_name\n    )\n    response = self._rest.GET(url, **kwargs)\n    return [Element.from_dict(element) for element in response.json()[\"value\"]]\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.get_elements_by_level","title":"<code>get_elements_by_level(dimension_name, hierarchy_name, level, **kwargs)</code>","text":"<p>Get all element names by level in a hierarchy</p> <p>Parameters:</p> Name Type Description Default <code>dimension_name</code> <code>str</code> <p>Name of the dimension</p> required <code>hierarchy_name</code> <code>str</code> <p>Name of the hierarchy</p> required <code>level</code> <code>int</code> <p>Level to filter</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>List of element names</p> Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def get_elements_by_level(self, dimension_name: str, hierarchy_name: str, level: int, **kwargs) -&gt; List[str]:\n    \"\"\"Get all element names by level in a hierarchy\n\n    :param dimension_name: Name of the dimension\n    :param hierarchy_name: Name of the hierarchy\n    :param level: Level to filter\n    :return: List of element names\n    \"\"\"\n    url = format_url(\n        \"/Dimensions('{}')/Hierarchies('{}')/Elements?$select=Name&amp;$filter=Level eq {}\",\n        dimension_name,\n        hierarchy_name,\n        str(level),\n    )\n    response = self._rest.GET(url, **kwargs)\n    return [e[\"Name\"] for e in response.json()[\"value\"]]\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.get_elements_dataframe","title":"<code>get_elements_dataframe(dimension_name=None, hierarchy_name=None, elements=None, skip_consolidations=True, attributes=None, attribute_column_prefix='', skip_parents=False, level_names=None, parent_attribute=None, skip_weights=False, use_blob=False, allow_empty_alias=True, attribute_suffix=False, element_type_column='Type', **kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>dimension_name</code> <code>str</code> <p>Name of the dimension. Can be derived from elements MDX</p> <code>None</code> <code>hierarchy_name</code> <code>str</code> <p>Name of the hierarchy in the dimension.Can be derived from elements MDX</p> <code>None</code> <code>elements</code> <code>Union[str, Iterable[str]]</code> <p>Selection of members. Iterable or valid MDX string</p> <code>None</code> <code>skip_consolidations</code> <code>bool</code> <p>Boolean flag to skip consolidations</p> <code>True</code> <code>attributes</code> <code>Iterable[str]</code> <p>Selection of attributes. Iterable. If None retrieve all.</p> <code>None</code> <code>attribute_column_prefix</code> <code>str</code> <p>string to prefix attribute colums to avoid name conflicts</p> <code>''</code> <code>level_names</code> <code>List[str]</code> <p>List of labels for parent columns. If None use level names from TM1.</p> <code>None</code> <code>skip_parents</code> <code>bool</code> <p>Boolean Flag to skip parent columns.</p> <code>False</code> <code>parent_attribute</code> <code>str</code> <p>Attribute to be displayed in parent columns. If None, parent name is used.</p> <code>None</code> <code>skip_weights</code> <code>bool</code> <p>include weight columns</p> <code>False</code> <code>use_blob</code> <code>bool</code> <p>Up to 40% better performance and lower memory footprint in any case. Requires admin permissions</p> <code>False</code> <code>allow_empty_alias</code> <code>bool</code> <p>False if empty alias values should be substituted with element names instead</p> <code>True</code> <code>attribute_suffix</code> <code>bool</code> <p>True if attribute columns should have ':a', ':s' or ':n' suffix</p> <code>False</code> <code>element_type_column</code> <code>str</code> <p>The column name in the df which specifies which element is which type.</p> <code>'Type'</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pandas DataFrame</p> Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>@require_pandas\ndef get_elements_dataframe(\n    self,\n    dimension_name: str = None,\n    hierarchy_name: str = None,\n    elements: Union[str, Iterable[str]] = None,\n    skip_consolidations: bool = True,\n    attributes: Iterable[str] = None,\n    attribute_column_prefix: str = \"\",\n    skip_parents: bool = False,\n    level_names: List[str] = None,\n    parent_attribute: str = None,\n    skip_weights: bool = False,\n    use_blob: bool = False,\n    allow_empty_alias: bool = True,\n    attribute_suffix: bool = False,\n    element_type_column: str = \"Type\",\n    **kwargs,\n) -&gt; \"pd.DataFrame\":\n    \"\"\"\n\n    :param dimension_name: Name of the dimension. Can be derived from elements MDX\n    :param hierarchy_name: Name of the hierarchy in the dimension.Can be derived from elements MDX\n    :param elements: Selection of members. Iterable or valid MDX string\n    :param skip_consolidations: Boolean flag to skip consolidations\n    :param attributes: Selection of attributes. Iterable. If None retrieve all.\n    :param attribute_column_prefix: string to prefix attribute colums to avoid name conflicts\n    :param level_names: List of labels for parent columns. If None use level names from TM1.\n    :param skip_parents: Boolean Flag to skip parent columns.\n    :param parent_attribute: Attribute to be displayed in parent columns. If None, parent name is used.\n    :param skip_weights: include weight columns\n    :param use_blob: Up to 40% better performance and lower memory footprint in any case. Requires admin permissions\n    :param allow_empty_alias: False if empty alias values should be substituted with element names instead\n    :param attribute_suffix: True if attribute columns should have ':a', ':s' or ':n' suffix\n    :param element_type_column: The column name in the df which specifies which element is which type.\n    :return: pandas DataFrame\n    \"\"\"\n\n    if isinstance(elements, str) and not all([dimension_name, hierarchy_name]):\n        record = self.execute_set_mdx(\n            mdx=elements,\n            top_records=1,\n            member_properties=[\"UniqueName\"],\n            parent_properties=None,\n            element_properties=None,\n        )\n\n        if not record:\n            raise ValueError(f\"member_selection invalid: '{elements}'\")\n\n        unique_name = record[0][0][\"UniqueName\"]\n        dimension_name, hierarchy_name, _ = dimension_hierarchy_element_tuple_from_unique_name(unique_name)\n\n    if elements is None or not any(elements):\n        elements = f\"{{ [{dimension_name}].[{hierarchy_name}].Members }}\"\n        if skip_consolidations:\n            elements = f\"{{ Tm1FilterByLevel({elements}, 0) }}\"\n\n    if not isinstance(elements, str):\n        if isinstance(elements, Iterable):\n            elements = (\n                \"{\" + \",\".join(f\"[{dimension_name}].[{hierarchy_name}].[{member}]\" for member in elements) + \"}\"\n            )\n        else:\n            raise ValueError(\"Argument 'element_selection' must be None or str\")\n\n    if not self.attribute_cube_exists(dimension_name):\n        raise RuntimeError(self.ELEMENT_ATTRIBUTES_PREFIX + dimension_name + \" cube must exist\")\n\n    members = [\n        tupl[0]\n        for tupl in self.execute_set_mdx(\n            mdx=elements, element_properties=None, member_properties=(\"Name\", \"UniqueName\"), parent_properties=None\n        )\n    ]\n\n    element_types = self.get_element_types(\n        dimension_name=dimension_name, hierarchy_name=hierarchy_name, skip_consolidations=skip_consolidations\n    )\n\n    df = pd.DataFrame(\n        data=[\n            (member[\"Name\"], element_types[member[\"Name\"]]) for member in members if member[\"Name\"] in element_types\n        ],\n        dtype=str,\n        columns=[dimension_name, element_type_column],\n    )\n\n    calculated_members_definition = list()\n    calculated_members_selection = list()\n    levels_dict = {}\n    if not skip_parents:\n        levels = self.get_levels_count(dimension_name, hierarchy_name)\n\n        # Generic Level names can't be used directly as a Calculated Member name as they conflict with an internal name\n        # Therefore, we create a map that relates the level name to the calculated member name L000 = level000\n        if not level_names:\n            level_names = self.get_level_names(dimension_name, hierarchy_name, descending=True)\n            level_calculated_member_names = []\n\n            # Create a map of MDX Calculated Member Names and Desired Pandas Names\n            for level in reversed(range(levels)):\n                level_calculated_member_names.append(f\"L{str(level).zfill(3)}\")\n            all_level_dict = OrderedDict(zip(level_calculated_member_names, level_names))\n\n        # if a specific parent names are provided the calculated member name is = to the data frame column name\n        else:\n            all_level_dict = OrderedDict(zip(level_names, level_names))\n\n        # Remove the highest level (leafs) to create proper MDX calculated members\n        levels_dict = {k: all_level_dict[k] for k in list(all_level_dict)[1:]}\n\n        # iterate the map of levels to create an MDX calculation and a related column axis definition\n        parent_members = list()\n        weight_members = list()\n        depth = 0\n        for calculated_name, level_name in levels_dict.items():\n            depth += 1\n\n            # Deliberately adding a trailing space to Properties after the attribute name\n            # to ensure the attribute \"name\" is accessed instead of the built-in NAME property\n            # when the original attribute is called \"Name\" (this behavior is relevant starting from v12 )\n            name_or_attribute = f\"Properties('{parent_attribute} ')\" if parent_attribute else \"NAME\"\n\n            member = f\"\"\"\n            MEMBER [{self.ELEMENT_ATTRIBUTES_PREFIX + dimension_name}].[{calculated_name}] \n            AS [{dimension_name}].[{hierarchy_name}].CurrentMember.{'Parent.' * depth}{name_or_attribute}\n            \"\"\"\n            calculated_members_definition.append(member)\n\n            parent_members.append(f\"[{self.ELEMENT_ATTRIBUTES_PREFIX + dimension_name}].[{calculated_name}]\")\n\n            if not skip_weights:\n                member_weight = f\"\"\"\n                MEMBER [{self.ELEMENT_ATTRIBUTES_PREFIX + dimension_name}].[{level_name}_Weight] \n                AS IIF(\n                [{dimension_name}].[{hierarchy_name}].CurrentMember.{'Parent.' * (depth - 1)}Properties('MEMBER_WEIGHT') = '',\n                0,\n                [{dimension_name}].[{hierarchy_name}].CurrentMember.{'Parent.' * (depth - 1)}Properties('MEMBER_WEIGHT'))\n                \"\"\"\n\n                calculated_members_definition.append(member_weight)\n\n                weight_members.append(f\"[{self.ELEMENT_ATTRIBUTES_PREFIX + dimension_name}].[{level_name}_Weight]\")\n\n        calculated_members_selection.extend(weight_members)\n        calculated_members_selection.extend(parent_members)\n\n    if attributes is None:\n        column_selection = \"{Tm1SubsetAll([\" + self.ELEMENT_ATTRIBUTES_PREFIX + dimension_name + \"])}\"\n    else:\n        column_selection = (\n            \"{\"\n            + \",\".join(\n                \"[\" + self.ELEMENT_ATTRIBUTES_PREFIX + dimension_name + \"].[\" + attribute + \"]\"\n                for attribute in attributes\n            )\n            + \"}\"\n        )\n\n    if calculated_members_selection:\n        if column_selection == \"{}\":\n            column_selection = \"{\" + \",\".join(calculated_members_selection) + \"}\"\n        else:\n            column_selection = column_selection + \" + {\" + \",\".join(calculated_members_selection) + \"}\"\n\n    mdx_with_block = \"\"\n    if calculated_members_definition:\n        mdx_with_block = \"WITH \" + \" \".join(calculated_members_definition)\n\n    mdx = f\"\"\"\n    {mdx_with_block}\n    SELECT\n    {{ {elements} }} ON ROWS,\n    {{ {column_selection} }} ON COLUMNS\n    FROM [{self.ELEMENT_ATTRIBUTES_PREFIX + dimension_name}]  \n    \"\"\"\n\n    cell_service = self._get_cell_service()\n\n    # override column names. hierarchy name with dimension and prefix attributes\n    element_attributes = self.get_element_attributes(dimension_name, hierarchy_name)\n    column_renaming = dict()\n    if attribute_column_prefix or attribute_suffix:\n        column_renaming = {\n            ea.name: f\"{attribute_column_prefix}{ea.name}\"\n            + (f\":{ea.attribute_type.lower()[0]}\" if attribute_suffix else \"\")\n            for ea in element_attributes\n        }\n\n    # responses are similar but not equivalent.\n    # Therefor only use execute_mdx_dataframe when use_blob is True\n    if use_blob:\n        raw_csv = cell_service.execute_mdx_csv(\n            mdx=mdx,\n            skip_zeros=False,\n            skip_consolidated_cells=False,\n            skip_rule_derived_cells=False,\n            line_separator=\"\\r\\n\",\n            value_separator=\"~\",\n            use_blob=True,\n            **kwargs,\n        )\n\n        df_data = pd.read_csv(StringIO(raw_csv), sep=\"~\", na_filter=False, dtype={0: str})\n\n        # Use _group to avoid aggregation of multiple members into one df record\n        # example: element A is part of multiple consolidations resulting df must have multiple records for A\n        unique_values_count = df_data[\"}ElementAttributes_\" + dimension_name].nunique()\n        df_data[\"_group\"] = (df_data.index // unique_values_count) + 1\n\n        # pivot the dataframe\n        df_data = df_data.pivot_table(\n            index=[dimension_name, \"_group\"],\n            columns=\"}ElementAttributes_\" + dimension_name,\n            values=\"Value\",\n            aggfunc=\"first\",\n            sort=False,\n        )\n\n        # override column names. hierarchy name with dimension and prefix attributes\n        df_data.columns = [column_renaming.get(col, col) for col in df_data.columns]\n        df_data = df_data.reset_index()\n\n        # Drop the group key\n        df_data = df_data.fillna(\"\").drop(columns=\"_group\")\n\n    else:\n        df_data = cell_service.execute_mdx_dataframe_shaped(mdx, **kwargs)\n\n        # override column names. hierarchy name with dimension and prefix attributes\n        df_data.columns = [df_data.columns[0]] + [column_renaming.get(col, col) for col in df_data.columns[1:]]\n\n    if levels_dict:\n        # rename level names to conform sto standard levels \"1\" -&gt; \"level001\"\n        df_data.rename(columns=levels_dict, inplace=True)\n\n    # format weights\n    # Find columns with certain names\n    cols_to_format = [col for col in df_data.columns if \"_Weight\" in col]\n\n    # format the columns\n    df_data[cols_to_format] = df_data[cols_to_format].apply(pd.to_numeric)\n    df_data[cols_to_format] = df_data[cols_to_format].apply(lambda col: col.map(lambda x: f\"{x:.6f}\"))\n\n    # override colum types\n    element_attributes = self.get_element_attributes(dimension_name, hierarchy_name)\n    attribute_column_types = {\n        ea.name: \"float\" if ea.attribute_type == \"Numeric\" else \"str\"\n        for ea in element_attributes\n        if ea.name in df_data.columns\n    }\n    df_data = df_data.astype(attribute_column_types)\n\n    # substitute empty strings with element name if empty alias is not allowed\n    if not allow_empty_alias:\n        alias_attributes = [\n            ea.name for ea in element_attributes if ea.attribute_type == \"Alias\" and ea.name in df_data.columns\n        ]\n\n        for col in alias_attributes:\n            df_data[col] = np.where(df_data[col] == \"\", df_data[dimension_name], df_data[col])\n\n    # shift levels to right hand side\n    if not skip_parents:\n        # skip max level (= leaves)\n        level_columns = level_names[1:]\n\n        # iterative approach\n        for _ in level_columns:\n\n            rows_to_shift = df_data[df_data[level_columns[-1]].isin([\"\", None])].index\n            if rows_to_shift.empty:\n                break\n            shifted_cols = df_data.iloc[rows_to_shift, -len(level_columns) :].shift(1, axis=1)\n            df_data.iloc[rows_to_shift, -len(level_columns) :] = shifted_cols\n\n            # also shift weight columns\n            if not skip_weights:\n                shifted_cols = df_data.iloc[rows_to_shift, -len(level_columns) * 2 : -len(level_columns)].shift(\n                    1, axis=1\n                )\n\n                df_data.iloc[rows_to_shift, -len(level_columns) * 2 : -len(level_columns)] = shifted_cols\n\n        df_data.iloc[:, -len(level_columns) :] = df_data.iloc[:, -len(level_columns) :].fillna(\"\")\n        if not skip_weights:\n            df_data.iloc[:, -len(level_columns) * 2 : -len(level_names)] = df_data.iloc[\n                :, -len(level_columns) * 2 : -len(level_names)\n            ].fillna(0)\n\n    return pd.merge(df, df_data, on=dimension_name).drop_duplicates()\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.get_elements_filtered_by_attribute","title":"<code>get_elements_filtered_by_attribute(dimension_name, hierarchy_name, attribute_name, attribute_value, **kwargs)</code>","text":"<p>Get all elements from a hierarchy with given attribute value</p> <p>Parameters:</p> Name Type Description Default <code>dimension_name</code> <code>str</code> required <code>hierarchy_name</code> <code>str</code> required <code>attribute_name</code> <code>str</code> required <code>attribute_value</code> <code>Union[str, float]</code> required <p>Returns:</p> Type Description <code>List[str]</code> <p>List of element names</p> Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def get_elements_filtered_by_attribute(\n    self,\n    dimension_name: str,\n    hierarchy_name: str,\n    attribute_name: str,\n    attribute_value: Union[str, float],\n    **kwargs,\n) -&gt; List[str]:\n    \"\"\"Get all elements from a hierarchy with given attribute value\n\n    :param dimension_name:\n    :param hierarchy_name:\n    :param attribute_name:\n    :param attribute_value:\n    :return: List of element names\n    \"\"\"\n    if not self.exists(\n        f\"}}ElementAttributes_{dimension_name}\", f\"}}ElementAttributes_{dimension_name}\", attribute_name\n    ):\n        raise RuntimeError(f\"Attribute '{attribute_name}' does not exist in Dimension '{dimension_name}'\")\n\n    if isinstance(attribute_value, str):\n        mdx = (\n            f\"{{FILTER({{TM1SUBSETALL([{dimension_name}].[{hierarchy_name}])}},\"\n            f'[{dimension_name}].[{hierarchy_name}].CURRENTMEMBER.PROPERTIES(\"{attribute_name}\") = \"{attribute_value}\")}}'\n        )\n    else:\n        mdx = (\n            f\"{{FILTER({{TM1SUBSETALL([{dimension_name}].[{hierarchy_name}])}},\"\n            f'(IIF([{dimension_name}].[{hierarchy_name}].CURRENTMEMBER.PROPERTIES(\"{attribute_name}\")=\"\", 0.0,'\n            f'STRTOVALUE([{dimension_name}].[{hierarchy_name}].CURRENTMEMBER.PROPERTIES(\"{attribute_name}\"))) = 1))}}'\n        )\n\n    elems = self.execute_set_mdx(\n        mdx=mdx, member_properties=[\"Name\"], parent_properties=None, element_properties=None\n    )\n    return [elem[0][\"Name\"] for elem in elems]\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.get_elements_filtered_by_wildcard","title":"<code>get_elements_filtered_by_wildcard(dimension_name, hierarchy_name, wildcard, level=None, **kwargs)</code>","text":"<p>Get all element names filtered by wildcard (CaseAndSpaceInsensitive) and level in a hierarchy</p> <p>Parameters:</p> Name Type Description Default <code>dimension_name</code> <code>str</code> <p>Name of the dimension</p> required <code>hierarchy_name</code> <code>str</code> <p>Name of the hierarchy</p> required <code>wildcard</code> <code>str</code> <p>wildcard to filter</p> required <code>level</code> <code>int</code> <p>Level to filter</p> <code>None</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of element names</p> Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def get_elements_filtered_by_wildcard(\n    self, dimension_name: str, hierarchy_name: str, wildcard: str, level: int = None, **kwargs\n) -&gt; List[str]:\n    \"\"\"Get all element names filtered by wildcard (CaseAndSpaceInsensitive) and level in a hierarchy\n\n    :param dimension_name: Name of the dimension\n    :param hierarchy_name: Name of the hierarchy\n    :param wildcard: wildcard to filter\n    :param level: Level to filter\n    :return: List of element names\n    \"\"\"\n    filter_elements = format_url(\"contains(tolower(replace(Name,' ','')),tolower(replace('{}',' ', '')))\", wildcard)\n    if level is not None:\n        filter_elements = filter_elements + f\" and Level eq {level}\"\n    url = format_url(\n        \"/Dimensions('{}')/Hierarchies('{}')/Elements?$select=Name&amp;$filter=\" + filter_elements,\n        dimension_name,\n        hierarchy_name,\n    )\n    response = self._rest.GET(url, **kwargs)\n    return [e[\"Name\"] for e in response.json()[\"value\"]]\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.get_leaf_element_names","title":"<code>get_leaf_element_names(dimension_name, hierarchy_name, **kwargs)</code>","text":"Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def get_leaf_element_names(self, dimension_name: str, hierarchy_name: str, **kwargs) -&gt; List[str]:\n    url = format_url(\n        \"/Dimensions('{}')/Hierarchies('{}')/Elements?$select=Name&amp;$filter=Type ne 3\",\n        dimension_name,\n        hierarchy_name,\n    )\n    response = self._rest.GET(url, **kwargs)\n    return [e[\"Name\"] for e in response.json()[\"value\"]]\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.get_leaf_elements","title":"<code>get_leaf_elements(dimension_name, hierarchy_name, **kwargs)</code>","text":"Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def get_leaf_elements(self, dimension_name: str, hierarchy_name: str, **kwargs) -&gt; List[Element]:\n    url = format_url(\n        \"/Dimensions('{}')/Hierarchies('{}')/Elements?$expand=*&amp;$filter=Type ne 3\", dimension_name, hierarchy_name\n    )\n    response = self._rest.GET(url, **kwargs)\n    return [Element.from_dict(element) for element in response.json()[\"value\"]]\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.get_leaves_under_consolidation","title":"<code>get_leaves_under_consolidation(dimension_name, hierarchy_name, consolidation, max_depth=None, **kwargs)</code>","text":"<p>Get all leaves under a consolidated element</p> <p>Parameters:</p> Name Type Description Default <code>dimension_name</code> <code>str</code> <p>name of dimension</p> required <code>hierarchy_name</code> <code>str</code> <p>name of hierarchy</p> required <code>consolidation</code> <code>str</code> <p>name of consolidated Element</p> required <code>max_depth</code> <code>int</code> <p>99 if not passed</p> <code>None</code> <p>Returns:</p> Type Description <code>List[str]</code> Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def get_leaves_under_consolidation(\n    self, dimension_name: str, hierarchy_name: str, consolidation: str, max_depth: int = None, **kwargs\n) -&gt; List[str]:\n    \"\"\"Get all leaves under a consolidated element\n\n    :param dimension_name: name of dimension\n    :param hierarchy_name: name of hierarchy\n    :param consolidation: name of consolidated Element\n    :param max_depth: 99 if not passed\n    :return:\n    \"\"\"\n    return self.get_members_under_consolidation(\n        dimension_name, hierarchy_name, consolidation, max_depth, True, **kwargs\n    )\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.get_level_names","title":"<code>get_level_names(dimension_name, hierarchy_name, descending=True, **kwargs)</code>","text":"Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def get_level_names(self, dimension_name: str, hierarchy_name: str, descending: bool = True, **kwargs) -&gt; List[str]:\n    url = format_url(\"/Dimensions('{}')/Hierarchies('{}')/Levels?$select=Name\", dimension_name, hierarchy_name)\n    response = self._rest.GET(url, **kwargs)\n    if descending:\n        return [level[\"Name\"] for level in reversed(response.json()[\"value\"])]\n    else:\n        return [level[\"Name\"] for level in response.json()[\"value\"]]\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.get_levels_count","title":"<code>get_levels_count(dimension_name, hierarchy_name, **kwargs)</code>","text":"Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def get_levels_count(self, dimension_name: str, hierarchy_name: str, **kwargs) -&gt; int:\n    url = format_url(\"/Dimensions('{}')/Hierarchies('{}')/Levels/$count\", dimension_name, hierarchy_name)\n    response = self._rest.GET(url, **kwargs)\n    return int(response.text)\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.get_members_under_consolidation","title":"<code>get_members_under_consolidation(dimension_name, hierarchy_name, consolidation, max_depth=None, leaves_only=False, **kwargs)</code>","text":"<p>Get all members under a consolidated element</p> <p>Parameters:</p> Name Type Description Default <code>dimension_name</code> <code>str</code> <p>name of dimension</p> required <code>hierarchy_name</code> <code>str</code> <p>name of hierarchy</p> required <code>consolidation</code> <code>str</code> <p>name of consolidated Element</p> required <code>max_depth</code> <code>int</code> <p>99 if not passed</p> <code>None</code> <code>leaves_only</code> <code>bool</code> <p>Only Leaf Elements or all Elements</p> <code>False</code> <p>Returns:</p> Type Description <code>List[str]</code> Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def get_members_under_consolidation(\n    self,\n    dimension_name: str,\n    hierarchy_name: str,\n    consolidation: str,\n    max_depth: int = None,\n    leaves_only: bool = False,\n    **kwargs,\n) -&gt; List[str]:\n    \"\"\"Get all members under a consolidated element\n\n    :param dimension_name: name of dimension\n    :param hierarchy_name: name of hierarchy\n    :param consolidation: name of consolidated Element\n    :param max_depth: 99 if not passed\n    :param leaves_only: Only Leaf Elements or all Elements\n    :return:\n    \"\"\"\n    depth = max_depth - 1 if max_depth else 99\n    # members to return\n    members = []\n    # build url\n    bare_url = \"/Dimensions('{}')/Hierarchies('{}')/Elements('{}')?$select=Name,Type&amp;$expand=Components(\"\n    url = format_url(bare_url, dimension_name, hierarchy_name, consolidation)\n    for _ in range(depth):\n        url += \"$select=Name,Type;$expand=Components(\"\n    url = url[:-1] + \")\" * depth\n\n    response = self._rest.GET(url, **kwargs)\n    consolidation_tree = response.json()\n\n    # recursive function to parse consolidation_tree\n    def get_members(element):\n        if element[\"Type\"] == \"Numeric\":\n            members.append(element[\"Name\"])\n        elif element[\"Type\"] == \"Consolidated\":\n            if \"Components\" in element:\n                for component in element[\"Components\"]:\n                    if not leaves_only and component[\"Type\"] == \"Consolidated\":\n                        members.append(component[\"Name\"])\n                    get_members(component)\n\n    get_members(consolidation_tree)\n    return members\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.get_number_of_consolidated_elements","title":"<code>get_number_of_consolidated_elements(dimension_name, hierarchy_name, **kwargs)</code>","text":"Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def get_number_of_consolidated_elements(self, dimension_name: str, hierarchy_name: str, **kwargs) -&gt; int:\n    url = format_url(\n        \"/Dimensions('{}')/Hierarchies('{}')/Elements/$count?$filter=Type eq 3\", dimension_name, hierarchy_name\n    )\n    response = self._rest.GET(url, **kwargs)\n    return int(response.text)\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.get_number_of_elements","title":"<code>get_number_of_elements(dimension_name, hierarchy_name, **kwargs)</code>","text":"Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def get_number_of_elements(self, dimension_name: str, hierarchy_name: str, **kwargs) -&gt; int:\n    url = format_url(\"/Dimensions('{}')/Hierarchies('{}')/Elements/$count\", dimension_name, hierarchy_name)\n    response = self._rest.GET(url, **kwargs)\n    return int(response.text)\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.get_number_of_leaf_elements","title":"<code>get_number_of_leaf_elements(dimension_name, hierarchy_name, **kwargs)</code>","text":"Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def get_number_of_leaf_elements(self, dimension_name: str, hierarchy_name: str, **kwargs) -&gt; int:\n    url = format_url(\n        \"/Dimensions('{}')/Hierarchies('{}')/Elements/$count?$filter=Type ne 3\", dimension_name, hierarchy_name\n    )\n    response = self._rest.GET(url, **kwargs)\n    return int(response.text)\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.get_number_of_numeric_elements","title":"<code>get_number_of_numeric_elements(dimension_name, hierarchy_name, **kwargs)</code>","text":"Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def get_number_of_numeric_elements(self, dimension_name: str, hierarchy_name: str, **kwargs) -&gt; int:\n    url = format_url(\n        \"/Dimensions('{}')/Hierarchies('{}')/Elements/$count?$filter=Type eq 1\", dimension_name, hierarchy_name\n    )\n    response = self._rest.GET(url, **kwargs)\n    return int(response.text)\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.get_number_of_string_elements","title":"<code>get_number_of_string_elements(dimension_name, hierarchy_name, **kwargs)</code>","text":"Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def get_number_of_string_elements(self, dimension_name: str, hierarchy_name: str, **kwargs) -&gt; int:\n    url = format_url(\n        \"/Dimensions('{}')/Hierarchies('{}')/Elements/$count?$filter=Type eq 2\", dimension_name, hierarchy_name\n    )\n    response = self._rest.GET(url, **kwargs)\n    return int(response.text)\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.get_numeric_element_names","title":"<code>get_numeric_element_names(dimension_name, hierarchy_name, **kwargs)</code>","text":"Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def get_numeric_element_names(self, dimension_name: str, hierarchy_name: str, **kwargs) -&gt; List[str]:\n    url = format_url(\n        \"/Dimensions('{}')/Hierarchies('{}')/Elements?$select=Name&amp;$filter=Type eq 1\",\n        dimension_name,\n        hierarchy_name,\n    )\n    response = self._rest.GET(url, **kwargs)\n    return [e[\"Name\"] for e in response.json()[\"value\"]]\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.get_numeric_elements","title":"<code>get_numeric_elements(dimension_name, hierarchy_name, **kwargs)</code>","text":"Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def get_numeric_elements(self, dimension_name: str, hierarchy_name: str, **kwargs) -&gt; List[Element]:\n    url = format_url(\n        \"/Dimensions('{}')/Hierarchies('{}')/Elements?$expand=*&amp;$filter=Type eq 1\", dimension_name, hierarchy_name\n    )\n    response = self._rest.GET(url, **kwargs)\n    return [Element.from_dict(element) for element in response.json()[\"value\"]]\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.get_parents","title":"<code>get_parents(dimension_name, hierarchy_name, element_name, **kwargs)</code>","text":"Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def get_parents(self, dimension_name: str, hierarchy_name: str, element_name: str, **kwargs) -&gt; List[str]:\n    url = format_url(\n        \"/Dimensions('{dimension_name}')/Hierarchies('{hierarchy_name}')/Elements('{element_name}')/Parents\"\n        \"?$select=Name\",\n        dimension_name=dimension_name,\n        hierarchy_name=hierarchy_name,\n        element_name=element_name,\n    )\n    response = self._rest.GET(url=url, **kwargs)\n\n    return [record[\"Name\"] for record in response.json()[\"value\"]]\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.get_parents_of_all_elements","title":"<code>get_parents_of_all_elements(dimension_name, hierarchy_name, **kwargs)</code>","text":"Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def get_parents_of_all_elements(self, dimension_name: str, hierarchy_name: str, **kwargs) -&gt; Dict[str, List[str]]:\n    url = format_url(\n        f\"/Dimensions('{dimension_name}')/Hierarchies('{hierarchy_name}')/Elements?$select=Name\"\n        f\"&amp;$expand=Parents($select=Name)\",\n    )\n    response = self._rest.GET(url=url, **kwargs)\n\n    return {child[\"Name\"]: [parent[\"Name\"] for parent in child[\"Parents\"]] for child in response.json()[\"value\"]}\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.get_process_service","title":"<code>get_process_service()</code>","text":"Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def get_process_service(self):\n    from TM1py import ProcessService\n\n    return ProcessService(self._rest)\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.get_string_element_names","title":"<code>get_string_element_names(dimension_name, hierarchy_name, **kwargs)</code>","text":"Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def get_string_element_names(self, dimension_name: str, hierarchy_name: str, **kwargs) -&gt; List[str]:\n    url = format_url(\n        \"/Dimensions('{}')/Hierarchies('{}')/Elements?$select=Name&amp;$filter=Type eq 2\",\n        dimension_name,\n        hierarchy_name,\n    )\n    response = self._rest.GET(url, **kwargs)\n    return [e[\"Name\"] for e in response.json()[\"value\"]]\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.get_string_elements","title":"<code>get_string_elements(dimension_name, hierarchy_name, **kwargs)</code>","text":"Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def get_string_elements(self, dimension_name: str, hierarchy_name: str, **kwargs) -&gt; List[Element]:\n    url = format_url(\n        \"/Dimensions('{}')/Hierarchies('{}')/Elements?$expand=*&amp;$filter=Type eq 2\", dimension_name, hierarchy_name\n    )\n    response = self._rest.GET(url, **kwargs)\n    return [Element.from_dict(element) for element in response.json()[\"value\"]]\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.hierarchy_exists","title":"<code>hierarchy_exists(dimension_name, hierarchy_name)</code>","text":"Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def hierarchy_exists(self, dimension_name, hierarchy_name):\n    hierarchy_service = self._get_hierarchy_service()\n    return hierarchy_service.exists(dimension_name, hierarchy_name)\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.remove_edge","title":"<code>remove_edge(dimension_name, hierarchy_name, parent, component, **kwargs)</code>","text":"<p>Remove one edge from hierarchy. Fails if parent or child element doesn't exist.</p> <p>Parameters:</p> Name Type Description Default <code>dimension_name</code> <code>str</code> required <code>hierarchy_name</code> <code>str</code> required <code>parent</code> <code>str</code> required <code>component</code> <code>str</code> required <p>Returns:</p> Type Description <code>Response</code> Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def remove_edge(self, dimension_name: str, hierarchy_name: str, parent: str, component: str, **kwargs) -&gt; Response:\n    \"\"\"Remove one edge from hierarchy. Fails if parent or child element doesn't exist.\n\n    :param dimension_name:\n    :param hierarchy_name:\n    :param parent:\n    :param component:\n    :return:\n    \"\"\"\n\n    url = format_url(\n        \"/Dimensions('{}')/Hierarchies('{}')/Elements('{}')/Edges(ParentName='{}',ComponentName='{}')\",\n        dimension_name,\n        hierarchy_name,\n        parent,\n        parent,\n        component,\n    )\n\n    return self._rest.DELETE(url=url, **kwargs)\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.update","title":"<code>update(dimension_name, hierarchy_name, element, **kwargs)</code>","text":"Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def update(self, dimension_name: str, hierarchy_name: str, element: Element, **kwargs) -&gt; Response:\n    url = format_url(\n        \"/Dimensions('{}')/Hierarchies('{}')/Elements('{}')\", dimension_name, hierarchy_name, element.name\n    )\n    return self._rest.PATCH(url, element.body, **kwargs)\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.ElementService.update_or_create","title":"<code>update_or_create(dimension_name, hierarchy_name, element, **kwargs)</code>","text":"Source code in <code>TM1py/Services/ElementService.py</code> <pre><code>def update_or_create(self, dimension_name: str, hierarchy_name: str, element: Element, **kwargs) -&gt; Response:\n    if self.exists(\n        dimension_name=dimension_name, hierarchy_name=hierarchy_name, element_name=element.name, **kwargs\n    ):\n        return self.update(dimension_name=dimension_name, hierarchy_name=hierarchy_name, element=element, **kwargs)\n\n    return self.create(dimension_name=dimension_name, hierarchy_name=hierarchy_name, element=element, **kwargs)\n</code></pre>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.MDXDrillMethod","title":"<code>MDXDrillMethod</code>","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.MDXDrillMethod.DESCENDANTS","title":"<code>DESCENDANTS = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/services/elementservice/#TM1py.Services.ElementService.MDXDrillMethod.TM1DRILLDOWNMEMBER","title":"<code>TM1DRILLDOWNMEMBER = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/services/fileservice/","title":"FileService","text":""},{"location":"reference/services/fileservice/#TM1py.Services.FileService.FileService","title":"<code>FileService(tm1_rest)</code>","text":"<p>               Bases: <code>ObjectService</code></p> <p>Parameters:</p> Name Type Description Default <code>tm1_rest</code> <code>RestService</code> required Source code in <code>TM1py/Services/FileService.py</code> <pre><code>def __init__(self, tm1_rest: RestService):\n    \"\"\"\n\n    :param tm1_rest:\n    \"\"\"\n    super().__init__(tm1_rest)\n    self._rest = tm1_rest\n    if verify_version(required_version=\"12\", version=self.version):\n        self.version_content_path = \"Files\"\n    else:\n        self.version_content_path = \"Blobs\"\n</code></pre>"},{"location":"reference/services/fileservice/#TM1py.Services.FileService.FileService.MPU_REQUIRED_VERSION","title":"<code>MPU_REQUIRED_VERSION = '12'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/services/fileservice/#TM1py.Services.FileService.FileService.SUBFOLDER_REQUIRED_VERSION","title":"<code>SUBFOLDER_REQUIRED_VERSION = '12'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/services/fileservice/#TM1py.Services.FileService.FileService.version_content_path","title":"<code>version_content_path = 'Files'</code>  <code>instance-attribute</code>","text":""},{"location":"reference/services/fileservice/#TM1py.Services.FileService.FileService.create","title":"<code>create(file_name, file_content, multi_part_upload=None, max_mb_per_part=200, max_workers=1, **kwargs)</code>","text":"<p>Create file</p> <p>Folders in file_name (e.g. folderA/folderB/file.csv) will be created implicitly</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>Union[str, Path]</code> <p>file name in root or path to file</p> required <code>file_content</code> <code>Union[bytes, BytesIO]</code> <p>file_content as bytes or BytesIO</p> required <code>multi_part_upload</code> <code>bool</code> <p>boolean use multipart upload or not (only available from TM1 12 onwards) By default, multi_part_upload is used for TM1 v12 and not used for TM1 v11</p> <code>None</code> <code>max_mb_per_part</code> <code>float</code> <p>max megabyte per part in multipart upload (only available from TM1 12 onwards)</p> <code>200</code> <code>max_workers</code> <code>int</code> <p>max parallel workers for multipart upload (only available from TM1 12 onwards)</p> <code>1</code> Source code in <code>TM1py/Services/FileService.py</code> <pre><code>@require_version(version=\"11.4\")\ndef create(\n    self,\n    file_name: Union[str, Path],\n    file_content: Union[bytes, BytesIO],\n    multi_part_upload: bool = None,\n    max_mb_per_part: float = 200,\n    max_workers: int = 1,\n    **kwargs,\n):\n    \"\"\"Create file\n\n    Folders in file_name (e.g. folderA/folderB/file.csv) will be created implicitly\n\n    :param file_name: file name in root or path to file\n    :param file_content: file_content as bytes or BytesIO\n    :param multi_part_upload: boolean use multipart upload or not (only available from TM1 12 onwards)\n    By default, multi_part_upload is used for TM1 v12 and not used for TM1 v11\n    :param max_mb_per_part: max megabyte per part in multipart upload (only available from TM1 12 onwards)\n    :param max_workers: max parallel workers for multipart upload (only available from TM1 12 onwards)\n    \"\"\"\n    path = Path(file_name)\n    self._check_subfolder_support(path=path, function=\"FileService.create\")\n    if multi_part_upload:\n        self._check_mpu_support(function=\"FileService.create\")\n\n    # Create folder structure iteratively\n    if path.parents:\n        folder_path = Path()\n        for parent_folder in path.parts[:-1]:\n            folder_path = folder_path.joinpath(parent_folder)\n            self._create_folder(folder_name=folder_path)\n\n    url = self._construct_content_url(path, exclude_path_end=True, extension=\"Contents\")\n    body = {\"@odata.type\": \"#ibm.tm1.api.v1.Document\", \"ID\": path.name, \"Name\": path.name}\n    self._rest.POST(url, json.dumps(body), **kwargs)\n\n    return self._upload_file_content(path, file_content, multi_part_upload, max_mb_per_part, max_workers, **kwargs)\n</code></pre>"},{"location":"reference/services/fileservice/#TM1py.Services.FileService.FileService.delete","title":"<code>delete(file_name, **kwargs)</code>","text":"<p>Delete file</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>Union[str, Path]</code> <p>file name in root or path to file</p> required Source code in <code>TM1py/Services/FileService.py</code> <pre><code>@require_version(version=\"11.4\")\ndef delete(self, file_name: Union[str, Path], **kwargs):\n    \"\"\"Delete file\n\n    :param file_name: file name in root or path to file\n    \"\"\"\n    path = Path(file_name)\n    self._check_subfolder_support(path=path, function=\"FileService.delete\")\n\n    url = self._construct_content_url(path=path, exclude_path_end=False, extension=\"\")\n\n    return self._rest.DELETE(url, **kwargs)\n</code></pre>"},{"location":"reference/services/fileservice/#TM1py.Services.FileService.FileService.exists","title":"<code>exists(file_name, **kwargs)</code>","text":"<p>Check if file exists</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>Union[str, Path]</code> <p>file name in root or path to file</p> required Source code in <code>TM1py/Services/FileService.py</code> <pre><code>@require_version(version=\"11.4\")\ndef exists(self, file_name: Union[str, Path], **kwargs):\n    \"\"\"Check if file exists\n\n    :param file_name: file name in root or path to file\n    \"\"\"\n    url = self._construct_content_url(path=Path(file_name), exclude_path_end=False, extension=\"\")\n\n    return self._exists(url, **kwargs)\n</code></pre>"},{"location":"reference/services/fileservice/#TM1py.Services.FileService.FileService.get","title":"<code>get(file_name, **kwargs)</code>","text":"<p>Get file</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>file name in root or path to file</p> required Source code in <code>TM1py/Services/FileService.py</code> <pre><code>@require_version(version=\"11.4\")\ndef get(self, file_name: str, **kwargs) -&gt; bytes:\n    \"\"\"Get file\n\n    :param file_name: file name in root or path to file\n    \"\"\"\n    path = Path(file_name)\n    self._check_subfolder_support(path=path, function=\"FileService.get\")\n\n    url = self._construct_content_url(path=path, exclude_path_end=False, extension=\"Content\")\n\n    return self._rest.GET(url, **kwargs).content\n</code></pre>"},{"location":"reference/services/fileservice/#TM1py.Services.FileService.FileService.get_all_names","title":"<code>get_all_names(path='', **kwargs)</code>","text":"<p>return list of blob file names</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>path to folder. When empty searches in root</p> <code>''</code> Source code in <code>TM1py/Services/FileService.py</code> <pre><code>@require_version(version=\"11.4\")\ndef get_all_names(self, path: Union[str, Path] = \"\", **kwargs) -&gt; List[str]:\n    \"\"\"return list of blob file names\n\n    :param path: path to folder. When empty searches in root\n    \"\"\"\n    path = Path(path)\n    url = self._construct_content_url(path, exclude_path_end=False, extension=\"Contents\")\n\n    response = self._rest.GET(url, **kwargs).content\n    return [file[\"Name\"] for file in json.loads(response)[\"value\"]]\n</code></pre>"},{"location":"reference/services/fileservice/#TM1py.Services.FileService.FileService.get_names","title":"<code>get_names(**kwargs)</code>","text":"Source code in <code>TM1py/Services/FileService.py</code> <pre><code>@require_version(version=\"11.4\")\ndef get_names(self, **kwargs) -&gt; bytes:\n    warnings.warn(\n        \"Function get_names will be deprecated. Use get_all_names instead\", DeprecationWarning, stacklevel=2\n    )\n\n    url = format_url(\n        \"/Contents('{version_content_path}')/Contents?$select=Name\", version_content_path=self.version_content_path\n    )\n\n    return self._rest.GET(url, **kwargs).content\n</code></pre>"},{"location":"reference/services/fileservice/#TM1py.Services.FileService.FileService.search_string_in_name","title":"<code>search_string_in_name(name_startswith=None, name_contains=None, name_contains_operator='and', path='', **kwargs)</code>","text":"<p>Return list of blob files that match search critera</p> <p>Parameters:</p> Name Type Description Default <code>name_startswith</code> <code>str</code> <p>str, file name begins with (case insensitive)</p> <code>None</code> <code>name_contains</code> <code>Iterable</code> <p>iterable, found anywhere in name (case insensitive)</p> <code>None</code> <code>name_contains_operator</code> <code>str</code> <p>'and' or 'or'</p> <code>'and'</code> <code>path</code> <code>Union[Path, str]</code> <p>search in given path or root</p> <code>''</code> Source code in <code>TM1py/Services/FileService.py</code> <pre><code>@require_version(version=\"11.4\")\ndef search_string_in_name(\n    self,\n    name_startswith: str = None,\n    name_contains: Iterable = None,\n    name_contains_operator: str = \"and\",\n    path: Union[Path, str] = \"\",\n    **kwargs,\n) -&gt; List[str]:\n    \"\"\"Return list of blob files that match search critera\n\n    :param name_startswith: str, file name begins with (case insensitive)\n    :param name_contains: iterable, found anywhere in name (case insensitive)\n    :param name_contains_operator: 'and' or 'or'\n    :param path: search in given path or root\n    \"\"\"\n\n    name_contains_operator = name_contains_operator.strip().lower()\n    if name_contains_operator not in (\"and\", \"or\"):\n        raise ValueError(\"'name_contains_operator' must be either 'AND' or 'OR'\")\n\n    name_filters = []\n\n    if name_startswith:\n        name_filters.append(format_url(\"startswith(tolower(Name),tolower('{}'))\", name_startswith))\n\n    if name_contains:\n        if isinstance(name_contains, str):\n            name_filters.append(format_url(\"contains(tolower(Name),tolower('{}'))\", name_contains))\n\n        elif isinstance(name_contains, Iterable):\n            name_contains_filters = [\n                format_url(\"contains(tolower(Name),tolower('{}'))\", wildcard) for wildcard in name_contains\n            ]\n            name_filters.append(\"({})\".format(f\" {name_contains_operator} \".join(name_contains_filters)))\n\n        else:\n            raise ValueError(\"'name_contains' must be str or iterable\")\n\n    path = Path(path)\n    self._check_subfolder_support(path=path, function=\"FileService.search_string_in_name\")\n\n    url = self._construct_content_url(\n        path=Path(path),\n        exclude_path_end=False,\n        extension=\"Contents?$select=Name&amp;$filter={}\".format(\" and \".join(name_filters)),\n    )\n    response = self._rest.GET(url, **kwargs).content\n\n    return list(file[\"Name\"] for file in json.loads(response)[\"value\"])\n</code></pre>"},{"location":"reference/services/fileservice/#TM1py.Services.FileService.FileService.update","title":"<code>update(file_name, file_content, multi_part_upload=None, max_mb_per_part=200, max_workers=1, **kwargs)</code>","text":"<p>Update existing file</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>Union[str, Path]</code> <p>file name in root or path to file</p> required <code>file_content</code> <code>Union[bytes, BytesIO]</code> <p>file_content as bytes or BytesIO</p> required <code>multi_part_upload</code> <code>bool</code> <p>boolean use multipart upload or not (only available from TM1 12 onwards) By default, multi_part_upload is used for TM1 v12 and not used for TM1 v11</p> <code>None</code> <code>max_mb_per_part</code> <code>float</code> <p>max megabyte per part in multipart upload (only available from TM1 12 onwards)</p> <code>200</code> <code>max_workers</code> <code>int</code> <p>max parallel workers for multipart upload (only available from TM1 12 onwards)</p> <code>1</code> Source code in <code>TM1py/Services/FileService.py</code> <pre><code>@require_version(version=\"11.4\")\ndef update(\n    self,\n    file_name: Union[str, Path],\n    file_content: Union[bytes, BytesIO],\n    multi_part_upload: bool = None,\n    max_mb_per_part: float = 200,\n    max_workers: int = 1,\n    **kwargs,\n):\n    \"\"\"Update existing file\n\n    :param file_name: file name in root or path to file\n    :param file_content: file_content as bytes or BytesIO\n    :param multi_part_upload: boolean use multipart upload or not (only available from TM1 12 onwards)\n    By default, multi_part_upload is used for TM1 v12 and not used for TM1 v11\n    :param max_mb_per_part: max megabyte per part in multipart upload (only available from TM1 12 onwards)\n    :param max_workers: max parallel workers for multipart upload (only available from TM1 12 onwards)\n    \"\"\"\n    path = Path(file_name)\n    self._check_subfolder_support(path=path, function=\"FileService.update\")\n    if multi_part_upload:\n        self._check_mpu_support(function=\"FileService.create\")\n\n    return self._upload_file_content(path, file_content, multi_part_upload, max_mb_per_part, max_workers, **kwargs)\n</code></pre>"},{"location":"reference/services/fileservice/#TM1py.Services.FileService.FileService.update_or_create","title":"<code>update_or_create(file_name, file_content, multi_part_upload=None, max_mb_per_part=200, max_workers=1, **kwargs)</code>","text":"<p>Create file or update file if it already exists</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>Union[str, Path]</code> <p>file name in root or path to file</p> required <code>file_content</code> <code>bytes</code> <p>file_content as bytes or BytesIO</p> required <code>multi_part_upload</code> <code>bool</code> <p>boolean use multipart upload or not (only available from TM1 12 onwards). By default, multi_part_upload is used for TM1 v12 and not used for TM1 v11</p> <code>None</code> <code>max_mb_per_part</code> <code>float</code> <p>max megabyte per part in multipart upload (only available from TM1 12 onwards)</p> <code>200</code> <code>max_workers</code> <code>int</code> <p>max parallel workers for multipart upload (only available from TM1 12 onwards)</p> <code>1</code> Source code in <code>TM1py/Services/FileService.py</code> <pre><code>@require_version(version=\"11.4\")\ndef update_or_create(\n    self,\n    file_name: Union[str, Path],\n    file_content: bytes,\n    multi_part_upload: bool = None,\n    max_mb_per_part: float = 200,\n    max_workers: int = 1,\n    **kwargs,\n):\n    \"\"\"Create file or update file if it already exists\n\n    :param file_name: file name in root or path to file\n    :param file_content: file_content as bytes or BytesIO\n    :param multi_part_upload: boolean use multipart upload or not (only available from TM1 12 onwards).\n    By default, multi_part_upload is used for TM1 v12 and not used for TM1 v11\n    :param max_mb_per_part: max megabyte per part in multipart upload (only available from TM1 12 onwards)\n    :param max_workers: max parallel workers for multipart upload (only available from TM1 12 onwards)\n    \"\"\"\n    if self.exists(file_name, **kwargs):\n        return self.update(file_name, file_content, multi_part_upload, max_mb_per_part, max_workers, **kwargs)\n\n    return self.create(file_name, file_content, multi_part_upload, max_mb_per_part, max_workers, **kwargs)\n</code></pre>"},{"location":"reference/services/gitservice/","title":"GitService","text":""},{"location":"reference/services/gitservice/#TM1py.Services.GitService.GitService","title":"<code>GitService(rest)</code>","text":"<p>               Bases: <code>ObjectService</code></p> <p>Service to interact with GIT</p> Source code in <code>TM1py/Services/GitService.py</code> <pre><code>def __init__(self, rest: RestService):\n    super().__init__(rest)\n</code></pre>"},{"location":"reference/services/gitservice/#TM1py.Services.GitService.GitService.COMMON_PARAMETERS","title":"<code>COMMON_PARAMETERS = {'username': 'Username', 'password': 'Password', 'message': 'Message', 'author': 'Author', 'email': 'Email', 'branch': 'Branch', 'new_branch': 'NewBranch', 'force': 'Force', 'public_key': 'PublicKey', 'private_key': 'PrivateKey', 'passphrase': 'Passphrase', 'config': 'Config'}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/services/gitservice/#TM1py.Services.GitService.GitService.git_execute_plan","title":"<code>git_execute_plan(plan_id, **kwargs)</code>","text":"<p>Executes a plan based on the planid</p> <p>Parameters:</p> Name Type Description Default <code>plan_id</code> <code>str</code> <p>GitPlan id</p> required Source code in <code>TM1py/Services/GitService.py</code> <pre><code>def git_execute_plan(self, plan_id: str, **kwargs) -&gt; Response:\n    \"\"\"Executes a plan based on the planid\n    :param plan_id: GitPlan id\n    \"\"\"\n    url = format_url(\"/GitPlans('{}')/tm1.Execute\", plan_id)\n    return self._rest.POST(url=url, **kwargs)\n</code></pre>"},{"location":"reference/services/gitservice/#TM1py.Services.GitService.GitService.git_get_plans","title":"<code>git_get_plans(**kwargs)</code>","text":"<p>Gets a list of currently available GIT plans</p> Source code in <code>TM1py/Services/GitService.py</code> <pre><code>def git_get_plans(self, **kwargs) -&gt; List[GitPlan]:\n    \"\"\"Gets a list of currently available GIT plans\"\"\"\n    url = \"/GitPlans\"\n    plans = []\n\n    response = self._rest.GET(url=url, **kwargs)\n\n    # Every individual plan is wrapped in a \"value\" parent, iterate through those to get the actual plans\n    for plan in response.json().get(\"value\"):\n        plan_id = plan.get(\"ID\")\n        # Check if plan has an ID, sometimes there's a null in the mix that we don't want\n        if plan_id is None:\n            continue\n        plan_branch = plan.get(\"Branch\")\n        plan_force = plan.get(\"Force\")\n\n        # A git plan can either be a PushPlan or a PullPlan, these have slightly different variables,\n        # so we need to handle those differently\n        if plan.get(\"@odata.type\") == \"#ibm.tm1.api.v1.GitPushPlan\":\n            plan_new_branch = plan.get(\"NewBranch\")\n            plan_source_files = plan.get(\"SourceFiles\")\n\n            new_commit = GitCommit(\n                commit_id=plan.get(\"NewCommit\").get(\"ID\"),\n                summary=plan.get(\"NewCommit\").get(\"Summary\"),\n                author=plan.get(\"NewCommit\").get(\"Author\"),\n            )\n\n            parent_commit = GitCommit(\n                commit_id=plan.get(\"ParentCommit\").get(\"ID\"),\n                summary=plan.get(\"ParentCommit\").get(\"Summary\"),\n                author=plan.get(\"ParentCommit\").get(\"Author\"),\n            )\n\n            current_plan = GitPushPlan(\n                plan_id=plan_id,\n                branch=plan_branch,\n                force=plan_force,\n                new_branch=plan_new_branch,\n                new_commit=new_commit,\n                parent_commit=parent_commit,\n                source_files=plan_source_files,\n            )\n\n        elif plan.get(\"@odata.type\") == \"#ibm.tm1.api.v1.GitPullPlan\":\n\n            plan_commit = GitCommit(\n                commit_id=plan.get(\"Commit\").get(\"ID\"),\n                summary=plan.get(\"Commit\").get(\"Summary\"),\n                author=plan.get(\"Commit\").get(\"Author\"),\n            )\n\n            plan_operations = plan.get(\"Operations\")\n            current_plan = GitPullPlan(\n                plan_id=plan_id,\n                branch=plan_branch,\n                force=plan_force,\n                commit=plan_commit,\n                operations=plan_operations,\n            )\n\n        else:\n            raise RuntimeError(f\"Invalid plan detected: {plan.get('@odata.type')}\")\n\n        plans.append(current_plan)\n\n    return plans\n</code></pre>"},{"location":"reference/services/gitservice/#TM1py.Services.GitService.GitService.git_init","title":"<code>git_init(git_url, deployment, username=None, password=None, public_key=None, private_key=None, passphrase=None, force=None, config=None, **kwargs)</code>","text":"<p>Initialize GIT service, returns Git object</p> <p>Parameters:</p> Name Type Description Default <code>git_url</code> <code>str</code> <p>file or http(s) path to GIT repository</p> required <code>deployment</code> <code>str</code> <p>name of selected deployment group</p> required <code>username</code> <code>str</code> <p>GIT username</p> <code>None</code> <code>password</code> <code>str</code> <p>GIT password</p> <code>None</code> <code>public_key</code> <code>str</code> <p>SSH public key, available from PAA V2.0.9.4</p> <code>None</code> <code>private_key</code> <code>str</code> <p>SSH private key, available from PAA V2.0.9.4</p> <code>None</code> <code>passphrase</code> <code>str</code> <p>Passphrase for decrypting private key, if set</p> <code>None</code> <code>force</code> <code>bool</code> <p>reset git context on True</p> <code>None</code> <code>config</code> <code>dict</code> <p>Dictionary containing git configuration parameters</p> <code>None</code> Source code in <code>TM1py/Services/GitService.py</code> <pre><code>def git_init(\n    self,\n    git_url: str,\n    deployment: str,\n    username: str = None,\n    password: str = None,\n    public_key: str = None,\n    private_key: str = None,\n    passphrase: str = None,\n    force: bool = None,\n    config: dict = None,\n    **kwargs,\n) -&gt; Git:\n    \"\"\"Initialize GIT service, returns Git object\n    :param git_url: file or http(s) path to GIT repository\n    :param deployment: name of selected deployment group\n    :param username: GIT username\n    :param password: GIT password\n    :param public_key: SSH public key, available from PAA V2.0.9.4\n    :param private_key: SSH private key, available from PAA V2.0.9.4\n    :param passphrase: Passphrase for decrypting private key, if set\n    :param force: reset git context on True\n    :param config: Dictionary containing git configuration parameters\n    \"\"\"\n    url = \"/GitInit\"\n    body = {\"URL\": git_url, \"Deployment\": deployment}\n\n    for key, value in locals().items():\n        if value is not None and key in self.COMMON_PARAMETERS.keys():\n            body[self.COMMON_PARAMETERS.get(key)] = value\n\n    body_json = json.dumps(body)\n    response = self._rest.POST(url=url, data=body_json, **kwargs)\n\n    return Git.from_dict(response.json())\n</code></pre>"},{"location":"reference/services/gitservice/#TM1py.Services.GitService.GitService.git_pull","title":"<code>git_pull(branch, force=None, execute=None, username=None, password=None, public_key=None, private_key=None, passphrase=None, **kwargs)</code>","text":"<p>Creates a gitpull plan, returns response</p> <p>Parameters:</p> Name Type Description Default <code>branch</code> <code>str</code> <p>The name of source branch</p> required <code>force</code> <code>bool</code> <p>A flag passed in for evaluating preconditions</p> <code>None</code> <code>execute</code> <code>bool</code> <p>Executes the plan right away if True</p> <code>None</code> <code>username</code> <code>str</code> <p>GIT username</p> <code>None</code> <code>password</code> <code>str</code> <p>GIT password</p> <code>None</code> <code>public_key</code> <code>str</code> <p>SSH public key, available from PAA V2.0.9.4</p> <code>None</code> <code>private_key</code> <code>str</code> <p>SSH private key, available from PAA V2.0.9.4</p> <code>None</code> <code>passphrase</code> <code>str</code> <p>Passphrase for decrypting private key, if set</p> <code>None</code> Source code in <code>TM1py/Services/GitService.py</code> <pre><code>def git_pull(\n    self,\n    branch: str,\n    force: bool = None,\n    execute: bool = None,\n    username: str = None,\n    password: str = None,\n    public_key: str = None,\n    private_key: str = None,\n    passphrase: str = None,\n    **kwargs,\n) -&gt; Response:\n    \"\"\"Creates a gitpull plan, returns response\n    :param branch: The name of source branch\n    :param force: A flag passed in for evaluating preconditions\n    :param execute: Executes the plan right away if True\n    :param username: GIT username\n    :param password: GIT password\n    :param public_key: SSH public key, available from PAA V2.0.9.4\n    :param private_key: SSH private key, available from PAA V2.0.9.4\n    :param passphrase: Passphrase for decrypting private key, if set\n    \"\"\"\n    url = \"/GitPull\"\n    body = {}\n\n    for key, value in locals().items():\n        if value is not None and key in self.COMMON_PARAMETERS.keys():\n            body[self.COMMON_PARAMETERS.get(key)] = value\n\n    body_json = json.dumps(body)\n    response = self._rest.POST(url=url, data=body_json, **kwargs)\n\n    if execute:\n        plan_id = json.loads(response.content).get(\"ID\")\n        self.git_execute_plan(plan_id=plan_id)\n\n    return response\n</code></pre>"},{"location":"reference/services/gitservice/#TM1py.Services.GitService.GitService.git_push","title":"<code>git_push(message, author, email, branch=None, new_branch=None, force=False, username=None, password=None, public_key=None, private_key=None, passphrase=None, execute=None, **kwargs)</code>","text":"<p>Creates a gitpush plan, returns response</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Commit message</p> required <code>author</code> <code>str</code> <p>Name of commit author</p> required <code>email</code> <code>str</code> <p>Email of commit author</p> required <code>branch</code> <code>str</code> <p>The branch which last commit will be used as parent commit for new branch. Must be empty if GIT repo is empty</p> <code>None</code> <code>new_branch</code> <code>str</code> <p>If specified, creates a new branch and pushes the commit onto it. If not specified, pushes to the branch specified in \"Branch\"</p> <code>None</code> <code>force</code> <code>bool</code> <p>A flag passed in for evaluating preconditions</p> <code>False</code> <code>username</code> <code>str</code> <p>GIT username</p> <code>None</code> <code>password</code> <code>str</code> <p>GIT password</p> <code>None</code> <code>public_key</code> <code>str</code> <p>SSH public key, available from PAA V2.0.9.4</p> <code>None</code> <code>private_key</code> <code>str</code> <p>SSH private key, available from PAA V2.0.9.4</p> <code>None</code> <code>passphrase</code> <code>str</code> <p>Passphrase for decrypting private key, if set</p> <code>None</code> <code>execute</code> <code>bool</code> <p>Executes the plan right away if True</p> <code>None</code> Source code in <code>TM1py/Services/GitService.py</code> <pre><code>def git_push(\n    self,\n    message: str,\n    author: str,\n    email: str,\n    branch: str = None,\n    new_branch: str = None,\n    force: bool = False,\n    username: str = None,\n    password: str = None,\n    public_key: str = None,\n    private_key: str = None,\n    passphrase: str = None,\n    execute: bool = None,\n    **kwargs,\n) -&gt; Response:\n    \"\"\"Creates a gitpush plan, returns response\n    :param message: Commit message\n    :param author: Name of commit author\n    :param email: Email of commit author\n    :param branch: The branch which last commit will be used as parent commit for new branch.\n    Must be empty if GIT repo is empty\n    :param new_branch: If specified, creates a new branch and pushes the commit onto it. If not specified,\n    pushes to the branch specified in \"Branch\"\n    :param force: A flag passed in for evaluating preconditions\n    :param username: GIT username\n    :param password: GIT password\n    :param public_key: SSH public key, available from PAA V2.0.9.4\n    :param private_key: SSH private key, available from PAA V2.0.9.4\n    :param passphrase: Passphrase for decrypting private key, if set\n    :param execute: Executes the plan right away if True\n\n    \"\"\"\n    url = \"/GitPush\"\n    body = {}\n\n    for key, value in locals().items():\n        if value is not None and key in self.COMMON_PARAMETERS.keys():\n            body[self.COMMON_PARAMETERS.get(key)] = value\n\n    response = self._rest.POST(url=url, data=json.dumps(body), **kwargs)\n\n    if execute:\n        plan_id = json.loads(response.content).get(\"ID\")\n        self.git_execute_plan(plan_id=plan_id)\n\n    return response\n</code></pre>"},{"location":"reference/services/gitservice/#TM1py.Services.GitService.GitService.git_status","title":"<code>git_status(username=None, password=None, public_key=None, private_key=None, passphrase=None, **kwargs)</code>","text":"<p>Get GIT status, returns Git object</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>GIT username</p> <code>None</code> <code>password</code> <code>str</code> <p>GIT password</p> <code>None</code> <code>public_key</code> <code>str</code> <p>SSH public key, available from PAA V2.0.9.4</p> <code>None</code> <code>private_key</code> <code>str</code> <p>SSH private key, available from PAA V2.0.9.4</p> <code>None</code> <code>passphrase</code> <code>str</code> <p>Passphrase for decrypting private key, if set</p> <code>None</code> Source code in <code>TM1py/Services/GitService.py</code> <pre><code>def git_status(\n    self,\n    username: str = None,\n    password: str = None,\n    public_key: str = None,\n    private_key: str = None,\n    passphrase: str = None,\n    **kwargs,\n) -&gt; Git:\n    \"\"\"Get GIT status, returns Git object\n    :param username: GIT username\n    :param password: GIT password\n    :param public_key: SSH public key, available from PAA V2.0.9.4\n    :param private_key: SSH private key, available from PAA V2.0.9.4\n    :param passphrase: Passphrase for decrypting private key, if set\n    \"\"\"\n    url = \"/GitStatus\"\n    body = {}\n\n    for key, value in locals().items():\n        if value is not None and key in self.COMMON_PARAMETERS.keys():\n            body[self.COMMON_PARAMETERS.get(key)] = value\n\n    response = self._rest.POST(url=url, data=json.dumps(body), **kwargs)\n\n    return Git.from_dict(response.json())\n</code></pre>"},{"location":"reference/services/gitservice/#TM1py.Services.GitService.GitService.git_uninit","title":"<code>git_uninit(force=False, **kwargs)</code>","text":"<p>Unitialize GIT service</p> <p>Parameters:</p> Name Type Description Default <code>force</code> <code>bool</code> <p>clean up git context when True</p> <code>False</code> Source code in <code>TM1py/Services/GitService.py</code> <pre><code>def git_uninit(self, force: bool = False, **kwargs):\n    \"\"\"Unitialize GIT service\n\n    :param force: clean up git context when True\n    \"\"\"\n    url = \"/GitUninit\"\n    body = json.dumps(force)\n    return self._rest.POST(url=url, data=body, **kwargs)\n</code></pre>"},{"location":"reference/services/gitservice/#TM1py.Services.GitService.GitService.tm1project_delete","title":"<code>tm1project_delete()</code>","text":"Source code in <code>TM1py/Services/GitService.py</code> <pre><code>def tm1project_delete(self):\n    url = \"/!tm1project\"\n    empty_dict = {}\n    body_json = json.dumps(empty_dict)\n\n    response = self._rest.PUT(url, data=body_json)\n    return TM1Project.from_dict(response.json())\n</code></pre>"},{"location":"reference/services/gitservice/#TM1py.Services.GitService.GitService.tm1project_get","title":"<code>tm1project_get()</code>","text":"<p>summary</p> Source code in <code>TM1py/Services/GitService.py</code> <pre><code>def tm1project_get(self) -&gt; TM1Project:\n    \"\"\"_summary_\"\"\"\n    url = \"/!tm1project\"\n    response = self._rest.GET(url)\n    if not response.content:\n        return None\n\n    return TM1Project.from_dict(response.json())\n</code></pre>"},{"location":"reference/services/gitservice/#TM1py.Services.GitService.GitService.tm1project_put","title":"<code>tm1project_put(tm1_project)</code>","text":"Source code in <code>TM1py/Services/GitService.py</code> <pre><code>def tm1project_put(self, tm1_project: TM1Project) -&gt; TM1Project:\n    url = \"/!tm1project\"\n    body_json = tm1_project.body\n\n    # we need to ensure that async_requests_mode=False for this specific request as the response will not include\n    # the Location field with the async_id.\n    response = self._rest.PUT(url=url, data=body_json, async_requests_mode=False)\n    return TM1Project.from_dict(response.json())\n</code></pre>"},{"location":"reference/services/hierarchyservice/","title":"HierarchyService","text":""},{"location":"reference/services/hierarchyservice/#TM1py.Services.HierarchyService.HierarchyService","title":"<code>HierarchyService(rest)</code>","text":"<p>               Bases: <code>ObjectService</code></p> <p>Service to handle Object Updates for TM1 Hierarchies</p> Source code in <code>TM1py/Services/HierarchyService.py</code> <pre><code>def __init__(self, rest: RestService):\n    super().__init__(rest)\n    self.subsets = SubsetService(rest)\n    self.elements = ElementService(rest)\n</code></pre>"},{"location":"reference/services/hierarchyservice/#TM1py.Services.HierarchyService.HierarchyService.EDGES_WORKAROUND_VERSIONS","title":"<code>EDGES_WORKAROUND_VERSIONS = ('11.0.002', '11.0.003', '11.1.000')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/services/hierarchyservice/#TM1py.Services.HierarchyService.HierarchyService.HIERARCHY_SORT_ORDER_ARGUMENTS","title":"<code>HIERARCHY_SORT_ORDER_ARGUMENTS = CaseAndSpaceInsensitiveDict({'CompSortType': CaseAndSpaceInsensitiveSet(['ByInput', 'ByName']), 'CompSortSense': CaseAndSpaceInsensitiveSet(['Ascending', 'Descending']), 'ElSortType': CaseAndSpaceInsensitiveSet(['ByInput', 'ByName', 'ByLevel', 'ByHierarchy']), 'ElSortSense': CaseAndSpaceInsensitiveSet(['Ascending', 'Descending'])})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/services/hierarchyservice/#TM1py.Services.HierarchyService.HierarchyService.elements","title":"<code>elements = ElementService(rest)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/services/hierarchyservice/#TM1py.Services.HierarchyService.HierarchyService.subsets","title":"<code>subsets = SubsetService(rest)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/services/hierarchyservice/#TM1py.Services.HierarchyService.HierarchyService.add_edges","title":"<code>add_edges(dimension_name, hierarchy_name=None, edges=None, **kwargs)</code>","text":"<p>Add Edges to hierarchy. Fails if one edge already exists.</p> <p>Parameters:</p> Name Type Description Default <code>dimension_name</code> <code>str</code> required <code>hierarchy_name</code> <code>str</code> <code>None</code> <code>edges</code> <code>Dict[Tuple[str, str], int]</code> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> Source code in <code>TM1py/Services/HierarchyService.py</code> <pre><code>def add_edges(\n    self, dimension_name: str, hierarchy_name: str = None, edges: Dict[Tuple[str, str], int] = None, **kwargs\n) -&gt; Response:\n    \"\"\"Add Edges to hierarchy. Fails if one edge already exists.\n\n    :param dimension_name:\n    :param hierarchy_name:\n    :param edges:\n    :return:\n    \"\"\"\n    return self.elements.add_edges(dimension_name, hierarchy_name, edges, **kwargs)\n</code></pre>"},{"location":"reference/services/hierarchyservice/#TM1py.Services.HierarchyService.HierarchyService.add_element_attributes","title":"<code>add_element_attributes(dimension_name, hierarchy_name, element_attributes, **kwargs)</code>","text":"<p>Add element attributes to hierarchy. Fails if one element attribute already exists.</p> <p>Parameters:</p> Name Type Description Default <code>dimension_name</code> <code>str</code> required <code>hierarchy_name</code> <code>str</code> required <code>element_attributes</code> <code>List[ElementAttribute]</code> required <p>Returns:</p> Type Description Source code in <code>TM1py/Services/HierarchyService.py</code> <pre><code>def add_element_attributes(\n    self, dimension_name: str, hierarchy_name: str, element_attributes: List[ElementAttribute], **kwargs\n):\n    \"\"\"Add element attributes to hierarchy. Fails if one element attribute already exists.\n\n    :param dimension_name:\n    :param hierarchy_name:\n    :param element_attributes:\n    :return:\n    \"\"\"\n    return self.elements.add_element_attributes(dimension_name, hierarchy_name, element_attributes, **kwargs)\n</code></pre>"},{"location":"reference/services/hierarchyservice/#TM1py.Services.HierarchyService.HierarchyService.add_elements","title":"<code>add_elements(dimension_name, hierarchy_name, elements, **kwargs)</code>","text":"<p>Add elements to hierarchy. Fails if one element already exists.</p> <p>Parameters:</p> Name Type Description Default <code>dimension_name</code> <code>str</code> required <code>hierarchy_name</code> <code>str</code> required <code>elements</code> <code>List[Element]</code> required <p>Returns:</p> Type Description Source code in <code>TM1py/Services/HierarchyService.py</code> <pre><code>def add_elements(self, dimension_name: str, hierarchy_name: str, elements: List[Element], **kwargs):\n    \"\"\"Add elements to hierarchy. Fails if one element already exists.\n\n    :param dimension_name:\n    :param hierarchy_name:\n    :param elements:\n    :return:\n    \"\"\"\n    return self.elements.add_elements(dimension_name, hierarchy_name, elements, **kwargs)\n</code></pre>"},{"location":"reference/services/hierarchyservice/#TM1py.Services.HierarchyService.HierarchyService.create","title":"<code>create(hierarchy, **kwargs)</code>","text":"<p>Create a hierarchy in an existing dimension</p> <p>Parameters:</p> Name Type Description Default <code>hierarchy</code> <code>Hierarchy</code> required <p>Returns:</p> Type Description Source code in <code>TM1py/Services/HierarchyService.py</code> <pre><code>def create(self, hierarchy: Hierarchy, **kwargs):\n    \"\"\"Create a hierarchy in an existing dimension\n\n    :param hierarchy:\n    :return:\n    \"\"\"\n    url = format_url(\"/Dimensions('{}')/Hierarchies\", hierarchy.dimension_name)\n    response = self._rest.POST(url, hierarchy.body, **kwargs)\n\n    self.update_element_attributes(hierarchy, **kwargs)\n\n    return response\n</code></pre>"},{"location":"reference/services/hierarchyservice/#TM1py.Services.HierarchyService.HierarchyService.delete","title":"<code>delete(dimension_name, hierarchy_name, **kwargs)</code>","text":"Source code in <code>TM1py/Services/HierarchyService.py</code> <pre><code>def delete(self, dimension_name: str, hierarchy_name: str, **kwargs) -&gt; Response:\n    url = format_url(\"/Dimensions('{}')/Hierarchies('{}')\", dimension_name, hierarchy_name)\n    return self._rest.DELETE(url, **kwargs)\n</code></pre>"},{"location":"reference/services/hierarchyservice/#TM1py.Services.HierarchyService.HierarchyService.exists","title":"<code>exists(dimension_name, hierarchy_name, **kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>dimension_name</code> <code>str</code> required <code>hierarchy_name</code> <code>str</code> required <p>Returns:</p> Type Description <code>bool</code> Source code in <code>TM1py/Services/HierarchyService.py</code> <pre><code>def exists(self, dimension_name: str, hierarchy_name: str, **kwargs) -&gt; bool:\n    \"\"\"\n\n    :param dimension_name:\n    :param hierarchy_name:\n    :return:\n    \"\"\"\n    url = format_url(\"/Dimensions('{}')/Hierarchies?$select=Name\", dimension_name)\n\n    try:\n        response = self._rest.GET(url, **kwargs)\n    except TM1pyRestException as e:\n        if e.status_code == 404:\n            return False\n        raise e\n\n    existing_hierarchies = CaseAndSpaceInsensitiveSet([hierarchy[\"Name\"] for hierarchy in response.json()[\"value\"]])\n    return hierarchy_name in existing_hierarchies\n</code></pre>"},{"location":"reference/services/hierarchyservice/#TM1py.Services.HierarchyService.HierarchyService.get","title":"<code>get(dimension_name, hierarchy_name, **kwargs)</code>","text":"<p>get hierarchy</p> <p>Parameters:</p> Name Type Description Default <code>dimension_name</code> <code>str</code> <p>name of the dimension</p> required <code>hierarchy_name</code> <code>str</code> <p>name of the hierarchy</p> required <p>Returns:</p> Type Description <code>Hierarchy</code> Source code in <code>TM1py/Services/HierarchyService.py</code> <pre><code>def get(self, dimension_name: str, hierarchy_name: str, **kwargs) -&gt; Hierarchy:\n    \"\"\"get hierarchy\n\n    :param dimension_name: name of the dimension\n    :param hierarchy_name: name of the hierarchy\n    :return:\n    \"\"\"\n    url = format_url(\n        \"/Dimensions('{}')/Hierarchies('{}')?$expand=Edges,Elements,ElementAttributes,Subsets,DefaultMember\",\n        dimension_name,\n        hierarchy_name,\n    )\n    response = self._rest.GET(url, **kwargs)\n    return Hierarchy.from_dict(response.json())\n</code></pre>"},{"location":"reference/services/hierarchyservice/#TM1py.Services.HierarchyService.HierarchyService.get_all_names","title":"<code>get_all_names(dimension_name, **kwargs)</code>","text":"<p>get all names of existing Hierarchies in a dimension</p> <p>Parameters:</p> Name Type Description Default <code>dimension_name</code> <code>str</code> required <p>Returns:</p> Type Description <code>List[str]</code> Source code in <code>TM1py/Services/HierarchyService.py</code> <pre><code>def get_all_names(self, dimension_name: str, **kwargs) -&gt; List[str]:\n    \"\"\"get all names of existing Hierarchies in a dimension\n\n    :param dimension_name:\n    :return:\n    \"\"\"\n    url = format_url(\"/Dimensions('{}')/Hierarchies?$select=Name\", dimension_name)\n    response = self._rest.GET(url, **kwargs)\n    return [hierarchy[\"Name\"] for hierarchy in response.json()[\"value\"]]\n</code></pre>"},{"location":"reference/services/hierarchyservice/#TM1py.Services.HierarchyService.HierarchyService.get_cell_service","title":"<code>get_cell_service()</code>","text":"Source code in <code>TM1py/Services/HierarchyService.py</code> <pre><code>def get_cell_service(self):\n    from TM1py import CellService\n\n    return CellService(self._rest)\n</code></pre>"},{"location":"reference/services/hierarchyservice/#TM1py.Services.HierarchyService.HierarchyService.get_default_member","title":"<code>get_default_member(dimension_name, hierarchy_name=None, **kwargs)</code>","text":"<p>Get the defined default_member for a Hierarchy. Will return the element with index 1, if default member is not specified explicitly in }HierarchyProperty Cube</p> <p>Parameters:</p> Name Type Description Default <code>dimension_name</code> <code>str</code> required <code>hierarchy_name</code> <code>str</code> <code>None</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>String, name of Member</p> Source code in <code>TM1py/Services/HierarchyService.py</code> <pre><code>def get_default_member(self, dimension_name: str, hierarchy_name: str = None, **kwargs) -&gt; Optional[str]:\n    \"\"\"Get the defined default_member for a Hierarchy.\n    Will return the element with index 1, if default member is not specified explicitly in }HierarchyProperty Cube\n\n    :param dimension_name:\n    :param hierarchy_name:\n    :return: String, name of Member\n    \"\"\"\n    url = format_url(\n        \"/Dimensions('{dimension}')/Hierarchies('{hierarchy}')/DefaultMember\",\n        dimension=dimension_name,\n        hierarchy=hierarchy_name if hierarchy_name else dimension_name,\n    )\n    response = self._rest.GET(url=url, **kwargs)\n\n    if not response.text:\n        return None\n    return response.json()[\"Name\"]\n</code></pre>"},{"location":"reference/services/hierarchyservice/#TM1py.Services.HierarchyService.HierarchyService.get_dimension_service","title":"<code>get_dimension_service()</code>","text":"Source code in <code>TM1py/Services/HierarchyService.py</code> <pre><code>def get_dimension_service(self):\n    from TM1py import DimensionService\n\n    return DimensionService(self._rest)\n</code></pre>"},{"location":"reference/services/hierarchyservice/#TM1py.Services.HierarchyService.HierarchyService.get_hierarchy_summary","title":"<code>get_hierarchy_summary(dimension_name, hierarchy_name, **kwargs)</code>","text":"Source code in <code>TM1py/Services/HierarchyService.py</code> <pre><code>def get_hierarchy_summary(self, dimension_name: str, hierarchy_name: str, **kwargs) -&gt; Dict[str, int]:\n    hierarchy_properties = (\"Elements\", \"Edges\", \"ElementAttributes\", \"Members\", \"Levels\")\n    url = format_url(\n        \"/Dimensions('{}')/Hierarchies('{}')?$expand=Edges/$count,Elements/$count,\"\n        \"ElementAttributes/$count,Members/$count,Levels/$count&amp;$select=Cardinality\",\n        dimension_name,\n        hierarchy_name,\n    )\n    hierary_summary_raw = self._rest.GET(url, **kwargs).json()\n\n    return {\n        hierarchy_property: hierary_summary_raw[hierarchy_property + \"@odata.count\"]\n        for hierarchy_property in hierarchy_properties\n    }\n</code></pre>"},{"location":"reference/services/hierarchyservice/#TM1py.Services.HierarchyService.HierarchyService.is_balanced","title":"<code>is_balanced(dimension_name, hierarchy_name, **kwargs)</code>","text":"<p>Check if hierarchy is balanced</p> <p>Parameters:</p> Name Type Description Default <code>dimension_name</code> <code>str</code> required <code>hierarchy_name</code> <code>str</code> required <p>Returns:</p> Type Description Source code in <code>TM1py/Services/HierarchyService.py</code> <pre><code>def is_balanced(self, dimension_name: str, hierarchy_name: str, **kwargs):\n    \"\"\"Check if hierarchy is balanced\n\n    :param dimension_name:\n    :param hierarchy_name:\n    :return:\n    \"\"\"\n    url = format_url(\"/Dimensions('{}')/Hierarchies('{}')/Structure/$value\", dimension_name, hierarchy_name)\n    structure = int(self._rest.GET(url, **kwargs).text)\n    # 0 = balanced, 2 = unbalanced\n    if structure == 0:\n        return True\n    elif structure == 2:\n        return False\n    else:\n        raise RuntimeError(f\"Unexpected return value from TM1 API request: {str(structure)}\")\n</code></pre>"},{"location":"reference/services/hierarchyservice/#TM1py.Services.HierarchyService.HierarchyService.remove_all_edges","title":"<code>remove_all_edges(dimension_name, hierarchy_name=None, **kwargs)</code>","text":"Source code in <code>TM1py/Services/HierarchyService.py</code> <pre><code>def remove_all_edges(self, dimension_name: str, hierarchy_name: str = None, **kwargs) -&gt; Response:\n    if not hierarchy_name:\n        hierarchy_name = dimension_name\n    url = format_url(\"/Dimensions('{}')/Hierarchies('{}')\", dimension_name, hierarchy_name)\n    body = {\"Edges\": []}\n    return self._rest.PATCH(url=url, data=json.dumps(body), **kwargs)\n</code></pre>"},{"location":"reference/services/hierarchyservice/#TM1py.Services.HierarchyService.HierarchyService.remove_edges_under_consolidation","title":"<code>remove_edges_under_consolidation(dimension_name, hierarchy_name, consolidation_element, **kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>dimension_name</code> <code>str</code> <p>Name of the dimension</p> required <code>hierarchy_name</code> <code>str</code> <p>Name of the hierarchy</p> required <code>consolidation_element</code> <code>str</code> <p>Name of the Consolidated element</p> required <p>Returns:</p> Type Description <code>List[Response]</code> <p>response</p> Source code in <code>TM1py/Services/HierarchyService.py</code> <pre><code>def remove_edges_under_consolidation(\n    self, dimension_name: str, hierarchy_name: str, consolidation_element: str, **kwargs\n) -&gt; List[Response]:\n    \"\"\"\n    :param dimension_name: Name of the dimension\n    :param hierarchy_name: Name of the hierarchy\n    :param consolidation_element: Name of the Consolidated element\n    :return: response\n    \"\"\"\n    hierarchy = self.get(dimension_name, hierarchy_name)\n    from TM1py.Services import ElementService\n\n    element_service = ElementService(self._rest)\n    elements_under_consolidations = CaseAndSpaceInsensitiveSet(\n        element_service.get_members_under_consolidation(dimension_name, hierarchy_name, consolidation_element)\n    )\n    elements_under_consolidations.add(consolidation_element)\n    remove_edges = []\n    for parent, component in hierarchy.edges:\n        if parent in elements_under_consolidations and component in elements_under_consolidations:\n            remove_edges.append((parent, component))\n    hierarchy.remove_edges(remove_edges)\n    return self.update(hierarchy, **kwargs)\n</code></pre>"},{"location":"reference/services/hierarchyservice/#TM1py.Services.HierarchyService.HierarchyService.update","title":"<code>update(hierarchy, keep_existing_attributes=False, **kwargs)</code>","text":"<p>update a hierarchy. It's a two step process: 1. Update Hierarchy 2. Update Element-Attributes</p> <p>Function caters for Bug with Edge Creation: https://www.ibm.com/developerworks/community/forums/html/topic?id=75f2b99e-6961-4c71-9364-1d5e1e083eff</p> <p>Parameters:</p> Name Type Description Default <code>hierarchy</code> <code>Hierarchy</code> <p>instance of TM1py.Hierarchy</p> required <code>keep_existing_attributes</code> <p>True to make sure existing attributes are not removed</p> <code>False</code> <p>Returns:</p> Type Description <code>List[Response]</code> <p>list of responses</p> Source code in <code>TM1py/Services/HierarchyService.py</code> <pre><code>def update(self, hierarchy: Hierarchy, keep_existing_attributes=False, **kwargs) -&gt; List[Response]:\n    \"\"\"update a hierarchy. It's a two step process:\n    1. Update Hierarchy\n    2. Update Element-Attributes\n\n    Function caters for Bug with Edge Creation:\n    https://www.ibm.com/developerworks/community/forums/html/topic?id=75f2b99e-6961-4c71-9364-1d5e1e083eff\n\n    :param hierarchy: instance of TM1py.Hierarchy\n    :param keep_existing_attributes: True to make sure existing attributes are not removed\n    :return: list of responses\n    \"\"\"\n    # functions returns multiple responses\n    responses = list()\n    # 1. Update Hierarchy\n    url = format_url(\"/Dimensions('{}')/Hierarchies('{}')\", hierarchy.dimension_name, hierarchy.name)\n    # Workaround EDGES: Handle Issue, that Edges cant be created in one batch with the Hierarchy in certain versions\n    hierarchy_body = hierarchy.body_as_dict\n    if self.version[0:8] in self.EDGES_WORKAROUND_VERSIONS:\n        del hierarchy_body[\"Edges\"]\n    responses.append(self._rest.PATCH(url, json.dumps(hierarchy_body), **kwargs))\n\n    # 2. Update Attributes\n    responses.append(\n        self.update_element_attributes(\n            hierarchy=hierarchy, keep_existing_attributes=keep_existing_attributes, **kwargs\n        )\n    )\n\n    # Workaround EDGES\n    if self.version[0:8] in self.EDGES_WORKAROUND_VERSIONS:\n        process_service = self._get_process_service()\n        ti_function = \"HierarchyElementComponentAdd('{}', '{}', '{}', '{}', {});\"\n        ti_statements = [\n            ti_function.format(\n                hierarchy.dimension_name, hierarchy.name, edge[0], edge[1], hierarchy.edges[(edge[0], edge[1])]\n            )\n            for edge in hierarchy.edges\n        ]\n        responses.append(process_service.execute_ti_code(lines_prolog=ti_statements, **kwargs))\n\n    return responses\n</code></pre>"},{"location":"reference/services/hierarchyservice/#TM1py.Services.HierarchyService.HierarchyService.update_default_member","title":"<code>update_default_member(dimension_name, hierarchy_name=None, member_name='', **kwargs)</code>","text":"<p>Update the default member of a hierarchy.</p> <p>Parameters:</p> Name Type Description Default <code>dimension_name</code> <code>str</code> required <code>hierarchy_name</code> <code>str</code> <code>None</code> <code>member_name</code> <code>str</code> <code>''</code> <p>Returns:</p> Type Description <code>Response</code> Source code in <code>TM1py/Services/HierarchyService.py</code> <pre><code>def update_default_member(\n    self, dimension_name: str, hierarchy_name: str = None, member_name: str = \"\", **kwargs\n) -&gt; Response:\n    \"\"\"Update the default member of a hierarchy.\n\n    :param dimension_name:\n    :param hierarchy_name:\n    :param member_name:\n    :return:\n    \"\"\"\n    if verify_version(required_version=\"12\", version=self.version):\n        return self._update_default_member_via_api(dimension_name, hierarchy_name, member_name)\n    else:\n        return self._update_default_member_via_props_cube(dimension_name, hierarchy_name, member_name)\n</code></pre>"},{"location":"reference/services/hierarchyservice/#TM1py.Services.HierarchyService.HierarchyService.update_element_attributes","title":"<code>update_element_attributes(hierarchy, keep_existing_attributes=False, **kwargs)</code>","text":"<p>Update the elementattributes of a hierarchy</p> <p>Parameters:</p> Name Type Description Default <code>hierarchy</code> <code>Hierarchy</code> <p>Instance of TM1py.Hierarchy</p> required <code>keep_existing_attributes</code> <p>True to make sure existing attributes are not removed</p> <code>False</code> <p>Returns:</p> Type Description Source code in <code>TM1py/Services/HierarchyService.py</code> <pre><code>def update_element_attributes(self, hierarchy: Hierarchy, keep_existing_attributes=False, **kwargs):\n    \"\"\"Update the elementattributes of a hierarchy\n\n    :param hierarchy: Instance of TM1py.Hierarchy\n    :param keep_existing_attributes: True to make sure existing attributes are not removed\n    :return:\n    \"\"\"\n    # get existing attributes first\n    existing_element_attributes = self.elements.get_element_attributes(\n        dimension_name=hierarchy.dimension_name, hierarchy_name=hierarchy.name, **kwargs\n    )\n    existing_element_attributes = CaseAndSpaceInsensitiveDict({ea.name: ea for ea in existing_element_attributes})\n\n    attributes_to_create = list()\n    attributes_to_delete = list()\n    attributes_to_update = list()\n\n    for element_attribute in hierarchy.element_attributes:\n        if element_attribute.name not in existing_element_attributes:\n            attributes_to_create.append(element_attribute)\n            continue\n\n        existing_element_attribute = existing_element_attributes[element_attribute.name]\n        if not existing_element_attribute.attribute_type == element_attribute.attribute_type:\n            attributes_to_update.append(element_attribute)\n            continue\n\n    if not keep_existing_attributes:\n        for existing_element_attribute in existing_element_attributes:\n            if existing_element_attribute not in CaseAndSpaceInsensitiveSet(\n                [ea.name for ea in hierarchy.element_attributes]\n            ):\n                attributes_to_delete.append(existing_element_attribute)\n\n    for element_attribute in attributes_to_create:\n        self.elements.create_element_attribute(\n            dimension_name=hierarchy.dimension_name,\n            hierarchy_name=hierarchy.name,\n            element_attribute=element_attribute,\n            **kwargs,\n        )\n\n    for element_attribute in attributes_to_delete:\n        self.elements.delete_element_attribute(\n            dimension_name=hierarchy.dimension_name,\n            hierarchy_name=hierarchy.name,\n            element_attribute=element_attribute,\n            **kwargs,\n        )\n\n    for element_attribute in attributes_to_update:\n        self.elements.delete_element_attribute(\n            dimension_name=hierarchy.dimension_name,\n            hierarchy_name=hierarchy.name,\n            element_attribute=element_attribute.name,\n            **kwargs,\n        )\n        self.elements.create_element_attribute(\n            dimension_name=hierarchy.dimension_name,\n            hierarchy_name=hierarchy.name,\n            element_attribute=element_attribute,\n            **kwargs,\n        )\n</code></pre>"},{"location":"reference/services/hierarchyservice/#TM1py.Services.HierarchyService.HierarchyService.update_or_create","title":"<code>update_or_create(hierarchy, **kwargs)</code>","text":"<p>update if exists else create</p> <p>Parameters:</p> Name Type Description Default <code>hierarchy</code> <code>Hierarchy</code> required <p>Returns:</p> Type Description Source code in <code>TM1py/Services/HierarchyService.py</code> <pre><code>def update_or_create(self, hierarchy: Hierarchy, **kwargs):\n    \"\"\"update if exists else create\n\n    :param hierarchy:\n    :return:\n    \"\"\"\n    if self.exists(dimension_name=hierarchy.dimension_name, hierarchy_name=hierarchy.name, **kwargs):\n        self.update(hierarchy=hierarchy, **kwargs)\n    else:\n        self.create(hierarchy=hierarchy, **kwargs)\n</code></pre>"},{"location":"reference/services/hierarchyservice/#TM1py.Services.HierarchyService.HierarchyService.update_or_create_hierarchy_from_dataframe","title":"<code>update_or_create_hierarchy_from_dataframe(dimension_name, hierarchy_name, df, element_column=None, verify_unique_elements=False, verify_edges=True, element_type_column='ElementType', unwind_all=False, unwind_consolidations=None, update_attribute_types=False, hierarchy_sort_order=None, delete_orphaned_consolidations=False, **kwargs)</code>","text":"<p>Update or Create a hierarchy based on a dataframe, while never deleting existing elements.</p> <p>Parameters:</p> Name Type Description Default <code>dimension_name</code> <code>str</code> <p>Name of the dimension</p> required <code>hierarchy_name</code> <code>str</code> <p>Name of the hierarchy</p> required <code>df</code> <code>DataFrame</code> <p>pd.DataFrame the data frame. Example: |    | Region  | ElementType | Alias:a     | Currency:s | population:n | level001 | level000 | level001_weight | level000_weight | |---:|:--------|:------------|:------------|:-----------|-------------:|:---------|:---------|----------------:|----------------:| |  0 | France  | Numeric     | Frankreich  | EUR        |     60000000 | Europe   | World    |               1 |               1 | |  1 | Belgium | Numeric     | Schweiz     | CHF        |      9000000 | Europe   | World    |               1 |               1 | |  2 | Germany | Numeric     | Deutschland | EUR        |     84000000 | Europe   | World    |               1 |               1 |  Names for the parent columns (level001, level000) are not configurable and <code>level000</code> is the top node. All columns except for the element_column, element_type_colums and parent columns are attribute columns. On attribute columns, you specify the type as a suffix. If no type is provided string attributes are created</p> required <code>element_type_column</code> <code>str</code> <p>str The column name in the df which specifies which element is which type. If None, all will be considered N level.</p> <code>'ElementType'</code> <code>element_column</code> <code>str</code> <p>str The column name of the element ID. If None, assumes first column is the element ID.</p> <code>None</code> <code>verify_unique_elements</code> <code>bool</code> <p>Abort early if element names are not unique</p> <code>False</code> <code>verify_edges</code> <code>bool</code> <p>Abort early if edges contain a circular reference.</p> <code>True</code> <code>unwind_all</code> <code>bool</code> <p>bool Unwind hierarch before creating new edges</p> <code>False</code> <code>unwind_consolidations</code> <code>Iterable</code> <p>list Unwind a list of specific consolidations in the hierarchy before creating new edges, if unwind_all is true, this list is ignored</p> <code>None</code> <code>update_attribute_types</code> <code>bool</code> <p>bool If True, function will delete and recreate attributes when a type change is requested. By default, function will not delete attributes.</p> <code>False</code> <code>hierarchy_sort_order</code> <code>Tuple[str, str, str, str]</code> <p>Dict Pass a Tuple with 4 values for: <code>CompSortType</code>, <code>CompSortSense</code>, <code>ElSortType</code>, <code>ElSortSense</code> to control sort order as in IBM docs: https://www.ibm.com/docs/en/planning-analytics/2.0.0?topic=hmtf-hierarchysortorder-1</p> <code>None</code> <code>delete_orphaned_consolidations</code> <code>bool</code> <p>bool If True, function will delete c elements that will have no children and will have no parents post update. By default, function will not delete orphaned consolidations.</p> <code>False</code> <p>Returns:</p> Type Description Source code in <code>TM1py/Services/HierarchyService.py</code> <pre><code>@require_pandas\n@require_data_admin\n@require_ops_admin\ndef update_or_create_hierarchy_from_dataframe(\n    self,\n    dimension_name: str,\n    hierarchy_name: str,\n    df: \"pd.DataFrame\",\n    element_column: str = None,\n    verify_unique_elements: bool = False,\n    verify_edges: bool = True,\n    element_type_column: str = \"ElementType\",\n    unwind_all: bool = False,\n    unwind_consolidations: Iterable = None,\n    update_attribute_types: bool = False,\n    hierarchy_sort_order: Tuple[str, str, str, str] = None,\n    delete_orphaned_consolidations: bool = False,\n    **kwargs,\n):\n    \"\"\"Update or Create a hierarchy based on a dataframe, while never deleting existing elements.\n\n    :param dimension_name:\n        Name of the dimension\n    :param hierarchy_name:\n        Name of the hierarchy\n    :param df: pd.DataFrame the data frame. Example:\n        |    | Region  | ElementType | Alias:a     | Currency:s | population:n | level001 | level000 | level001_weight | level000_weight |\n        |---:|:--------|:------------|:------------|:-----------|-------------:|:---------|:---------|----------------:|----------------:|\n        |  0 | France  | Numeric     | Frankreich  | EUR        |     60000000 | Europe   | World    |               1 |               1 |\n        |  1 | Belgium | Numeric     | Schweiz     | CHF        |      9000000 | Europe   | World    |               1 |               1 |\n        |  2 | Germany | Numeric     | Deutschland | EUR        |     84000000 | Europe   | World    |               1 |               1 |\n\n        Names for the parent columns (level001, level000) are not configurable and `level000` is the top node.\n        All columns except for the element_column, element_type_colums and parent columns are attribute columns.\n        On attribute columns, you specify the type as a suffix. If no type is provided string attributes are created\n\n    :param element_type_column: str\n        The column name in the df which specifies which element is which type.\n        If None, all will be considered N level.\n    :param element_column: str\n        The column name of the element ID. If None, assumes first column is the element ID.\n    :param verify_unique_elements:\n        Abort early if element names are not unique\n    :param verify_edges:\n        Abort early if edges contain a circular reference.\n    :param unwind_all: bool\n        Unwind hierarch before creating new edges\n    :param unwind_consolidations: list\n        Unwind a list of specific consolidations in the hierarchy before creating new edges,\n        if unwind_all is true, this list is ignored\n    :param update_attribute_types: bool\n        If True, function will delete and recreate attributes when a type change is requested.\n        By default, function will not delete attributes.\n    :param hierarchy_sort_order: Dict\n        Pass a Tuple with 4 values for: `CompSortType`, `CompSortSense`, `ElSortType`, `ElSortSense` to control\n        sort order as in IBM docs:\n        https://www.ibm.com/docs/en/planning-analytics/2.0.0?topic=hmtf-hierarchysortorder-1\n    :param delete_orphaned_consolidations: bool\n        If True, function will delete c elements that will have no children and will have no parents post update.\n        By default, function will not delete orphaned consolidations.\n\n    :return:\n\n    \"\"\"\n    if hierarchy_sort_order:\n        self._validate_hierarchy_sort_order_arguments(hierarchy_sort_order)\n\n    df = df.copy()\n\n    # element ID is in first column if not specified.\n    element_column = df.columns[0] if not element_column else element_column\n    df[element_column] = df[element_column].astype(str)\n\n    # assume all Numeric if no type is provided\n    if element_type_column not in df.columns:\n        df[element_type_column] = \"Numeric\"\n\n    # verify uniqueness of element names\n    if verify_unique_elements:\n        unique_element_names = len(set(df[element_column].str.lower().str.replace(\" \", \"\")))\n        if df.shape[0] != unique_element_names:\n            raise ValueError(\"There must be no duplicates in the element column\")\n\n    # verify alias uniqueness\n    alias_columns = tuple([col for col in df.columns if col.lower().endswith((\":a\", \":alias\"))])\n    if len(alias_columns) &gt; 0:\n        self._validate_alias_uniqueness(df=df[[element_column, *alias_columns]])\n\n    # backward compatibility for unwind, the value for unwind would be assinged to unwind_all. expected type is bool\n    if \"unwind\" in kwargs:\n        unwind_all = kwargs[\"unwind\"]\n\n    if unwind_consolidations:\n        if isinstance(unwind_consolidations, str) or not isinstance(unwind_consolidations, Iterable):\n            raise ValueError(\n                f\"value for 'unwind_consolidations' must be an iterable (e.g., list), \"\n                f\"but received: '{unwind_consolidations}' of type {type(unwind_consolidations).__name__}\"\n            )\n\n    # identify and sort level columns\n    level_columns = []\n    level_weight_columns = []\n    # sort to assure right order of levels (e.g. Level003 -&gt; level002 -&gt; LEVEL001)\n    sorted_level_columns = sorted(\n        [col for col in df.columns if any(char.isdigit() for char in col)],  # Filter columns with digits\n        key=lambda x: int(\"\".join(filter(str.isdigit, x))),  # Sort based on numeric part\n        reverse=True,  # Descending order\n    )\n    for column in sorted_level_columns:\n        if column.lower().startswith(\"level\") and column[5:8].isdigit():\n            if len(column) == 8:  # \"LevelXXX\"\n                level_columns.append(column)\n            elif len(column) == 15 and column.lower().endswith(\"_weight\"):  # \"LevelXXX_weight\"\n                level_weight_columns.append(column)\n\n    # case: no level weight columns. All weights are 1\n    if len(level_weight_columns) == 0:\n        for level_column in level_columns:\n            level_weight_column = level_column + \"_weight\"\n            level_weight_columns.append(level_weight_column)\n            df[level_weight_column] = 1\n\n    if not len(level_columns) == len(level_weight_columns):\n        raise ValueError(\"Number of level columns must be equal to number of level weight columns\")\n\n    if verify_edges:\n        self._validate_edges(df=df[[element_column, *level_columns]])\n\n    hierarchy_exists = self.exists(dimension_name, hierarchy_name)\n\n    if not hierarchy_exists:\n        existing_element_identifiers = CaseAndSpaceInsensitiveSet()\n    else:\n        existing_element_identifiers = self.elements.get_all_element_identifiers(\n            dimension_name=dimension_name, hierarchy_name=hierarchy_name\n        )\n\n    if not hierarchy_exists:\n        hierarchy = Hierarchy(name=hierarchy_name, dimension_name=dimension_name)\n        dimension_service = self.get_dimension_service()\n        if not dimension_service.exists(dimension_name):\n            dimension = Dimension(name=dimension_name, hierarchies=[hierarchy])\n            dimension_service.create(dimension)\n        else:\n            hierarchy = Hierarchy(name=hierarchy_name, dimension_name=dimension_name)\n            self.create(hierarchy)\n\n    # determine new elements based on Element Name column\n    new_elements = CaseAndSpaceInsensitiveDict(\n        {\n            element_name: Element.Types(element_type)\n            for element_name, element_type in df.loc[\n                ~df[element_column]\n                .str.lower()\n                .str.replace(\" \", \"\")\n                .isin(existing_element_identifiers._store.keys()),\n                (element_column, element_type_column),\n            ].itertuples(index=False)\n        }\n    )\n\n    # determine new consolidations based on level columns\n    for element_name in df[[*level_columns]].stack().unique():\n        if not element_name:\n            continue\n        if element_name in existing_element_identifiers:\n            continue\n        if element_name in new_elements and new_elements[element_name] != Element.Types.CONSOLIDATED:\n            raise ValueError(f\"Inconsistent Type for element: '{element_name}' in hierarchy '{hierarchy_name}'\")\n        new_elements[element_name] = Element.Types.CONSOLIDATED\n\n    if new_elements:\n        # add these elements to hierarchy in tm1\n        self.elements.add_elements(\n            dimension_name=dimension_name,\n            hierarchy_name=hierarchy_name,\n            elements=(Element(element_name, element_type) for element_name, element_type in new_elements.items()),\n        )\n\n    # define the attribute columns in df. Applies to all elements in df, not only new ones.\n    attribute_columns = df.columns.drop(\n        labels=[element_column] + [element_type_column] + level_columns + level_weight_columns, errors=\"ignore\"\n    )\n\n    # new attributes are created as strings if no type is provided\n    try:\n        existing_attributes = CaseAndSpaceInsensitiveDict(\n            {\n                ea.name: ElementAttribute.Types(ea.attribute_type)\n                for ea in self.elements.get_element_attributes(dimension_name, hierarchy_name)\n            }\n        )\n\n    except TM1pyRestException as ex:\n        if ex.status_code == 404:\n            existing_attributes = set()\n        else:\n            raise ex\n\n    new_attributes = []\n    for attribute_column in attribute_columns:\n        if \":\" in attribute_column:\n            attribute_name, attribute_type = attribute_column.rsplit(\":\", maxsplit=1)\n            attribute_type = self._attribute_type_from_code(attribute_type)\n\n        else:\n            attribute_name = attribute_column\n            attribute_type = ElementAttribute.Types.STRING\n\n        if attribute_name not in existing_attributes:\n            new_attributes.append(ElementAttribute(attribute_name, attribute_type))\n\n        if attribute_name in existing_attributes and update_attribute_types:\n            if attribute_type != existing_attributes[attribute_name]:\n                self.elements.delete_element_attribute(dimension_name, dimension_name, attribute_name)\n                new_attributes.append(ElementAttribute(attribute_name, attribute_type))\n\n    if new_attributes:\n        self.elements.add_element_attributes(\n            dimension_name=dimension_name, hierarchy_name=hierarchy_name, element_attributes=new_attributes\n        )\n\n    # define attributes df with ID + attribute columns.\n    id_attribute_cols = [element_column] + list(attribute_columns.values)\n    attributes_df: pd.DataFrame = df.loc[:, id_attribute_cols]\n\n    # melt for write structure (ID, Attribute) : Attribute_value\n    attributes_df = attributes_df.melt(\n        id_vars=element_column,\n        value_vars=attribute_columns,\n        var_name=\"}ElementAttributes_\" + dimension_name,\n        value_name=\"attribute_value\",\n    )\n    attributes_df.fillna(\"\", inplace=True)\n\n    # drop ':' suffix in attribute column\n    attribute_column = \"}ElementAttributes_\" + dimension_name\n    attributes_df[attribute_column] = attributes_df[attribute_column].apply(lambda x: x.rsplit(\":\", 1)[0])\n\n    # write attributes to cube\n    if not attributes_df.empty:\n        cell_service = self.get_cell_service()\n        # explicitly reference hierarchy if dimension_name != hierarchy_name\n        if not case_and_space_insensitive_equals(dimension_name, hierarchy_name):\n            attributes_df.iloc[:, 0] = hierarchy_name + \":\" + attributes_df.iloc[:, 0].astype(str)\n        cell_service.write_dataframe(\n            cube_name=\"}ElementAttributes_\" + dimension_name,\n            data=attributes_df,\n            sum_numeric_duplicates=False,\n            use_blob=True,\n        )\n\n    if unwind_all:\n        self.remove_all_edges(dimension_name=dimension_name, hierarchy_name=hierarchy_name)\n    else:\n        if unwind_consolidations:\n            edges_to_delete = CaseAndSpaceInsensitiveTuplesDict()\n            for elem in unwind_consolidations:\n                if not self.elements.exists(\n                    dimension_name=dimension_name, hierarchy_name=hierarchy_name, element_name=elem\n                ):\n                    continue\n\n                edges_under_consolidation = self.elements.get_edges_under_consolidation(\n                    dimension_name=dimension_name, hierarchy_name=hierarchy_name, consolidation=elem\n                )\n                edges_to_delete.join(edges_under_consolidation)\n\n            self.elements.delete_edges(\n                dimension_name=dimension_name,\n                hierarchy_name=hierarchy_name,\n                edges=edges_to_delete,\n                use_blob=self.is_admin,\n            )\n\n    edges = CaseAndSpaceInsensitiveTuplesDict()\n    for element_name, *record in df[[element_column, *level_columns, *level_weight_columns]].itertuples(\n        index=False\n    ):\n        levels = record[: len(level_columns)]\n        level_weights = record[len(level_columns) :]\n\n        previous_level = element_name\n        for level, weight in zip(levels, level_weights):\n            if not level:\n                continue\n            if not isinstance(level, str) and math.isnan(level):\n                continue\n            if level == previous_level:\n                continue\n\n            edges[level, previous_level] = weight\n            previous_level = level\n\n    if edges:\n        try:\n            current_edges = CaseAndSpaceInsensitiveTuplesDict(\n                self.elements.get_edges(dimension_name=dimension_name, hierarchy_name=hierarchy_name)\n            )\n        except TM1pyRestException as ex:\n            if ex.status_code == 404:\n                current_edges = CaseAndSpaceInsensitiveTuplesDict()\n            else:\n                raise ex\n\n        edges_to_delete = {(k, v): w for (k, v), w in edges.items() if w != current_edges.get((k, v), w)}\n        if edges_to_delete:\n            self.elements.delete_edges(\n                dimension_name=dimension_name,\n                hierarchy_name=hierarchy_name,\n                edges=edges_to_delete.keys(),\n                use_blob=self.is_admin,\n            )\n\n        new_edges = {\n            (k, v): w for (k, v), w in edges.items() if (k, v) not in current_edges or w != current_edges[(k, v)]\n        }\n        if new_edges:\n            self.elements.add_edges(dimension_name=dimension_name, hierarchy_name=hierarchy_name, edges=new_edges)\n\n    if hierarchy_sort_order:\n        self._implement_hierarchy_sort_order(dimension_name, hierarchy_name, hierarchy_sort_order)\n\n    if delete_orphaned_consolidations:\n        all_edges = self.elements.get_edges(dimension_name=dimension_name, hierarchy_name=hierarchy_name)\n\n        parents = CaseAndSpaceInsensitiveSet(parent for parent, _ in all_edges)\n        children = CaseAndSpaceInsensitiveSet(child for _, child in all_edges)\n        parents_and_children = parents.union(children)\n\n        consolidated_element_names = CaseAndSpaceInsensitiveSet(\n            self.elements.get_consolidated_element_names(\n                dimension_name=dimension_name, hierarchy_name=hierarchy_name\n            )\n        )\n        orphaned_consolidations = list(consolidated_element_names - parents_and_children)\n\n        if orphaned_consolidations:\n            self.elements.delete_elements(\n                dimension_name=dimension_name,\n                hierarchy_name=hierarchy_name,\n                element_names=orphaned_consolidations,\n                use_ti=self.is_admin,\n            )\n</code></pre>"},{"location":"reference/services/jobservice/","title":"JobService","text":""},{"location":"reference/services/jobservice/#TM1py.Services.JobService.JobService","title":"<code>JobService(rest)</code>","text":"<p>               Bases: <code>ObjectService</code></p> <p>Service to handle TM1 Job objects introduced in v12</p> Source code in <code>TM1py/Services/JobService.py</code> <pre><code>def __init__(self, rest: RestService):\n    super().__init__(rest)\n</code></pre>"},{"location":"reference/services/jobservice/#TM1py.Services.JobService.JobService.cancel","title":"<code>cancel(job_id, **kwargs)</code>","text":"<p>Cancels a running Job</p> <p>Parameters:</p> Name Type Description Default <code>job_id</code> required <p>Returns:</p> Type Description Source code in <code>TM1py/Services/JobService.py</code> <pre><code>@require_version(version=\"12.0.0\")\ndef cancel(self, job_id, **kwargs):\n    \"\"\"Cancels a running Job\n\n    :param job_id:\n    :return:\n    \"\"\"\n    url = format_url(\"/Jobs('{}')/tm1.Cancel\", str(job_id))\n    response = self._rest.POST(url, **kwargs)\n    return response\n</code></pre>"},{"location":"reference/services/jobservice/#TM1py.Services.JobService.JobService.cancel_all","title":"<code>cancel_all(**kwargs)</code>","text":"Source code in <code>TM1py/Services/JobService.py</code> <pre><code>@require_version(version=\"12.0.0\")\ndef cancel_all(self, **kwargs):\n    jobs = self.get_all()\n    canceled_jobs = list()\n    for job in jobs:\n        self.cancel(job[\"ID\"])\n        canceled_jobs.append(job)\n    return canceled_jobs\n</code></pre>"},{"location":"reference/services/jobservice/#TM1py.Services.JobService.JobService.get_all","title":"<code>get_all(**kwargs)</code>","text":"<p>Return a dict of the currently running jobs from the TM1 Server</p> <p>Returns:</p> Type Description <p>dict: the response</p> Source code in <code>TM1py/Services/JobService.py</code> <pre><code>@require_version(version=\"12.0.0\")\ndef get_all(self, **kwargs):\n    \"\"\"Return a dict of the currently running jobs from the TM1 Server\n\n    :return:\n        dict: the response\n    \"\"\"\n    url = \"/Jobs\"\n    response = self._rest.GET(url, **kwargs)\n    return response.json()[\"value\"]\n</code></pre>"},{"location":"reference/services/jobservice/#TM1py.Services.JobService.JobService.get_as_dataframe","title":"<code>get_as_dataframe()</code>","text":"<p>Gets jobs and returns them as a dataframe</p> Source code in <code>TM1py/Services/JobService.py</code> <pre><code>@require_pandas\n@require_version(version=\"12.0.0\")\ndef get_as_dataframe(self):\n    \"\"\"Gets jobs and returns them as a dataframe\"\"\"\n    jobs = self.get_all()\n    df = pd.DataFrame.from_records(jobs)\n    return df\n</code></pre>"},{"location":"reference/services/loggerservice/","title":"LoggerService","text":""},{"location":"reference/services/loggerservice/#TM1py.Services.LoggerService.LoggerService","title":"<code>LoggerService(rest)</code>","text":"<p>               Bases: <code>ObjectService</code></p> <p>Service to query and update loggers</p> Source code in <code>TM1py/Services/LoggerService.py</code> <pre><code>def __init__(self, rest: RestService):\n    super().__init__(rest)\n</code></pre>"},{"location":"reference/services/loggerservice/#TM1py.Services.LoggerService.LoggerService.exists","title":"<code>exists(logger, **kwargs)</code>","text":"<p>Test if logger exists</p> <p>Parameters:</p> Name Type Description Default <code>logger</code> <code>str</code> <p>string name of logger</p> required <p>Returns:</p> Type Description <code>bool</code> <p>bool</p> Source code in <code>TM1py/Services/LoggerService.py</code> <pre><code>@require_ops_admin\ndef exists(self, logger: str, **kwargs) -&gt; bool:\n    \"\"\"Test if logger exists\n    :param logger: string name of logger\n    :return: bool\n    \"\"\"\n    url = format_url(\"/Loggers('{}')\", logger)\n    return self._exists(url, **kwargs)\n</code></pre>"},{"location":"reference/services/loggerservice/#TM1py.Services.LoggerService.LoggerService.get","title":"<code>get(logger, **kwargs)</code>","text":"<p>Get level for specified logger</p> <p>Parameters:</p> Name Type Description Default <code>logger</code> <code>str</code> <p>string name of logger</p> required <p>Returns:</p> Type Description <code>Dict</code> <p>Dict of logger and level</p> Source code in <code>TM1py/Services/LoggerService.py</code> <pre><code>@require_ops_admin\ndef get(self, logger: str, **kwargs) -&gt; Dict:\n    \"\"\"Get level for specified logger\n\n    :param logger: string name of logger\n    :return: Dict of logger and level\n    \"\"\"\n    url = format_url(\"/Loggers('{}')\", logger)\n    logger = self._rest.GET(url, **kwargs).json()\n    del logger[\"@odata.context\"]\n    return logger\n</code></pre>"},{"location":"reference/services/loggerservice/#TM1py.Services.LoggerService.LoggerService.get_all","title":"<code>get_all(**kwargs)</code>","text":"Source code in <code>TM1py/Services/LoggerService.py</code> <pre><code>@require_ops_admin\ndef get_all(self, **kwargs) -&gt; Dict:\n    url = \"/Loggers\"\n    loggers = self._rest.GET(url, **kwargs).json()\n    return loggers[\"value\"]\n</code></pre>"},{"location":"reference/services/loggerservice/#TM1py.Services.LoggerService.LoggerService.get_all_names","title":"<code>get_all_names(**kwargs)</code>","text":"Source code in <code>TM1py/Services/LoggerService.py</code> <pre><code>@require_ops_admin\ndef get_all_names(self, **kwargs) -&gt; List[str]:\n    loggers = self.get_all(**kwargs)\n    return [logger[\"Name\"] for logger in loggers]\n</code></pre>"},{"location":"reference/services/loggerservice/#TM1py.Services.LoggerService.LoggerService.search","title":"<code>search(wildcard='', level='', **kwargs)</code>","text":"<p>Searches logger names by wildcard or by level. Combining wildcard and level will filter via AND and not OR</p> <p>Parameters:</p> Name Type Description Default <code>wildcard</code> <code>str</code> <p>string to match in logger name</p> <code>''</code> <code>level</code> <code>str</code> <p>string e.g. FATAL, ERROR, WARNING, INFO, DEBUG, UNKOWN, OFF</p> <code>''</code> <p>Returns:</p> Type Description <code>Dict</code> <p>Dict of matching loggers and levels</p> Source code in <code>TM1py/Services/LoggerService.py</code> <pre><code>@require_ops_admin\ndef search(self, wildcard: str = \"\", level: str = \"\", **kwargs) -&gt; Dict:\n    \"\"\"Searches logger names by wildcard or by level. Combining wildcard and level will filter via AND and not OR\n\n    :param wildcard: string to match in logger name\n    :param level: string e.g. FATAL, ERROR, WARNING, INFO, DEBUG, UNKOWN, OFF\n    :return: Dict of matching loggers and levels\n    \"\"\"\n    url = \"/Loggers\"\n\n    logger_filters = []\n\n    if level:\n        level_dict = CaseAndSpaceInsensitiveDict(\n            {\"FATAL\": 0, \"ERROR\": 1, \"WARNING\": 2, \"INFO\": 3, \"DEBUG\": 4, \"UNKNOWN\": 5, \"OFF\": 6}\n        )\n        level_index = level_dict.get(level)\n        if level_index:\n            logger_filters.append(\"Level eq {}\".format(level_index))\n\n    if wildcard:\n        logger_filters.append(\"contains(tolower(Name), tolower('{}'))\".format(wildcard))\n\n    url += \"?$filter={}\".format(\" and \".join(logger_filters))\n\n    loggers = self._rest.GET(url, **kwargs).json()\n    return loggers[\"value\"]\n</code></pre>"},{"location":"reference/services/loggerservice/#TM1py.Services.LoggerService.LoggerService.set_level","title":"<code>set_level(logger, level, **kwargs)</code>","text":"<p>Set logger level</p> <p>Parameters:</p> Name Type Description Default <code>logger</code> <code>str</code> <p>string name of logger</p> required <code>level</code> <code>str</code> <p>string e.g. FATAL, ERROR, WARNING, INFO, DEBUG, UNKOWN, OFF</p> required <p>Returns:</p> Type Description <p>response</p> Source code in <code>TM1py/Services/LoggerService.py</code> <pre><code>@require_ops_admin\ndef set_level(self, logger: str, level: str, **kwargs):\n    \"\"\"Set logger level\n    :param logger: string name of logger\n    :param level: string e.g. FATAL, ERROR, WARNING, INFO, DEBUG, UNKOWN, OFF\n    :return: response\n    \"\"\"\n    url = format_url(\"/Loggers('{}')\", logger)\n\n    if not self.exists(logger=logger, **kwargs):\n        raise ValueError(\"{} is not a valid logger\".format(logger))\n\n    level_dict = CaseAndSpaceInsensitiveDict(\n        {\"FATAL\": 0, \"ERROR\": 1, \"WARNING\": 2, \"INFO\": 3, \"DEBUG\": 4, \"UNKNOWN\": 5, \"OFF\": 6}\n    )\n    level_index = level_dict.get(level)\n    if level_index:\n        logger = {\"Level\": level_index}\n    else:\n        raise ValueError(\"{} is not a valid level\".format(level))\n\n    return self._rest.PATCH(url, json.dumps(logger))\n</code></pre>"},{"location":"reference/services/manageservice/","title":"ManageService","text":""},{"location":"reference/services/manageservice/#TM1py.Services.ManageService.ManageService","title":"<code>ManageService(domain, root_client, root_secret)</code>","text":"<p>Manage service to interact with the manage endpoint. The manage endpoint uses basic auth using the root client and secret</p> Source code in <code>TM1py/Services/ManageService.py</code> <pre><code>def __init__(self, domain, root_client, root_secret):\n    self._domain = domain\n    self._root_client = root_client\n    self._root_secret = root_secret\n    self._auth_header = HTTPBasicAuth(self._root_client, self._root_secret)\n    self._root_url = f\"{self._domain}/manage/v1\"\n</code></pre>"},{"location":"reference/services/manageservice/#TM1py.Services.ManageService.ManageService.__enter__","title":"<code>__enter__()</code>","text":"Source code in <code>TM1py/Services/ManageService.py</code> <pre><code>def __enter__(self):\n    return self\n</code></pre>"},{"location":"reference/services/manageservice/#TM1py.Services.ManageService.ManageService.__exit__","title":"<code>__exit__(exception_type, exception_value, traceback)</code>","text":"Source code in <code>TM1py/Services/ManageService.py</code> <pre><code>def __exit__(self, exception_type, exception_value, traceback):\n    pass\n</code></pre>"},{"location":"reference/services/manageservice/#TM1py.Services.ManageService.ManageService.create_and_upload_database_backup_set_file","title":"<code>create_and_upload_database_backup_set_file(instance_name, database_name, backup_set_name)</code>","text":"Source code in <code>TM1py/Services/ManageService.py</code> <pre><code>def create_and_upload_database_backup_set_file(self, instance_name: str, database_name: str, backup_set_name: str):\n\n    create_url = (\n        f\"{self._root_url}/Instances('{instance_name}')/Databases('{database_name}')\"\n        f\"/Contents('Files')/Contents('.backupsets')/Contents\"\n    )\n    payload = {\"@odata.type\": \"#ibm.tm1.api.v1.Document\", \"Name\": f\"{backup_set_name}.tgz\"}\n    requests.post(url=create_url, json=payload, auth=self._auth_header)\n\n    upload_url = (\n        f\"{self._root_url}/Instances('{instance_name}')/Databases('{database_name}')\"\n        f\"/Contents('Files')/Contents('.backupsets')/Contents('{backup_set_name}.tgz')/Content\"\n    )\n    response = requests.post(url=upload_url, json=payload, auth=self._auth_header)\n    return response\n</code></pre>"},{"location":"reference/services/manageservice/#TM1py.Services.ManageService.ManageService.create_application","title":"<code>create_application(instance_name, application_name)</code>","text":"Source code in <code>TM1py/Services/ManageService.py</code> <pre><code>def create_application(self, instance_name, application_name):\n    url = f\"{self._root_url}/Instances('{instance_name}')/Applications\"\n    payload = {\"Name\": application_name}\n    response = requests.post(url=url, json=payload, auth=self._auth_header)\n    response_json = json.loads(response.content)\n    return response_json[\"ClientID\"], response_json[\"ClientSecret\"]\n</code></pre>"},{"location":"reference/services/manageservice/#TM1py.Services.ManageService.ManageService.create_database","title":"<code>create_database(instance_name, database_name, number_replicas, product_version, cpu_requests='1000m', cpu_limits='2000m', memory_requests='1G', memory_limits='2G', storage_size='20Gi')</code>","text":"Source code in <code>TM1py/Services/ManageService.py</code> <pre><code>def create_database(\n    self,\n    instance_name,\n    database_name,\n    number_replicas,\n    product_version,\n    cpu_requests=\"1000m\",\n    cpu_limits=\"2000m\",\n    memory_requests=\"1G\",\n    memory_limits=\"2G\",\n    storage_size=\"20Gi\",\n):\n\n    url = f\"{self._root_url}/Instances('{instance_name}')/Databases\"\n\n    payload = {\n        \"Name\": database_name,\n        \"Replicas\": number_replicas,\n        \"ProductVersion\": product_version,\n        \"Resources\": {\n            \"Replica\": {\n                \"CPU\": {\"Requests\": cpu_requests, \"Limits\": cpu_limits},\n                \"Memory\": {\"Requests\": memory_requests, \"Limits\": memory_limits},\n            },\n            \"Storage\": {\"Size\": storage_size},\n        },\n    }\n    response = requests.post(url=url, json=payload, auth=self._auth_header)\n\n    return response\n</code></pre>"},{"location":"reference/services/manageservice/#TM1py.Services.ManageService.ManageService.create_database_backup","title":"<code>create_database_backup(instance_name, database_name, backup_set_name)</code>","text":"Source code in <code>TM1py/Services/ManageService.py</code> <pre><code>def create_database_backup(self, instance_name: str, database_name: str, backup_set_name: str):\n    url = f\"{self._root_url}/Instances('{instance_name}')/Databases('{database_name}')/tm1s.Backup\"\n    payload = {\"URL\": f\"{backup_set_name}.tgz\"}\n    response = requests.post(url=url, json=payload, auth=self._auth_header)\n    return response\n</code></pre>"},{"location":"reference/services/manageservice/#TM1py.Services.ManageService.ManageService.create_instance","title":"<code>create_instance(instance_name)</code>","text":"Source code in <code>TM1py/Services/ManageService.py</code> <pre><code>def create_instance(self, instance_name):\n    url = f\"{self._root_url}/Instances\"\n    payload = {\"Name\": instance_name}\n    response = requests.post(url=url, json=payload, auth=self._auth_header)\n    return response\n</code></pre>"},{"location":"reference/services/manageservice/#TM1py.Services.ManageService.ManageService.database_exists","title":"<code>database_exists(instance_name, database_name)</code>","text":"Source code in <code>TM1py/Services/ManageService.py</code> <pre><code>def database_exists(self, instance_name, database_name):\n    url = f\"{self._root_url}/Instances('{instance_name}')/Databases('{database_name}')\"\n    response = requests.get(url=url, auth=self._auth_header)\n    if response.ok:\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"reference/services/manageservice/#TM1py.Services.ManageService.ManageService.delete_database","title":"<code>delete_database(instance_name, database_name)</code>","text":"Source code in <code>TM1py/Services/ManageService.py</code> <pre><code>def delete_database(self, instance_name, database_name):\n    url = f\"{self._root_url}/Instances('{instance_name}')/Databases('{database_name}')\"\n    response = requests.delete(url=url, auth=self._auth_header)\n    return response\n</code></pre>"},{"location":"reference/services/manageservice/#TM1py.Services.ManageService.ManageService.delete_instance","title":"<code>delete_instance(instance_name)</code>","text":"Source code in <code>TM1py/Services/ManageService.py</code> <pre><code>def delete_instance(self, instance_name):\n    url = f\"{self._root_url}/Instances('{instance_name}')\"\n    response = requests.delete(url=url, auth=self._auth_header)\n    return response\n</code></pre>"},{"location":"reference/services/manageservice/#TM1py.Services.ManageService.ManageService.get_application","title":"<code>get_application(instance_name, application_name)</code>","text":"Source code in <code>TM1py/Services/ManageService.py</code> <pre><code>def get_application(self, instance_name, application_name):\n    url = f\"{self._root_url}/Instances('{instance_name}')/Applications('{application_name}')\"\n    response = requests.get(url=url, auth=self._auth_header)\n    return json.loads(response.content)\n</code></pre>"},{"location":"reference/services/manageservice/#TM1py.Services.ManageService.ManageService.get_applications","title":"<code>get_applications(instance_name)</code>","text":"Source code in <code>TM1py/Services/ManageService.py</code> <pre><code>def get_applications(self, instance_name):\n    url = f\"{self._root_url}/Instances('{instance_name}')/Applications\"\n    response = requests.get(url=url, auth=self._auth_header)\n    return json.loads(response.content)\n</code></pre>"},{"location":"reference/services/manageservice/#TM1py.Services.ManageService.ManageService.get_database","title":"<code>get_database(instance_name, database_name)</code>","text":"Source code in <code>TM1py/Services/ManageService.py</code> <pre><code>def get_database(self, instance_name, database_name):\n    url = f\"{self._root_url}/Instances('{instance_name}')/Databases('{database_name}')\"\n    response = requests.get(url=url, auth=self._auth_header)\n    return json.loads(response.content)\n</code></pre>"},{"location":"reference/services/manageservice/#TM1py.Services.ManageService.ManageService.get_databases","title":"<code>get_databases(instance_name)</code>","text":"Source code in <code>TM1py/Services/ManageService.py</code> <pre><code>def get_databases(self, instance_name):\n    url = f\"{self._root_url}/Instances('{instance_name}')/Databases\"\n    response = requests.get(url=url, auth=self._auth_header)\n    return json.loads(response.content).get(\"value\")\n</code></pre>"},{"location":"reference/services/manageservice/#TM1py.Services.ManageService.ManageService.get_instance","title":"<code>get_instance(instance_name)</code>","text":"Source code in <code>TM1py/Services/ManageService.py</code> <pre><code>def get_instance(self, instance_name):\n    url = f\"{self._root_url}/Instances('{instance_name}')\"\n    response = requests.get(url=url, auth=self._auth_header)\n    return json.loads(response.content)\n</code></pre>"},{"location":"reference/services/manageservice/#TM1py.Services.ManageService.ManageService.get_instances","title":"<code>get_instances()</code>","text":"Source code in <code>TM1py/Services/ManageService.py</code> <pre><code>def get_instances(self):\n    url = f\"{self._root_url}/Instances\"\n    response = requests.get(url=url, auth=self._auth_header)\n    return json.loads(response.content).get(\"value\")\n</code></pre>"},{"location":"reference/services/manageservice/#TM1py.Services.ManageService.ManageService.get_metadata","title":"<code>get_metadata()</code>","text":"Source code in <code>TM1py/Services/ManageService.py</code> <pre><code>def get_metadata(self):\n    url = f\"{self._root_url}/$metadata?$format=json\"\n    response = requests.get(url=url, auth=self._auth_header)\n    return json.loads(response.content)\n</code></pre>"},{"location":"reference/services/manageservice/#TM1py.Services.ManageService.ManageService.instance_exists","title":"<code>instance_exists(instance_name)</code>","text":"Source code in <code>TM1py/Services/ManageService.py</code> <pre><code>def instance_exists(self, instance_name):\n    url = f\"{self._root_url}/Instances('{instance_name}')\"\n    response = requests.get(url=url, auth=self._auth_header)\n    if response.ok:\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"reference/services/manageservice/#TM1py.Services.ManageService.ManageService.restore_database","title":"<code>restore_database(instance_name, database_name, backup_url)</code>","text":"Source code in <code>TM1py/Services/ManageService.py</code> <pre><code>def restore_database(self, instance_name: str, database_name: str, backup_url: str):\n    url = f\"{self._root_url}/Instances('{instance_name}')/Databases('{database_name}')/tm1s.Restore\"\n    payload = {\"URL\": backup_url}\n    response = requests.post(url=url, json=payload, auth=self._auth_header)\n    return response\n</code></pre>"},{"location":"reference/services/manageservice/#TM1py.Services.ManageService.ManageService.scale_database","title":"<code>scale_database(instance_name, database_name, replicas)</code>","text":"Source code in <code>TM1py/Services/ManageService.py</code> <pre><code>def scale_database(self, instance_name: str, database_name: str, replicas: int):\n    url = f\"{self._root_url}/Instances('{instance_name}')/Databases('{database_name}')\"\n    payload = {\"Replicas\": replicas}\n    response = requests.patch(url=url, json=payload, auth=self._auth_header)\n    return response\n</code></pre>"},{"location":"reference/services/manageservice/#TM1py.Services.ManageService.ManageService.subscribe_to_data_changes","title":"<code>subscribe_to_data_changes(instance_name, database_name, target_url, additional_properties={})</code>","text":"Source code in <code>TM1py/Services/ManageService.py</code> <pre><code>def subscribe_to_data_changes(self, instance_name, database_name, target_url, additional_properties: dict = {}):\n    url = f\"{self._root_url}/Instances('{instance_name}')/Databases('{database_name}')/tm1.Subscribe\"\n    payload = {\"URL\": target_url, \"AdditionalProperties\": additional_properties}\n    response = requests.post(url=url, json=payload, auth=self._auth_header)\n    return response\n</code></pre>"},{"location":"reference/services/manageservice/#TM1py.Services.ManageService.ManageService.unsubscribe_from_data_changes","title":"<code>unsubscribe_from_data_changes(instance_name, database_name, target_url)</code>","text":"Source code in <code>TM1py/Services/ManageService.py</code> <pre><code>def unsubscribe_from_data_changes(self, instance_name, database_name, target_url):\n    url = f\"{self._root_url}/Instances('{instance_name}')/Databases('{database_name}')/tm1.Unsubscribe\"\n    response = requests.post(url=url, auth=self._auth_header)\n    return response\n</code></pre>"},{"location":"reference/services/manageservice/#TM1py.Services.ManageService.ManageService.update_database_cpu","title":"<code>update_database_cpu(instance_name, database_name, cpu_requests, cpu_limits)</code>","text":"Source code in <code>TM1py/Services/ManageService.py</code> <pre><code>def update_database_cpu(\n    self,\n    instance_name,\n    database_name,\n    cpu_requests,\n    cpu_limits,\n):\n    url = f\"{self._root_url}/Instances('{instance_name}')/Databases('{database_name}')\"\n\n    payload = {\n        \"Resources\": {\n            \"Replica\": {\n                \"CPU\": {\"Requests\": cpu_requests, \"Limits\": cpu_limits},\n            }\n        }\n    }\n    response = requests.patch(url=url, json=payload, auth=self._auth_header)\n    return response\n</code></pre>"},{"location":"reference/services/manageservice/#TM1py.Services.ManageService.ManageService.update_database_memory","title":"<code>update_database_memory(instance_name, database_name, memory_requests, memory_limits)</code>","text":"Source code in <code>TM1py/Services/ManageService.py</code> <pre><code>def update_database_memory(\n    self,\n    instance_name,\n    database_name,\n    memory_requests,\n    memory_limits,\n):\n    url = f\"{self._root_url}/Instances('{instance_name}')/Databases('{database_name}')\"\n\n    payload = {\"Resources\": {\"Replica\": {\"Memory\": {\"Requests\": memory_requests, \"Limits\": memory_limits}}}}\n    response = requests.patch(url=url, json=payload, auth=self._auth_header)\n    return response\n</code></pre>"},{"location":"reference/services/manageservice/#TM1py.Services.ManageService.ManageService.update_database_storage","title":"<code>update_database_storage(instance_name, database_name, storage_size)</code>","text":"Source code in <code>TM1py/Services/ManageService.py</code> <pre><code>def update_database_storage(self, instance_name, database_name, storage_size):\n    url = f\"{self._root_url}/Instances('{instance_name}')/Databases('{database_name}')\"\n\n    payload = {\"Resources\": {\"Storage\": {\"Size\": storage_size}}}\n    response = requests.patch(url=url, json=payload, auth=self._auth_header)\n    return response\n</code></pre>"},{"location":"reference/services/manageservice/#TM1py.Services.ManageService.ManageService.upgrade_database","title":"<code>upgrade_database(instance_name, database_name, target_version='')</code>","text":"Source code in <code>TM1py/Services/ManageService.py</code> <pre><code>def upgrade_database(self, instance_name: str, database_name: str, target_version: str = \"\"):\n    url = f\"{self._root_url}/Instances('{instance_name}')/Databases('{database_name}')/tm1s.Upgrade\"\n    payload = {\"ProductVersion\": target_version}\n    response = requests.post(url=url, json=payload, auth=self._auth_header)\n    return response\n</code></pre>"},{"location":"reference/services/messagelogservice/","title":"MessageLogService","text":""},{"location":"reference/services/messagelogservice/#TM1py.Services.MessageLogService.MessageLogService","title":"<code>MessageLogService(rest)</code>","text":"<p>               Bases: <code>ObjectService</code></p> Source code in <code>TM1py/Services/MessageLogService.py</code> <pre><code>def __init__(self, rest: RestService):\n    super().__init__(rest)\n    if verify_version(required_version=\"12.0.0\", version=rest.version):\n        # warn only due to use in Monitoring Service\n        warn(\"Message Logs are not available in this version of TM1, removed as of 12.0.0\", DeprecationWarning, 2)\n    self.last_delta_request = None\n</code></pre>"},{"location":"reference/services/messagelogservice/#TM1py.Services.MessageLogService.MessageLogService.last_delta_request","title":"<code>last_delta_request = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/services/messagelogservice/#TM1py.Services.MessageLogService.MessageLogService.create_entry","title":"<code>create_entry(level, message, **kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>level</code> <code>str</code> <p>string, FATAL, ERROR, WARN, INFO, DEBUG</p> required <code>message</code> <code>str</code> <p>string</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>TM1py/Services/MessageLogService.py</code> <pre><code>@require_data_admin\ndef create_entry(self, level: str, message: str, **kwargs) -&gt; None:\n    \"\"\"\n    :param level: string, FATAL, ERROR, WARN, INFO, DEBUG\n    :param message: string\n    :return:\n    \"\"\"\n\n    valid_levels = CaseAndSpaceInsensitiveSet({\"FATAL\", \"ERROR\", \"WARN\", \"INFO\", \"DEBUG\"})\n    if level not in valid_levels:\n        raise ValueError(f\"Invalid level: '{level}'\")\n\n    from TM1py.Services import ProcessService\n\n    process_service = ProcessService(self._rest)\n    process = Process(name=\"\", prolog_procedure=\"LogOutput('{}', '{}');\".format(level, message))\n    success, status, _ = process_service.execute_process_with_return(process, **kwargs)\n\n    if not success:\n        raise RuntimeError(f\"Failed to write to TM1 Message Log through unbound process. Status: '{status}'\")\n</code></pre>"},{"location":"reference/services/messagelogservice/#TM1py.Services.MessageLogService.MessageLogService.execute_delta_request","title":"<code>execute_delta_request(**kwargs)</code>","text":"Source code in <code>TM1py/Services/MessageLogService.py</code> <pre><code>@deprecated_in_version(version=\"12.0.0\")\n@odata_track_changes_header\ndef execute_delta_request(self, **kwargs) -&gt; Dict:\n    response = self._rest.GET(url=\"/\" + self.last_delta_request, **kwargs)\n    self.last_delta_request = response.text[response.text.rfind(\"MessageLogEntries/!delta('\") : -2]\n    return response.json()[\"value\"]\n</code></pre>"},{"location":"reference/services/messagelogservice/#TM1py.Services.MessageLogService.MessageLogService.get_entries","title":"<code>get_entries(reverse=True, since=None, until=None, top=None, logger=None, level=None, msg_contains=None, msg_contains_operator='and', **kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>reverse</code> <code>bool</code> <p>Boolean</p> <code>True</code> <code>since</code> <code>datetime</code> <p>of type datetime. If it doesn't have tz information, UTC is assumed.</p> <code>None</code> <code>until</code> <code>datetime</code> <p>of type datetime. If it doesn't have tz information, UTC is assumed.</p> <code>None</code> <code>top</code> <code>int</code> <p>Integer</p> <code>None</code> <code>logger</code> <code>str</code> <p>string, eg TM1.Server, TM1.Chore, TM1.Mdx.Interface, TM1.Process</p> <code>None</code> <code>level</code> <code>str</code> <p>string, ERROR, WARNING, INFO, DEBUG, UNKNOWN</p> <code>None</code> <code>msg_contains</code> <code>Iterable</code> <p>iterable, find substring in log message; list of substrings will be queried as AND statement</p> <code>None</code> <code>msg_contains_operator</code> <code>str</code> <p>'and' or 'or'</p> <code>'and'</code> <code>kwargs</code> <code>{}</code> <p>Returns:</p> Type Description <code>Dict</code> <p>Dict of server log</p> Source code in <code>TM1py/Services/MessageLogService.py</code> <pre><code>@deprecated_in_version(version=\"12.0.0\")\n@require_ops_admin\ndef get_entries(\n    self,\n    reverse: bool = True,\n    since: datetime = None,\n    until: datetime = None,\n    top: int = None,\n    logger: str = None,\n    level: str = None,\n    msg_contains: Iterable = None,\n    msg_contains_operator: str = \"and\",\n    **kwargs,\n) -&gt; Dict:\n    \"\"\"\n    :param reverse: Boolean\n    :param since: of type datetime. If it doesn't have tz information, UTC is assumed.\n    :param until: of type datetime. If it doesn't have tz information, UTC is assumed.\n    :param top: Integer\n    :param logger: string, eg TM1.Server, TM1.Chore, TM1.Mdx.Interface, TM1.Process\n    :param level: string, ERROR, WARNING, INFO, DEBUG, UNKNOWN\n    :param msg_contains: iterable, find substring in log message; list of substrings will be queried as AND statement\n    :param msg_contains_operator: 'and' or 'or'\n\n    :param kwargs:\n    :return: Dict of server log\n    \"\"\"\n    msg_contains_operator = msg_contains_operator.strip().lower()\n    if msg_contains_operator not in (\"and\", \"or\"):\n        raise ValueError(\"'msg_contains_operator' must be either 'AND' or 'OR'\")\n\n    reverse = \"desc\" if reverse else \"asc\"\n    url = \"/MessageLogEntries?$orderby=TimeStamp {}\".format(reverse)\n\n    if since or until or logger or level or msg_contains:\n        log_filters = []\n\n        if since:\n            # If since doesn't have tz information, UTC is assumed\n            if not since.tzinfo:\n                since = utc_localize_time(since)\n            log_filters.append(format_url(\"TimeStamp ge {}\", since.strftime(\"%Y-%m-%dT%H:%M:%SZ\")))\n\n        if until:\n            # If until doesn't have tz information, UTC is assumed\n            if not until.tzinfo:\n                until = utc_localize_time(until)\n            log_filters.append(format_url(\"TimeStamp le {}\", until.strftime(\"%Y-%m-%dT%H:%M:%SZ\")))\n\n        if logger:\n            log_filters.append(format_url(\"Logger eq '{}'\", logger))\n\n        if level:\n            level_dict = CaseAndSpaceInsensitiveDict(\n                {\"ERROR\": 1, \"WARNING\": 2, \"INFO\": 3, \"DEBUG\": 4, \"UNKNOWN\": 5}\n            )\n            level_index = level_dict.get(level)\n            if level_index:\n                log_filters.append(\"Level eq {}\".format(level_index))\n\n        if msg_contains:\n            if isinstance(msg_contains, str):\n                log_filters.append(format_url(\"contains(toupper(Message),toupper('{}'))\", msg_contains))\n            else:\n                msg_filters = [\n                    format_url(\"contains(toupper(Message),toupper('{}'))\", wildcard) for wildcard in msg_contains\n                ]\n                log_filters.append(\"({})\".format(f\" {msg_contains_operator} \".join(msg_filters)))\n\n        url += \"&amp;$filter={}\".format(\" and \".join(log_filters))\n\n    if top:\n        url += \"&amp;$top={}\".format(top)\n\n    response = self._rest.GET(url, **kwargs)\n    return response.json()[\"value\"]\n</code></pre>"},{"location":"reference/services/messagelogservice/#TM1py.Services.MessageLogService.MessageLogService.get_last_process_message","title":"<code>get_last_process_message(process_name, **kwargs)</code>","text":"<p>Get the latest message log entry for a process</p> <p>Parameters:</p> Name Type Description Default <code>process_name</code> <code>str</code> <p>name of the process</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>String - the message, for instance: \"Ausf\u00fchrung normal beendet, verstrichene Zeit 0.03  Sekunden\"</p> Source code in <code>TM1py/Services/MessageLogService.py</code> <pre><code>@require_ops_admin\n@deprecated_in_version(version=\"12.0.0\")\ndef get_last_process_message(self, process_name: str, **kwargs) -&gt; Optional[str]:\n    \"\"\"Get the latest message log entry for a process\n\n    :param process_name: name of the process\n    :return: String - the message, for instance: \"Ausf\u00fchrung normal beendet, verstrichene Zeit 0.03  Sekunden\"\n    \"\"\"\n    url = format_url(\n        \"/MessageLog()?$orderby='TimeStamp'&amp;$filter=Logger eq 'TM1.Process' and contains(Message, '{}')\",\n        process_name,\n    )\n    response = self._rest.GET(url=url, **kwargs)\n    response_as_list = response.json()[\"value\"]\n    if len(response_as_list) &gt; 0:\n        message_log_entry = response_as_list[0]\n        return message_log_entry[\"Message\"]\n</code></pre>"},{"location":"reference/services/messagelogservice/#TM1py.Services.MessageLogService.MessageLogService.initialize_delta_requests","title":"<code>initialize_delta_requests(filter=None, **kwargs)</code>","text":"Source code in <code>TM1py/Services/MessageLogService.py</code> <pre><code>@deprecated_in_version(version=\"12.0.0\")\n@odata_track_changes_header\ndef initialize_delta_requests(self, filter=None, **kwargs):\n    url = \"/TailMessageLog()\"\n    if filter:\n        url += \"?$filter={}\".format(filter)\n    response = self._rest.GET(url=url, **kwargs)\n    # Read the next delta-request-url from the response\n    self.last_delta_request = response.text[response.text.rfind(\"MessageLogEntries/!delta('\") : -2]\n</code></pre>"},{"location":"reference/services/monitoringservice/","title":"MonitoringService","text":""},{"location":"reference/services/monitoringservice/#TM1py.Services.MonitoringService.MonitoringService","title":"<code>MonitoringService(rest)</code>","text":"<p>               Bases: <code>ObjectService</code></p> <p>Service to Query and Cancel Threads in TM1</p> Source code in <code>TM1py/Services/MonitoringService.py</code> <pre><code>def __init__(self, rest: RestService):\n    super().__init__(rest)\n    warn(\"Monitoring Service will be moved to a new location in a future version\", DeprecationWarning, 2)\n    self.users = UserService(rest)\n    self.threads = ThreadService(rest)\n    self.session = SessionService(rest)\n</code></pre>"},{"location":"reference/services/monitoringservice/#TM1py.Services.MonitoringService.MonitoringService.session","title":"<code>session = SessionService(rest)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/services/monitoringservice/#TM1py.Services.MonitoringService.MonitoringService.threads","title":"<code>threads = ThreadService(rest)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/services/monitoringservice/#TM1py.Services.MonitoringService.MonitoringService.users","title":"<code>users = UserService(rest)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/services/monitoringservice/#TM1py.Services.MonitoringService.MonitoringService.cancel_all_running_threads","title":"<code>cancel_all_running_threads(**kwargs)</code>","text":"Source code in <code>TM1py/Services/MonitoringService.py</code> <pre><code>def cancel_all_running_threads(self, **kwargs) -&gt; list:\n    return self.threads.cancel_all_running(**kwargs)\n</code></pre>"},{"location":"reference/services/monitoringservice/#TM1py.Services.MonitoringService.MonitoringService.cancel_thread","title":"<code>cancel_thread(thread_id, **kwargs)</code>","text":"<p>Kill a running thread</p> <p>Parameters:</p> Name Type Description Default <code>thread_id</code> <code>int</code> required <p>Returns:</p> Type Description <code>Response</code> Source code in <code>TM1py/Services/MonitoringService.py</code> <pre><code>def cancel_thread(self, thread_id: int, **kwargs) -&gt; Response:\n    \"\"\"Kill a running thread\n\n    :param thread_id:\n    :return:\n    \"\"\"\n    return self.threads.cancel(thread_id, **kwargs)\n</code></pre>"},{"location":"reference/services/monitoringservice/#TM1py.Services.MonitoringService.MonitoringService.close_all_sessions","title":"<code>close_all_sessions(**kwargs)</code>","text":"Source code in <code>TM1py/Services/MonitoringService.py</code> <pre><code>@require_admin\ndef close_all_sessions(self, **kwargs) -&gt; list:\n    return self.session.close_all(**kwargs)\n</code></pre>"},{"location":"reference/services/monitoringservice/#TM1py.Services.MonitoringService.MonitoringService.close_session","title":"<code>close_session(session_id, **kwargs)</code>","text":"Source code in <code>TM1py/Services/MonitoringService.py</code> <pre><code>def close_session(self, session_id, **kwargs) -&gt; Response:\n    return self.session.close(session_id, **kwargs)\n</code></pre>"},{"location":"reference/services/monitoringservice/#TM1py.Services.MonitoringService.MonitoringService.disconnect_all_users","title":"<code>disconnect_all_users(**kwargs)</code>","text":"Source code in <code>TM1py/Services/MonitoringService.py</code> <pre><code>@require_admin\ndef disconnect_all_users(self, **kwargs) -&gt; list:\n    return self.users.disconnect_all(**kwargs)\n</code></pre>"},{"location":"reference/services/monitoringservice/#TM1py.Services.MonitoringService.MonitoringService.disconnect_user","title":"<code>disconnect_user(user_name, **kwargs)</code>","text":"<p>Disconnect User</p> <p>Parameters:</p> Name Type Description Default <code>user_name</code> <code>str</code> required <p>Returns:</p> Type Description <code>Response</code> Source code in <code>TM1py/Services/MonitoringService.py</code> <pre><code>def disconnect_user(self, user_name: str, **kwargs) -&gt; Response:\n    \"\"\"Disconnect User\n\n    :param user_name:\n    :return:\n    \"\"\"\n    return self.users.disconnect(user_name, **kwargs)\n</code></pre>"},{"location":"reference/services/monitoringservice/#TM1py.Services.MonitoringService.MonitoringService.get_active_session_threads","title":"<code>get_active_session_threads(exclude_idle=True, **kwargs)</code>","text":"Source code in <code>TM1py/Services/MonitoringService.py</code> <pre><code>def get_active_session_threads(self, exclude_idle: bool = True, **kwargs):\n    return self.session.get_threads_for_current(exclude_idle, **kwargs)\n</code></pre>"},{"location":"reference/services/monitoringservice/#TM1py.Services.MonitoringService.MonitoringService.get_active_threads","title":"<code>get_active_threads(**kwargs)</code>","text":"<p>Return a list of non-idle threads from the TM1 Server</p> <p>Returns:</p> Type Description <p>list: TM1 threads as dict</p> Source code in <code>TM1py/Services/MonitoringService.py</code> <pre><code>def get_active_threads(self, **kwargs):\n    \"\"\"Return a list of non-idle threads from the TM1 Server\n\n    :return:\n        list: TM1 threads as dict\n    \"\"\"\n    return self.threads.get_active(**kwargs)\n</code></pre>"},{"location":"reference/services/monitoringservice/#TM1py.Services.MonitoringService.MonitoringService.get_active_users","title":"<code>get_active_users(**kwargs)</code>","text":"<p>Get the activate users in TM1</p> <p>Returns:</p> Type Description <code>List[User]</code> <p>List of TM1py.User instances</p> Source code in <code>TM1py/Services/MonitoringService.py</code> <pre><code>def get_active_users(self, **kwargs) -&gt; List[User]:\n    \"\"\"Get the activate users in TM1\n\n    :return: List of TM1py.User instances\n    \"\"\"\n    return self.users.get_active(**kwargs)\n</code></pre>"},{"location":"reference/services/monitoringservice/#TM1py.Services.MonitoringService.MonitoringService.get_current_user","title":"<code>get_current_user(**kwargs)</code>","text":"Source code in <code>TM1py/Services/MonitoringService.py</code> <pre><code>def get_current_user(self, **kwargs):\n    return self.users.get_current(**kwargs)\n</code></pre>"},{"location":"reference/services/monitoringservice/#TM1py.Services.MonitoringService.MonitoringService.get_sessions","title":"<code>get_sessions(include_user=True, include_threads=True, **kwargs)</code>","text":"Source code in <code>TM1py/Services/MonitoringService.py</code> <pre><code>def get_sessions(self, include_user: bool = True, include_threads: bool = True, **kwargs) -&gt; List:\n    return self.session.get_all(include_user, include_threads, **kwargs)\n</code></pre>"},{"location":"reference/services/monitoringservice/#TM1py.Services.MonitoringService.MonitoringService.get_threads","title":"<code>get_threads(**kwargs)</code>","text":"<p>Return a dict of the currently running threads from the TM1 Server</p> <p>Returns:</p> Type Description <code>List</code> <p>dict: the response</p> Source code in <code>TM1py/Services/MonitoringService.py</code> <pre><code>def get_threads(self, **kwargs) -&gt; List:\n    \"\"\"Return a dict of the currently running threads from the TM1 Server\n\n    :return:\n        dict: the response\n    \"\"\"\n    return self.threads.get_all(**kwargs)\n</code></pre>"},{"location":"reference/services/monitoringservice/#TM1py.Services.MonitoringService.MonitoringService.user_is_active","title":"<code>user_is_active(user_name, **kwargs)</code>","text":"<p>Check if user is currently active in TM1</p> <p>Parameters:</p> Name Type Description Default <code>user_name</code> <code>str</code> required <p>Returns:</p> Type Description <code>bool</code> <p>Boolean</p> Source code in <code>TM1py/Services/MonitoringService.py</code> <pre><code>def user_is_active(self, user_name: str, **kwargs) -&gt; bool:\n    \"\"\"Check if user is currently active in TM1\n\n    :param user_name:\n    :return: Boolean\n    \"\"\"\n    return self.users.is_active(user_name, **kwargs)\n</code></pre>"},{"location":"reference/services/objectservice/","title":"ObjectService","text":""},{"location":"reference/services/objectservice/#TM1py.Services.ObjectService.ObjectService","title":"<code>ObjectService(rest_service)</code>","text":"<p>Parent class for all Object Services</p> <p>Constructor, Create an instance of ObjectService</p> <p>Parameters:</p> Name Type Description Default <code>rest_service</code> <code>RestService</code> required Source code in <code>TM1py/Services/ObjectService.py</code> <pre><code>def __init__(self, rest_service: RestService):\n    \"\"\"Constructor, Create an instance of ObjectService\n\n    :param rest_service:\n    \"\"\"\n    self._rest = rest_service\n    if verify_version(\"12\", self.version):\n        self.binary_http_header = self.BINARY_HTTP_HEADER\n    else:\n        self.binary_http_header = self.BINARY_HTTP_HEADER_PRE_V12\n</code></pre>"},{"location":"reference/services/objectservice/#TM1py.Services.ObjectService.ObjectService.BINARY_HTTP_HEADER","title":"<code>BINARY_HTTP_HEADER = {'Content-Type': 'application/json;charset=UTF-8'}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/services/objectservice/#TM1py.Services.ObjectService.ObjectService.BINARY_HTTP_HEADER_PRE_V12","title":"<code>BINARY_HTTP_HEADER_PRE_V12 = {'Content-Type': 'application/octet-stream; odata.streaming=true'}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/services/objectservice/#TM1py.Services.ObjectService.ObjectService.ELEMENT_ATTRIBUTES_PREFIX","title":"<code>ELEMENT_ATTRIBUTES_PREFIX = '}ElementAttributes_'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/services/objectservice/#TM1py.Services.ObjectService.ObjectService.SANDBOX_DIMENSION","title":"<code>SANDBOX_DIMENSION = 'Sandboxes'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/services/objectservice/#TM1py.Services.ObjectService.ObjectService.binary_http_header","title":"<code>binary_http_header = self.BINARY_HTTP_HEADER</code>  <code>instance-attribute</code>","text":""},{"location":"reference/services/objectservice/#TM1py.Services.ObjectService.ObjectService.is_admin","title":"<code>is_admin</code>  <code>property</code>","text":""},{"location":"reference/services/objectservice/#TM1py.Services.ObjectService.ObjectService.is_data_admin","title":"<code>is_data_admin</code>  <code>property</code>","text":""},{"location":"reference/services/objectservice/#TM1py.Services.ObjectService.ObjectService.is_ops_admin","title":"<code>is_ops_admin</code>  <code>property</code>","text":""},{"location":"reference/services/objectservice/#TM1py.Services.ObjectService.ObjectService.is_security_admin","title":"<code>is_security_admin</code>  <code>property</code>","text":""},{"location":"reference/services/objectservice/#TM1py.Services.ObjectService.ObjectService.version","title":"<code>version</code>  <code>property</code>","text":""},{"location":"reference/services/objectservice/#TM1py.Services.ObjectService.ObjectService.determine_actual_object_name","title":"<code>determine_actual_object_name(object_class, object_name, **kwargs)</code>","text":"Source code in <code>TM1py/Services/ObjectService.py</code> <pre><code>def determine_actual_object_name(self, object_class: str, object_name: str, **kwargs) -&gt; str:\n    url = format_url(\n        \"/{}?$filter=tolower(replace(Name, ' ', '')) eq '{}'\", object_class, object_name.replace(\" \", \"\").lower()\n    )\n    response = self._rest.GET(url, **kwargs)\n\n    if len(response.json()[\"value\"]) == 0:\n        raise ValueError(\"Object '{}' of type '{}' doesn't exist\".format(object_name, object_class))\n\n    return response.json()[\"value\"][0][\"Name\"]\n</code></pre>"},{"location":"reference/services/objectservice/#TM1py.Services.ObjectService.ObjectService.suggest_unique_object_name","title":"<code>suggest_unique_object_name(random_seed=None)</code>","text":"<p>Generate hash based on tm1-session-id, local-thread-id and random id to guarantee unique name avoids name conflicts in multithreading operations</p> Source code in <code>TM1py/Services/ObjectService.py</code> <pre><code>def suggest_unique_object_name(self, random_seed: float = None) -&gt; str:\n    \"\"\"\n    Generate hash based on tm1-session-id, local-thread-id and random id to guarantee unique name\n    avoids name conflicts in multithreading operations\n    \"\"\"\n    if not random_seed:\n        random_seed = random.random()\n    unique_string = f\"{self._rest.session_id}{threading.get_ident()}{random_seed}\"\n    unique_hash = \"tm1py.\" + hashlib.sha256(unique_string.encode(\"utf-8\")).hexdigest()[:12]\n    return unique_hash\n</code></pre>"},{"location":"reference/services/powerbiservice/","title":"PowerBiService","text":""},{"location":"reference/services/powerbiservice/#TM1py.Services.PowerBiService.PowerBiService","title":"<code>PowerBiService(tm1_rest)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>tm1_rest</code> <p>instance of RestService</p> required Source code in <code>TM1py/Services/PowerBiService.py</code> <pre><code>def __init__(self, tm1_rest):\n    \"\"\"\n\n    :param tm1_rest: instance of RestService\n    \"\"\"\n    self._tm1_rest = tm1_rest\n    self.cells = CellService(tm1_rest)\n    self.elements = ElementService(tm1_rest)\n</code></pre>"},{"location":"reference/services/powerbiservice/#TM1py.Services.PowerBiService.PowerBiService.cells","title":"<code>cells = CellService(tm1_rest)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/services/powerbiservice/#TM1py.Services.PowerBiService.PowerBiService.elements","title":"<code>elements = ElementService(tm1_rest)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/services/powerbiservice/#TM1py.Services.PowerBiService.PowerBiService.execute_mdx","title":"<code>execute_mdx(mdx, **kwargs)</code>","text":"Source code in <code>TM1py/Services/PowerBiService.py</code> <pre><code>@require_pandas\ndef execute_mdx(self, mdx, **kwargs) -&gt; \"pd.DataFrame\":\n    return self.cells.execute_mdx_dataframe_shaped(mdx, **kwargs)\n</code></pre>"},{"location":"reference/services/powerbiservice/#TM1py.Services.PowerBiService.PowerBiService.execute_view","title":"<code>execute_view(cube_name, view_name, private, use_iterative_json=False, use_blob=False, **kwargs)</code>","text":"Source code in <code>TM1py/Services/PowerBiService.py</code> <pre><code>@require_pandas\ndef execute_view(\n    self, cube_name: str, view_name: str, private: bool, use_iterative_json=False, use_blob=False, **kwargs\n) -&gt; \"pd.DataFrame\":\n    return self.cells.execute_view_dataframe_shaped(\n        cube_name, view_name, private, use_iterative_json=use_iterative_json, use_blob=use_blob, **kwargs\n    )\n</code></pre>"},{"location":"reference/services/powerbiservice/#TM1py.Services.PowerBiService.PowerBiService.get_member_properties","title":"<code>get_member_properties(dimension_name=None, hierarchy_name=None, member_selection=None, skip_consolidations=True, attributes=None, skip_parents=False, level_names=None, parent_attribute=None, skip_weights=True, use_blob=False, **kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>dimension_name</code> <code>str</code> <p>Name of the dimension</p> <code>None</code> <code>hierarchy_name</code> <code>str</code> <p>Name of the hierarchy in the dimension</p> <code>None</code> <code>member_selection</code> <code>Iterable</code> <p>Selection of members. Iterable or valid MDX string</p> <code>None</code> <code>skip_consolidations</code> <code>bool</code> <p>Boolean flag to skip consolidations</p> <code>True</code> <code>attributes</code> <code>Iterable</code> <p>Selection of attributes. Iterable. If None retrieve all.</p> <code>None</code> <code>level_names</code> <p>List of labels for parent columns. If None use level names from TM1.</p> <code>None</code> <code>skip_parents</code> <code>bool</code> <p>Boolean Flag to skip parent columns.</p> <code>False</code> <code>parent_attribute</code> <code>str</code> <p>Attribute to be displayed in parent columns. If None, parent name is used.</p> <code>None</code> <code>skip_weights</code> <p>include weight columns</p> <code>True</code> <code>use_blob</code> <p>Better performance on large sets and lower memory footprint in any case. Requires admin permissions</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pandas DataFrame</p> Source code in <code>TM1py/Services/PowerBiService.py</code> <pre><code>@require_pandas\ndef get_member_properties(\n    self,\n    dimension_name: str = None,\n    hierarchy_name: str = None,\n    member_selection: Iterable = None,\n    skip_consolidations: bool = True,\n    attributes: Iterable = None,\n    skip_parents: bool = False,\n    level_names=None,\n    parent_attribute: str = None,\n    skip_weights=True,\n    use_blob=False,\n    **kwargs,\n) -&gt; \"pd.DataFrame\":\n    \"\"\"\n\n    :param dimension_name: Name of the dimension\n    :param hierarchy_name: Name of the hierarchy in the dimension\n    :param member_selection: Selection of members. Iterable or valid MDX string\n    :param skip_consolidations: Boolean flag to skip consolidations\n    :param attributes: Selection of attributes. Iterable. If None retrieve all.\n    :param level_names: List of labels for parent columns. If None use level names from TM1.\n    :param skip_parents: Boolean Flag to skip parent columns.\n    :param parent_attribute: Attribute to be displayed in parent columns. If None, parent name is used.\n    :param skip_weights: include weight columns\n    :param use_blob: Better performance on large sets and lower memory footprint in any case. Requires admin permissions\n\n    :return: pandas DataFrame\n    \"\"\"\n    if not skip_weights and skip_parents:\n        raise ValueError(\"skip_weights must not be False if skip_parents is True\")\n\n    return self.elements.get_elements_dataframe(\n        dimension_name=dimension_name,\n        hierarchy_name=hierarchy_name,\n        elements=member_selection,\n        skip_consolidations=skip_consolidations,\n        attributes=attributes,\n        skip_parents=skip_parents,\n        level_names=level_names,\n        parent_attribute=parent_attribute,\n        skip_weights=skip_weights,\n        use_blob=use_blob,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/services/processservice/","title":"ProcessService","text":""},{"location":"reference/services/processservice/#TM1py.Services.ProcessService.ProcessService","title":"<code>ProcessService(rest)</code>","text":"<p>               Bases: <code>ObjectService</code></p> <p>Service to handle Object Updates for TI Processes</p> Source code in <code>TM1py/Services/ProcessService.py</code> <pre><code>def __init__(self, rest: RestService):\n    super().__init__(rest)\n</code></pre>"},{"location":"reference/services/processservice/#TM1py.Services.ProcessService.ProcessService.compile","title":"<code>compile(name, **kwargs)</code>","text":"<p>Compile a Process. Return List of Syntax errors.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> required <p>Returns:</p> Type Description <code>List</code> Source code in <code>TM1py/Services/ProcessService.py</code> <pre><code>def compile(self, name: str, **kwargs) -&gt; List:\n    \"\"\"Compile a Process. Return List of Syntax errors.\n\n    :param name:\n    :return:\n    \"\"\"\n    url = format_url(\"/Processes('{}')/tm1.Compile\", name)\n    response = self._rest.POST(url, **kwargs)\n    syntax_errors = response.json()[\"value\"]\n    return syntax_errors\n</code></pre>"},{"location":"reference/services/processservice/#TM1py.Services.ProcessService.ProcessService.compile_process","title":"<code>compile_process(process, **kwargs)</code>","text":"<p>Compile a Process. Return List of Syntax errors.</p> <p>Parameters:</p> Name Type Description Default <code>process</code> <code>Process</code> required <p>Returns:</p> Type Description <code>List</code> Source code in <code>TM1py/Services/ProcessService.py</code> <pre><code>def compile_process(self, process: Process, **kwargs) -&gt; List:\n    \"\"\"Compile a Process. Return List of Syntax errors.\n\n    :param process:\n    :return:\n    \"\"\"\n    url = \"/CompileProcess\"\n\n    payload = json.loads('{\"Process\":' + process.body + \"}\")\n\n    response = self._rest.POST(url=url, data=json.dumps(payload, ensure_ascii=False), **kwargs)\n\n    syntax_errors = response.json()[\"value\"]\n    return syntax_errors\n</code></pre>"},{"location":"reference/services/processservice/#TM1py.Services.ProcessService.ProcessService.create","title":"<code>create(process, **kwargs)</code>","text":"<p>Create a new process on TM1 Server</p> <p>Parameters:</p> Name Type Description Default <code>process</code> <code>Process</code> <p>Instance of TM1py.Process class</p> required <p>Returns:</p> Type Description <code>Response</code> <p>Response</p> Source code in <code>TM1py/Services/ProcessService.py</code> <pre><code>def create(self, process: Process, **kwargs) -&gt; Response:\n    \"\"\"Create a new process on TM1 Server\n\n    :param process: Instance of TM1py.Process class\n    :return: Response\n    \"\"\"\n    url = \"/Processes\"\n    # Adjust process body if TM1 version is lower than 11 due to change in Process Parameters structure\n    # https://www.ibm.com/developerworks/community/forums/html/topic?id=9188d139-8905-4895-9229-eaaf0e7fa683\n    if int(self.version[0:2]) &lt; 11:\n        process.drop_parameter_types()\n    response = self._rest.POST(url, process.body, **kwargs)\n    return response\n</code></pre>"},{"location":"reference/services/processservice/#TM1py.Services.ProcessService.ProcessService.debug_add_breakpoint","title":"<code>debug_add_breakpoint(debug_id, break_point, **kwargs)</code>","text":"Source code in <code>TM1py/Services/ProcessService.py</code> <pre><code>def debug_add_breakpoint(self, debug_id: str, break_point: ProcessDebugBreakpoint, **kwargs) -&gt; Response:\n    return self.debug_add_breakpoints(debug_id, [break_point], **kwargs)\n</code></pre>"},{"location":"reference/services/processservice/#TM1py.Services.ProcessService.ProcessService.debug_add_breakpoints","title":"<code>debug_add_breakpoints(debug_id, break_points=None, **kwargs)</code>","text":"Source code in <code>TM1py/Services/ProcessService.py</code> <pre><code>def debug_add_breakpoints(\n    self, debug_id: str, break_points: Iterable[ProcessDebugBreakpoint] = None, **kwargs\n) -&gt; Response:\n    url = format_url(\"/ProcessDebugContexts('{}')/Breakpoints\", debug_id)\n\n    body = json.dumps([break_point.body_as_dict for break_point in break_points])\n\n    response = self._rest.POST(url, body, **kwargs)\n    return response\n</code></pre>"},{"location":"reference/services/processservice/#TM1py.Services.ProcessService.ProcessService.debug_continue","title":"<code>debug_continue(debug_id, **kwargs)</code>","text":"<p>Resumes execution until next breakpoint</p> Source code in <code>TM1py/Services/ProcessService.py</code> <pre><code>def debug_continue(self, debug_id: str, **kwargs) -&gt; Dict:\n    \"\"\"\n    Resumes execution until next breakpoint\n\n    \"\"\"\n    url = format_url(\"/ProcessDebugContexts('{}')/tm1.Continue\", debug_id)\n    self._rest.POST(url, **kwargs)\n\n    # digest time  necessary for TM1 &lt;= 11.8\n    # ToDo: remove in later versions of TM1 once issue in TM1 server is resolved\n    time.sleep(0.1)\n\n    raw_url = (\n        \"/ProcessDebugContexts('{}')?$expand=Breakpoints,\"\n        \"Thread,CallStack($expand=Variables,Process($select=Name))\"\n    )\n    url = format_url(raw_url, debug_id)\n    response = self._rest.GET(url, **kwargs)\n\n    return response.json()\n</code></pre>"},{"location":"reference/services/processservice/#TM1py.Services.ProcessService.ProcessService.debug_get_breakpoints","title":"<code>debug_get_breakpoints(debug_id, **kwargs)</code>","text":"Source code in <code>TM1py/Services/ProcessService.py</code> <pre><code>def debug_get_breakpoints(self, debug_id: str, **kwargs) -&gt; List[ProcessDebugBreakpoint]:\n    url = format_url(\"/ProcessDebugContexts('{}')/Breakpoints\", debug_id)\n\n    response = self._rest.GET(url, **kwargs)\n    return [ProcessDebugBreakpoint.from_dict(b) for b in response.json()[\"value\"]]\n</code></pre>"},{"location":"reference/services/processservice/#TM1py.Services.ProcessService.ProcessService.debug_get_current_breakpoint","title":"<code>debug_get_current_breakpoint(debug_id, **kwargs)</code>","text":"Source code in <code>TM1py/Services/ProcessService.py</code> <pre><code>def debug_get_current_breakpoint(self, debug_id: str, **kwargs) -&gt; ProcessDebugBreakpoint:\n    raw_url = \"/ProcessDebugContexts('{}')?$expand=CurrentBreakpoint\"\n\n    url = format_url(raw_url, debug_id)\n\n    response = self._rest.GET(url=url, **kwargs)\n    return ProcessDebugBreakpoint.from_dict(response.json()[\"CurrentBreakpoint\"])\n</code></pre>"},{"location":"reference/services/processservice/#TM1py.Services.ProcessService.ProcessService.debug_get_process_line_number","title":"<code>debug_get_process_line_number(debug_id, **kwargs)</code>","text":"Source code in <code>TM1py/Services/ProcessService.py</code> <pre><code>def debug_get_process_line_number(self, debug_id: str, **kwargs) -&gt; str:\n    raw_url = \"/ProcessDebugContexts('{}')?$expand=\" \"CallStack($select=LineNumber)\"\n    url = format_url(raw_url, debug_id)\n\n    response = self._rest.GET(url, **kwargs)\n    return response.json()[\"CallStack\"][0][\"LineNumber\"]\n</code></pre>"},{"location":"reference/services/processservice/#TM1py.Services.ProcessService.ProcessService.debug_get_process_procedure","title":"<code>debug_get_process_procedure(debug_id, **kwargs)</code>","text":"Source code in <code>TM1py/Services/ProcessService.py</code> <pre><code>def debug_get_process_procedure(self, debug_id: str, **kwargs) -&gt; str:\n    raw_url = \"/ProcessDebugContexts('{}')?$expand=\" \"CallStack($select=Procedure)\"\n    url = format_url(raw_url, debug_id)\n\n    response = self._rest.GET(url, **kwargs)\n    return response.json()[\"CallStack\"][0][\"Procedure\"]\n</code></pre>"},{"location":"reference/services/processservice/#TM1py.Services.ProcessService.ProcessService.debug_get_record_number","title":"<code>debug_get_record_number(debug_id, **kwargs)</code>","text":"Source code in <code>TM1py/Services/ProcessService.py</code> <pre><code>def debug_get_record_number(self, debug_id: str, **kwargs) -&gt; str:\n    raw_url = \"/ProcessDebugContexts('{}')?$expand=\" \"CallStack($select=RecordNumber)\"\n    url = format_url(raw_url, debug_id)\n\n    response = self._rest.GET(url, **kwargs)\n    return response.json()[\"CallStack\"][0][\"RecordNumber\"]\n</code></pre>"},{"location":"reference/services/processservice/#TM1py.Services.ProcessService.ProcessService.debug_get_single_variable_value","title":"<code>debug_get_single_variable_value(debug_id, variable_name, **kwargs)</code>","text":"Source code in <code>TM1py/Services/ProcessService.py</code> <pre><code>def debug_get_single_variable_value(self, debug_id: str, variable_name: str, **kwargs) -&gt; str:\n    raw_url = (\n        \"/ProcessDebugContexts('{}')?$expand=\"\n        \"CallStack($expand=Variables($filter=tolower(Name) eq '{}';$select=Value))\"\n    )\n    url = format_url(raw_url, debug_id, variable_name.lower())\n\n    response = self._rest.GET(url, **kwargs)\n\n    try:\n        return response.json()[\"CallStack\"][0][\"Variables\"][0][\"Value\"]\n    except Exception:\n        raise ValueError(f\"'{variable_name}' not found in collection\")\n</code></pre>"},{"location":"reference/services/processservice/#TM1py.Services.ProcessService.ProcessService.debug_get_variable_values","title":"<code>debug_get_variable_values(debug_id, **kwargs)</code>","text":"Source code in <code>TM1py/Services/ProcessService.py</code> <pre><code>def debug_get_variable_values(self, debug_id: str, **kwargs) -&gt; CaseInsensitiveDict:\n    raw_url = \"/ProcessDebugContexts('{}')?$expand=\" \"CallStack($expand=Variables)\"\n    url = format_url(raw_url, debug_id)\n\n    response = self._rest.GET(url, **kwargs)\n    result = response.json()\n    call_stack = result[\"CallStack\"][0][\"Variables\"] if result[\"CallStack\"] else result[\"CallStack\"]\n\n    return CaseInsensitiveDict({entry[\"Name\"]: entry[\"Value\"] for entry in call_stack})\n</code></pre>"},{"location":"reference/services/processservice/#TM1py.Services.ProcessService.ProcessService.debug_process","title":"<code>debug_process(process_name, timeout=None, **kwargs)</code>","text":"<p>Start debug session for specified process; debug session id is returned in response</p> Source code in <code>TM1py/Services/ProcessService.py</code> <pre><code>def debug_process(self, process_name: str, timeout: float = None, **kwargs) -&gt; Dict:\n    \"\"\"\n    Start debug session for specified process; debug session id is returned in response\n    \"\"\"\n    raw_url = (\n        \"/Processes('{}')/tm1.Debug?$expand=Breakpoints,\"\n        \"Thread,CallStack($expand=Variables,Process($select=Name))\"\n    )\n    url = format_url(raw_url, process_name)\n\n    parameters = dict()\n    if kwargs:\n        parameters = {\"Parameters\": []}\n        for parameter_name, parameter_value in kwargs.items():\n            parameters[\"Parameters\"].append({\"Name\": parameter_name, \"Value\": parameter_value})\n\n    response = self._rest.POST(url, data=json.dumps(parameters, ensure_ascii=False), timeout=timeout, **kwargs)\n    return response.json()\n</code></pre>"},{"location":"reference/services/processservice/#TM1py.Services.ProcessService.ProcessService.debug_remove_breakpoint","title":"<code>debug_remove_breakpoint(debug_id, breakpoint_id, **kwargs)</code>","text":"Source code in <code>TM1py/Services/ProcessService.py</code> <pre><code>def debug_remove_breakpoint(self, debug_id: str, breakpoint_id: int, **kwargs) -&gt; Response:\n    url = format_url(\"/ProcessDebugContexts('{}')/Breakpoints('{}')\", debug_id, str(breakpoint_id))\n\n    response = self._rest.DELETE(url, **kwargs)\n    return response\n</code></pre>"},{"location":"reference/services/processservice/#TM1py.Services.ProcessService.ProcessService.debug_step_in","title":"<code>debug_step_in(debug_id, **kwargs)</code>","text":"<p>Runs a single statement in the process If ExecuteProcess is next function, will pause at first statement inside child process</p> Source code in <code>TM1py/Services/ProcessService.py</code> <pre><code>def debug_step_in(self, debug_id: str, **kwargs) -&gt; Dict:\n    \"\"\"\n    Runs a single statement in the process\n    If ExecuteProcess is next function, will pause at first statement inside child process\n    \"\"\"\n    url = format_url(\"/ProcessDebugContexts('{}')/tm1.StepIn\", debug_id)\n    self._rest.POST(url, **kwargs)\n\n    # digest time  necessary for TM1 &lt;= 11.8\n    # ToDo: remove in later versions of TM1 once issue in TM1 server is resolved\n    time.sleep(0.1)\n\n    raw_url = (\n        \"/ProcessDebugContexts('{}')?$expand=Breakpoints,\"\n        \"Thread,CallStack($expand=Variables,Process($select=Name))\"\n    )\n    url = format_url(raw_url, debug_id)\n    response = self._rest.GET(url, **kwargs)\n\n    return response.json()\n</code></pre>"},{"location":"reference/services/processservice/#TM1py.Services.ProcessService.ProcessService.debug_step_out","title":"<code>debug_step_out(debug_id, **kwargs)</code>","text":"<p>Resumes execution and runs until current process has finished.</p> Source code in <code>TM1py/Services/ProcessService.py</code> <pre><code>def debug_step_out(self, debug_id: str, **kwargs) -&gt; Dict:\n    \"\"\"\n    Resumes execution and runs until current process has finished.\n    \"\"\"\n    url = format_url(\"/ProcessDebugContexts('{}')/tm1.StepOut\", debug_id)\n    self._rest.POST(url, **kwargs)\n\n    # digest time  necessary for TM1 &lt;= 11.8\n    # ToDo: remove in later versions of TM1 once issue in TM1 server is resolved\n    time.sleep(0.1)\n\n    raw_url = (\n        \"/ProcessDebugContexts('{}')?$expand=Breakpoints,\"\n        \"Thread,CallStack($expand=Variables,Process($select=Name))\"\n    )\n    url = format_url(raw_url, debug_id)\n    response = self._rest.GET(url, **kwargs)\n\n    return response.json()\n</code></pre>"},{"location":"reference/services/processservice/#TM1py.Services.ProcessService.ProcessService.debug_step_over","title":"<code>debug_step_over(debug_id, **kwargs)</code>","text":"<p>Runs a single statement in the process If ExecuteProcess is next function, will NOT debug child process</p> Source code in <code>TM1py/Services/ProcessService.py</code> <pre><code>def debug_step_over(self, debug_id: str, **kwargs) -&gt; Dict:\n    \"\"\"\n    Runs a single statement in the process\n    If ExecuteProcess is next function, will NOT debug child process\n    \"\"\"\n    url = format_url(\"/ProcessDebugContexts('{}')/tm1.StepOver\", debug_id)\n    self._rest.POST(url, **kwargs)\n\n    # digest time  necessary for TM1 &lt;= 11.8\n    # ToDo: remove in later versions of TM1 once issue in TM1 server is resolved\n    time.sleep(0.1)\n\n    raw_url = (\n        \"/ProcessDebugContexts('{}')?$expand=Breakpoints,\"\n        \"Thread,CallStack($expand=Variables,Process($select=Name))\"\n    )\n    url = format_url(raw_url, debug_id)\n    response = self._rest.GET(url, **kwargs)\n\n    return response.json()\n</code></pre>"},{"location":"reference/services/processservice/#TM1py.Services.ProcessService.ProcessService.debug_update_breakpoint","title":"<code>debug_update_breakpoint(debug_id, break_point, **kwargs)</code>","text":"Source code in <code>TM1py/Services/ProcessService.py</code> <pre><code>def debug_update_breakpoint(self, debug_id: str, break_point: ProcessDebugBreakpoint, **kwargs) -&gt; Response:\n    url = format_url(\"/ProcessDebugContexts('{}')/Breakpoints('{}')\", debug_id, str(break_point.breakpoint_id))\n\n    response = self._rest.PATCH(url, break_point.body, **kwargs)\n    return response\n</code></pre>"},{"location":"reference/services/processservice/#TM1py.Services.ProcessService.ProcessService.delete","title":"<code>delete(name, **kwargs)</code>","text":"<p>Delete a process in TM1</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> required <p>Returns:</p> Type Description <code>Response</code> <p>Response</p> Source code in <code>TM1py/Services/ProcessService.py</code> <pre><code>def delete(self, name: str, **kwargs) -&gt; Response:\n    \"\"\"Delete a process in TM1\n\n    :param name:\n    :return: Response\n    \"\"\"\n    url = format_url(\"/Processes('{}')\", name)\n    response = self._rest.DELETE(url, **kwargs)\n    return response\n</code></pre>"},{"location":"reference/services/processservice/#TM1py.Services.ProcessService.ProcessService.evaluate_boolean_ti_expression","title":"<code>evaluate_boolean_ti_expression(formula)</code>","text":"Source code in <code>TM1py/Services/ProcessService.py</code> <pre><code>@require_data_admin\ndef evaluate_boolean_ti_expression(self, formula: str):\n    prolog_procedure = f\"\"\"\n    if (~{formula.strip(\";\")});\n      ProcessQuit;\n    endif;\n    \"\"\"\n\n    process = Process(name=\"\", prolog_procedure=prolog_procedure)\n    success, status, _ = self.execute_process_with_return(process)\n    if status == \"QuitCalled\":\n        return False\n    elif status == \"CompletedSuccessfully\":\n        return True\n    else:\n        raise TM1pyException(f\"Unexpected TI return status: '{status}' for expression: '{formula}'\")\n</code></pre>"},{"location":"reference/services/processservice/#TM1py.Services.ProcessService.ProcessService.evaluate_ti_expression","title":"<code>evaluate_ti_expression(formula, **kwargs)</code>","text":"<p>This function is same functionality as hitting \"Evaluate\" within variable formula editor in TI     Function creates temporary TI and then starts a debug session on that TI     EnableTIDebugging=T must be present in .cfg file     Only suited for DEV and one-off uses, don't incorporate into dataframe lambda function</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>str</code> <p>a valid tm1 variable formula (no double quotes, no equals sign, semicolon optional) e.g. \"8*2;\", \"CellGetN('c1', 'e1', 'e2);\", \"ATTRS('Region', 'France', 'Currency')\"</p> required <p>Returns:</p> Type Description <code>str</code> <p>string result from formula</p> Source code in <code>TM1py/Services/ProcessService.py</code> <pre><code>@require_data_admin\ndef evaluate_ti_expression(self, formula: str, **kwargs) -&gt; str:\n    \"\"\"This function is same functionality as hitting \"Evaluate\" within variable formula editor in TI\n        Function creates temporary TI and then starts a debug session on that TI\n        EnableTIDebugging=T must be present in .cfg file\n        Only suited for DEV and one-off uses, don't incorporate into dataframe lambda function\n\n    :param formula: a valid tm1 variable formula (no double quotes, no equals sign, semicolon optional)\n        e.g. \"8*2;\", \"CellGetN('c1', 'e1', 'e2);\", \"ATTRS('Region', 'France', 'Currency')\"\n    :returns: string result from formula\n    \"\"\"\n\n    # grab everything to right of \"=\" if present\n    formula = formula[formula.find(\"=\") + 1 :]\n\n    # make sure semicolon at end is present\n    if not formula.strip().endswith(\";\"):\n        formula += \";\"\n\n    prolog_list = [\"sFunc = {}\".format(formula), \"sDebug='Stop';\"]\n    process_name = \"\".join([\"}TM1py\", str(uuid.uuid4())])\n    p = Process(name=process_name, prolog_procedure=Process.AUTO_GENERATED_STATEMENTS + \"\\r\\n\".join(prolog_list))\n    syntax_errors = self.compile_process(p, **kwargs)\n\n    if syntax_errors:\n        raise ValueError(str(syntax_errors))\n\n    try:\n        self.create(p, **kwargs)\n        debug_id = self.debug_process(p.name, **kwargs)[\"ID\"]\n        break_point = ProcessDebugBreakpoint(\n            breakpoint_id=1,\n            breakpoint_type=\"ProcessDebugContextDataBreakpoint\",\n            enabled=True,\n            hit_mode=\"BreakAlways\",\n            variable_name=\"sFunc\",\n        )\n        self.debug_add_breakpoint(debug_id=debug_id, break_point=break_point, **kwargs)\n        self.debug_continue(debug_id, **kwargs)\n        result = self.debug_get_variable_values(debug_id, **kwargs)\n        self.debug_continue(debug_id, **kwargs)\n\n        if not result:\n            raise ValueError(\"unknown error: no formula result found\")\n        else:\n            return result[\"sFunc\"]\n\n    except TM1pyRestException as e:\n        raise e\n\n    finally:\n        self.delete(p.name, **kwargs)\n</code></pre>"},{"location":"reference/services/processservice/#TM1py.Services.ProcessService.ProcessService.execute","title":"<code>execute(process_name, parameters=None, timeout=None, cancel_at_timeout=False, **kwargs)</code>","text":"<p>Ask TM1 Server to execute a process. Call with parameter names as keyword arguments: tm1.processes.execute(\"Bedrock.Server.Wait\", pLegalEntity=\"UK01\")</p> <p>Parameters:</p> Name Type Description Default <code>process_name</code> <code>str</code> required <code>parameters</code> <code>Dict</code> <p>Deprecated! dictionary, e.g. {\"Parameters\": [ { \"Name\": \"pLegalEntity\", \"Value\": \"UK01\" }] }</p> <code>None</code> <code>timeout</code> <code>float</code> <p>Number of seconds that the client will wait to receive the first byte.</p> <code>None</code> <code>cancel_at_timeout</code> <code>bool</code> <p>Abort operation in TM1 when timeout is reached</p> <code>False</code> <p>Returns:</p> Type Description <code>Response</code> Source code in <code>TM1py/Services/ProcessService.py</code> <pre><code>def execute(\n    self,\n    process_name: str,\n    parameters: Dict = None,\n    timeout: float = None,\n    cancel_at_timeout: bool = False,\n    **kwargs,\n) -&gt; Response:\n    \"\"\"Ask TM1 Server to execute a process. Call with parameter names as keyword arguments:\n    tm1.processes.execute(\"Bedrock.Server.Wait\", pLegalEntity=\"UK01\")\n\n    :param process_name:\n    :param parameters: Deprecated! dictionary, e.g. {\"Parameters\": [ { \"Name\": \"pLegalEntity\", \"Value\": \"UK01\" }] }\n    :param timeout: Number of seconds that the client will wait to receive the first byte.\n    :param cancel_at_timeout: Abort operation in TM1 when timeout is reached\n    :return:\n    \"\"\"\n    url = format_url(\"/Processes('{}')/tm1.Execute\", process_name)\n    if not parameters:\n        if kwargs:\n            parameters = {\"Parameters\": []}\n            for parameter_name, parameter_value in kwargs.items():\n                parameters[\"Parameters\"].append({\"Name\": parameter_name, \"Value\": parameter_value})\n        else:\n            parameters = {}\n    return self._rest.POST(\n        url=url,\n        data=json.dumps(parameters, ensure_ascii=False),\n        timeout=timeout,\n        cancel_at_timeout=cancel_at_timeout,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/services/processservice/#TM1py.Services.ProcessService.ProcessService.execute_process_with_return","title":"<code>execute_process_with_return(process, timeout=None, cancel_at_timeout=False, return_async_id=False, retry_on_disconnect=False, **kwargs)</code>","text":"<p>Run unbound TI code directly.</p> <p>Parameters:</p> Name Type Description Default <code>process</code> <code>Process</code> <p>a TI Process Object</p> required <code>timeout</code> <code>float</code> <p>Number of seconds that the client will wait to receive the first byte.</p> <code>None</code> <code>cancel_at_timeout</code> <code>bool</code> <p>Abort operation in TM1 when timeout is reached</p> <code>False</code> <code>return_async_id</code> <code>bool</code> <p>return async_id instead of (success, status, error_log_file)</p> <code>False</code> <code>retry_on_disconnect</code> <code>bool</code> <p>bool, indicates that the operation is idempotent and can be safely retried on connection errors</p> <code>False</code> <code>kwargs</code> <p>dictionary of process parameters and values</p> <code>{}</code> <p>Returns:</p> Type Description <code>Tuple[bool, str, str]</code> <p>success (boolean), status (String), error_log_file (String)</p> Source code in <code>TM1py/Services/ProcessService.py</code> <pre><code>@require_version(version=\"11.3\")\ndef execute_process_with_return(\n    self,\n    process: Process,\n    timeout: float = None,\n    cancel_at_timeout: bool = False,\n    return_async_id: bool = False,\n    retry_on_disconnect: bool = False,\n    **kwargs,\n) -&gt; Tuple[bool, str, str]:\n    \"\"\"Run unbound TI code directly.\n\n    :param process: a TI Process Object\n    :param timeout: Number of seconds that the client will wait to receive the first byte.\n    :param cancel_at_timeout: Abort operation in TM1 when timeout is reached\n    :param return_async_id: return async_id instead of (success, status, error_log_file)\n    :param retry_on_disconnect: bool, indicates that the operation is idempotent and can be safely retried on connection errors\n    :param kwargs: dictionary of process parameters and values\n    :return: success (boolean), status (String), error_log_file (String)\n    \"\"\"\n    url = \"/ExecuteProcessWithReturn?$expand=*\"\n    if kwargs:\n        for parameter_name, parameter_value in kwargs.items():\n            process.remove_parameter(name=parameter_name)\n            process.add_parameter(name=parameter_name, prompt=parameter_name, value=parameter_value)\n\n    payload = json.loads('{\"Process\":' + process.body + \"}\")\n\n    response = self._rest.POST(\n        url=url,\n        data=json.dumps(payload, ensure_ascii=False),\n        timeout=timeout,\n        cancel_at_timeout=cancel_at_timeout,\n        return_async_id=return_async_id,\n        idempotent=retry_on_disconnect,\n        **kwargs,\n    )\n\n    if return_async_id:\n        return response\n\n    return self._execute_with_return_parse_response(response)\n</code></pre>"},{"location":"reference/services/processservice/#TM1py.Services.ProcessService.ProcessService.execute_ti_code","title":"<code>execute_ti_code(lines_prolog, lines_epilog=None, **kwargs)</code>","text":"<p>Execute lines of code on the TM1 Server</p> <p>Parameters:</p> Name Type Description Default <code>lines_prolog</code> <code>Iterable[str]</code> <p>list - where each element is a valid statement of TI code.</p> required <code>lines_epilog</code> <code>Iterable[str]</code> <p>list - where each element is a valid statement of TI code.</p> <code>None</code> Source code in <code>TM1py/Services/ProcessService.py</code> <pre><code>@require_data_admin\ndef execute_ti_code(self, lines_prolog: Iterable[str], lines_epilog: Iterable[str] = None, **kwargs) -&gt; Response:\n    \"\"\"Execute lines of code on the TM1 Server\n\n    :param lines_prolog: list - where each element is a valid statement of TI code.\n    :param lines_epilog: list - where each element is a valid statement of TI code.\n    \"\"\"\n    process_name = \"\".join([\"}TM1py\", str(uuid.uuid4())])\n    p = Process(\n        name=process_name,\n        prolog_procedure=Process.AUTO_GENERATED_STATEMENTS + \"\\r\\n\".join(lines_prolog),\n        epilog_procedure=Process.AUTO_GENERATED_STATEMENTS + \"\\r\\n\".join(lines_epilog) if lines_epilog else \"\",\n    )\n    self.create(p, **kwargs)\n    try:\n        return self.execute(process_name, **kwargs)\n    except TM1pyRestException as e:\n        raise e\n    finally:\n        self.delete(process_name, **kwargs)\n</code></pre>"},{"location":"reference/services/processservice/#TM1py.Services.ProcessService.ProcessService.execute_with_return","title":"<code>execute_with_return(process_name=None, timeout=None, cancel_at_timeout=False, return_async_id=False, retry_on_disconnect=False, **kwargs)</code>","text":"<p>Ask TM1 Server to execute a process. pass process parameters as keyword arguments to this function. E.g:</p> <p>self.tm1.processes.execute_with_return(     process_name=\"Bedrock.Server.Wait\",     pWaitSec=2)</p> <p>Parameters:</p> Name Type Description Default <code>process_name</code> <code>str</code> <p>name of the TI process</p> <code>None</code> <code>timeout</code> <code>float</code> <p>Number of seconds that the client will wait to receive the first byte.</p> <code>None</code> <code>cancel_at_timeout</code> <code>bool</code> <p>Abort operation in TM1 when timeout is reached</p> <code>False</code> <code>return_async_id</code> <code>bool</code> <p>return async_id instead of (success, status, error_log_file)</p> <code>False</code> <code>retry_on_disconnect</code> <code>bool</code> <p>bool, indicates that the operation is idempotent and can be safely retried on connection errors</p> <code>False</code> <code>kwargs</code> <p>dictionary of process parameters and values</p> <code>{}</code> <p>Returns:</p> Type Description <code>Tuple[bool, str, str]</code> <p>success (boolean), status (String), error_log_file (String)</p> Source code in <code>TM1py/Services/ProcessService.py</code> <pre><code>def execute_with_return(\n    self,\n    process_name: str = None,\n    timeout: float = None,\n    cancel_at_timeout: bool = False,\n    return_async_id: bool = False,\n    retry_on_disconnect: bool = False,\n    **kwargs,\n) -&gt; Tuple[bool, str, str]:\n    \"\"\"Ask TM1 Server to execute a process.\n    pass process parameters as keyword arguments to this function. E.g:\n\n    self.tm1.processes.execute_with_return(\n        process_name=\"Bedrock.Server.Wait\",\n        pWaitSec=2)\n\n    :param process_name: name of the TI process\n    :param timeout: Number of seconds that the client will wait to receive the first byte.\n    :param cancel_at_timeout: Abort operation in TM1 when timeout is reached\n    :param return_async_id: return async_id instead of (success, status, error_log_file)\n    :param retry_on_disconnect: bool, indicates that the operation is idempotent and can be safely retried on connection errors\n    :param kwargs: dictionary of process parameters and values\n    :return: success (boolean), status (String), error_log_file (String)\n    \"\"\"\n\n    url = format_url(\"/Processes('{}')/tm1.ExecuteWithReturn?$expand=*\", process_name)\n    parameters = dict()\n    if kwargs:\n        parameters = {\"Parameters\": []}\n        for parameter_name, parameter_value in kwargs.items():\n            parameters[\"Parameters\"].append({\"Name\": parameter_name, \"Value\": parameter_value})\n\n    response = self._rest.POST(\n        url=url,\n        data=json.dumps(parameters, ensure_ascii=False),\n        timeout=timeout,\n        cancel_at_timeout=cancel_at_timeout,\n        return_async_id=return_async_id,\n        idempotent=retry_on_disconnect,\n        **kwargs,\n    )\n\n    if return_async_id:\n        return response\n\n    return self._execute_with_return_parse_response(response)\n</code></pre>"},{"location":"reference/services/processservice/#TM1py.Services.ProcessService.ProcessService.exists","title":"<code>exists(name, **kwargs)</code>","text":"<p>Check if Process exists.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> required <p>Returns:</p> Type Description <code>bool</code> Source code in <code>TM1py/Services/ProcessService.py</code> <pre><code>def exists(self, name: str, **kwargs) -&gt; bool:\n    \"\"\"Check if Process exists.\n\n    :param name:\n    :return:\n    \"\"\"\n    url = format_url(\"/Processes('{}')\", name)\n    return self._exists(url, **kwargs)\n</code></pre>"},{"location":"reference/services/processservice/#TM1py.Services.ProcessService.ProcessService.get","title":"<code>get(name_process, **kwargs)</code>","text":"<p>Get a process from TM1 Server</p> <p>Parameters:</p> Name Type Description Default <code>name_process</code> <code>str</code> required <p>Returns:</p> Type Description <code>Process</code> <p>Instance of the TM1py.Process</p> Source code in <code>TM1py/Services/ProcessService.py</code> <pre><code>def get(self, name_process: str, **kwargs) -&gt; Process:\n    \"\"\"Get a process from TM1 Server\n\n    :param name_process:\n    :return: Instance of the TM1py.Process\n    \"\"\"\n    url = format_url(\n        \"/Processes('{}')?$select=*,UIData,VariablesUIData,\"\n        \"DataSource/dataSourceNameForServer,\"\n        \"DataSource/dataSourceNameForClient,\"\n        \"DataSource/asciiDecimalSeparator,\"\n        \"DataSource/asciiDelimiterChar,\"\n        \"DataSource/asciiDelimiterType,\"\n        \"DataSource/asciiHeaderRecords,\"\n        \"DataSource/asciiQuoteCharacter,\"\n        \"DataSource/asciiThousandSeparator,\"\n        \"DataSource/view,\"\n        \"DataSource/query,\"\n        \"DataSource/userName,\"\n        \"DataSource/password,\"\n        \"DataSource/usesUnicode,\"\n        \"DataSource/subset,\"\n        \"DataSource/jsonRootPointer,\"\n        \"DataSource/jsonVariableMapping\",\n        name_process,\n    )\n\n    response = self._rest.GET(url, **kwargs)\n    return Process.from_dict(response.json())\n</code></pre>"},{"location":"reference/services/processservice/#TM1py.Services.ProcessService.ProcessService.get_all","title":"<code>get_all(skip_control_processes=False, **kwargs)</code>","text":"<p>Get all processes from TM1 Server</p> <p>Parameters:</p> Name Type Description Default <code>skip_control_processes</code> <code>bool</code> <p>bool, True to exclude processes that begin with \"}\" or \"{\"</p> <code>False</code> <p>Returns:</p> Type Description <code>List[Process]</code> <p>List, instances of the TM1py.Process</p> Source code in <code>TM1py/Services/ProcessService.py</code> <pre><code>def get_all(self, skip_control_processes: bool = False, **kwargs) -&gt; List[Process]:\n    \"\"\"Get all processes from TM1 Server\n\n    :param skip_control_processes: bool, True to exclude processes that begin with \"}\" or \"{\"\n    :return: List, instances of the TM1py.Process\n    \"\"\"\n    model_process_filter = \"&amp;$filter=startswith(Name,'}') eq false and startswith(Name,'{') eq false\"\n\n    url = (\n        \"/Processes?$select=*,UIData,VariablesUIData,\"\n        \"DataSource/dataSourceNameForServer,\"\n        \"DataSource/dataSourceNameForClient,\"\n        \"DataSource/asciiDecimalSeparator,\"\n        \"DataSource/asciiDelimiterChar,\"\n        \"DataSource/asciiDelimiterType,\"\n        \"DataSource/asciiHeaderRecords,\"\n        \"DataSource/asciiQuoteCharacter,\"\n        \"DataSource/asciiThousandSeparator,\"\n        \"DataSource/view,\"\n        \"DataSource/query,\"\n        \"DataSource/userName,\"\n        \"DataSource/password,\"\n        \"DataSource/usesUnicode,\"\n        \"DataSource/subset,\"\n        \"DataSource/jsonRootPointer,\"\n        \"DataSource/jsonVariableMapping{}\".format(model_process_filter if skip_control_processes else \"\")\n    )\n\n    response = self._rest.GET(url, **kwargs)\n    response_as_dict = response.json()\n    return [Process.from_dict(p) for p in response_as_dict[\"value\"]]\n</code></pre>"},{"location":"reference/services/processservice/#TM1py.Services.ProcessService.ProcessService.get_all_names","title":"<code>get_all_names(skip_control_processes=False, **kwargs)</code>","text":"<p>Get List with all process names from TM1 Server</p> <p>:Returns:     List of Strings</p> <p>Parameters:</p> Name Type Description Default <code>skip_control_processes</code> <code>bool</code> <p>bool, True to exclude processes that begin with \"}\" or \"{\"</p> <code>False</code> Source code in <code>TM1py/Services/ProcessService.py</code> <pre><code>def get_all_names(self, skip_control_processes: bool = False, **kwargs) -&gt; List[str]:\n    \"\"\"Get List with all process names from TM1 Server\n\n    :param skip_control_processes: bool, True to exclude processes that begin with \"}\" or \"{\"\n    :Returns:\n        List of Strings\n    \"\"\"\n    model_process_filter = \"&amp;$filter=startswith(Name,'}') eq false and startswith(Name,'{') eq false\"\n    url = \"/Processes?$select=Name{}\".format(model_process_filter if skip_control_processes else \"\")\n\n    response = self._rest.GET(url, **kwargs)\n    processes = list(process[\"Name\"] for process in response.json()[\"value\"])\n    return processes\n</code></pre>"},{"location":"reference/services/processservice/#TM1py.Services.ProcessService.ProcessService.get_error_log_file_content","title":"<code>get_error_log_file_content(file_name, **kwargs)</code>","text":"<p>Get content of error log file (e.g. TM1ProcessError_20180926213819_65708356_979b248b-232e622c6.log)</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>name of the error log file in the TM1 log directory</p> required <p>Returns:</p> Type Description <code>str</code> <p>String, content of the file</p> Source code in <code>TM1py/Services/ProcessService.py</code> <pre><code>def get_error_log_file_content(self, file_name: str, **kwargs) -&gt; str:\n    \"\"\"Get content of error log file (e.g. TM1ProcessError_20180926213819_65708356_979b248b-232e622c6.log)\n\n    :param file_name: name of the error log file in the TM1 log directory\n    :return: String, content of the file\n    \"\"\"\n    url = format_url(\"/ErrorLogFiles('{}')/Content\", file_name)\n    response = self._rest.GET(url=url, **kwargs)\n    return response.text\n</code></pre>"},{"location":"reference/services/processservice/#TM1py.Services.ProcessService.ProcessService.get_error_log_filenames","title":"<code>get_error_log_filenames(process_name=None, top=0, descending=False, **kwargs)</code>","text":"<p>Get error log filenames for specified TI process</p> <p>Parameters:</p> Name Type Description Default <code>process_name</code> <code>str</code> <p>valid TI name, leave blank to return all error log filenames</p> <code>None</code> <code>top</code> <code>int</code> <p>top n filenames</p> <code>0</code> <code>descending</code> <code>bool</code> <p>default sort is ascending, descending=True would have most recent at the top of list</p> <code>False</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>list of filenames</p> Source code in <code>TM1py/Services/ProcessService.py</code> <pre><code>def get_error_log_filenames(\n    self, process_name: str = None, top: int = 0, descending: bool = False, **kwargs\n) -&gt; List[str]:\n    \"\"\"Get error log filenames for specified TI process\n\n    :param process_name: valid TI name, leave blank to return all error log filenames\n    :param top: top n filenames\n    :param descending: default sort is ascending, descending=True would have most recent at the top of list\n    :return: list of filenames\n    \"\"\"\n    if process_name:\n        if not self.exists(name=process_name, **kwargs):\n            raise ValueError(f\"'{process_name}' is not a valid process\")\n        search_string = \"{}\".format(process_name)\n    else:\n        search_string = \"\"\n\n    return self.search_error_log_filenames(search_string=search_string, top=top, descending=descending, **kwargs)\n</code></pre>"},{"location":"reference/services/processservice/#TM1py.Services.ProcessService.ProcessService.get_last_message_from_processerrorlog","title":"<code>get_last_message_from_processerrorlog(process_name, **kwargs)</code>","text":"<p>Get the latest ProcessErrorLog from a process entity</p> <p>Parameters:</p> Name Type Description Default <code>process_name</code> <code>str</code> <p>name of the process</p> required <p>Returns:</p> Type Description <code>str</code> <p>String - the errorlog, e.g.:  \"Error: Data procedure line (9): Invalid key: Dimension Name: \"Product\", Element Name (Key): \"ProductA\"\"</p> Source code in <code>TM1py/Services/ProcessService.py</code> <pre><code>@deprecated_in_version(version=\"12\")\ndef get_last_message_from_processerrorlog(self, process_name: str, **kwargs) -&gt; str:\n    \"\"\"Get the latest ProcessErrorLog from a process entity\n\n    :param process_name: name of the process\n    :return: String - the errorlog, e.g.:  \"Error: Data procedure line (9): Invalid key:\n    Dimension Name: \"Product\", Element Name (Key): \"ProductA\"\"\n    \"\"\"\n    logs_as_list = self.get_processerrorlogs(process_name, **kwargs)\n    if len(logs_as_list) &gt; 0:\n        timestamp = logs_as_list[-1][\"Timestamp\"]\n        url = format_url(\"/Processes('{}')/ErrorLogs('{}')/Content\", process_name, timestamp)\n        # response is plain text - due to entity type Edm.Stream\n        response = self._rest.GET(url=url, **kwargs)\n        return response.text\n</code></pre>"},{"location":"reference/services/processservice/#TM1py.Services.ProcessService.ProcessService.get_processerrorlogs","title":"<code>get_processerrorlogs(process_name, **kwargs)</code>","text":"<p>Get all ProcessErrorLog entries for a process</p> <p>Parameters:</p> Name Type Description Default <code>process_name</code> <code>str</code> <p>name of the process</p> required <p>Returns:</p> Type Description <code>List</code> <p>list - Collection of ProcessErrorLogs</p> Source code in <code>TM1py/Services/ProcessService.py</code> <pre><code>def get_processerrorlogs(self, process_name: str, **kwargs) -&gt; List:\n    \"\"\"Get all ProcessErrorLog entries for a process\n\n    :param process_name: name of the process\n    :return: list - Collection of ProcessErrorLogs\n    \"\"\"\n    url = format_url(\"/Processes('{}')/ErrorLogs\", process_name)\n    response = self._rest.GET(url=url, **kwargs)\n    return response.json()[\"value\"]\n</code></pre>"},{"location":"reference/services/processservice/#TM1py.Services.ProcessService.ProcessService.poll_execute_with_return","title":"<code>poll_execute_with_return(async_id)</code>","text":"Source code in <code>TM1py/Services/ProcessService.py</code> <pre><code>def poll_execute_with_return(self, async_id: str):\n\n    response = self._rest.retrieve_async_response(async_id=async_id)\n    if response.status_code not in [200, 201]:\n        return None\n\n    # response transformation necessary in TM1 &lt; v11. Not required for v12\n    if response.content.startswith(b\"HTTP/\"):\n        response = self._rest.build_response_from_binary_response(response.content)\n\n    return self._execute_with_return_parse_response(response)\n</code></pre>"},{"location":"reference/services/processservice/#TM1py.Services.ProcessService.ProcessService.search_error_log_filenames","title":"<code>search_error_log_filenames(search_string, top=0, descending=False, **kwargs)</code>","text":"<p>Search error log filenames for given search string like a datestamp e.g. 20231201</p> <p>Parameters:</p> Name Type Description Default <code>search_string</code> <code>str</code> <p>substring to contain in file names</p> required <code>top</code> <code>int</code> <p>top n filenames</p> <code>0</code> <code>descending</code> <code>bool</code> <p>default sort is ascending, descending=True would have most recent at the top of list</p> <code>False</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>list of filenames</p> Source code in <code>TM1py/Services/ProcessService.py</code> <pre><code>def search_error_log_filenames(\n    self, search_string: str, top: int = 0, descending: bool = False, **kwargs\n) -&gt; List[str]:\n    \"\"\"Search error log filenames for given search string like a datestamp e.g. 20231201\n\n    :param search_string: substring to contain in file names\n    :param top: top n filenames\n    :param descending: default sort is ascending, descending=True would have most recent at the top of list\n    :return: list of filenames\n    \"\"\"\n\n    url = format_url(\n        \"/ErrorLogFiles?select=Filename&amp;$filter=contains(tolower(Filename), tolower('{}'))\", search_string\n    )\n\n    url += \"&amp;$top={}\".format(top) if top &gt; 0 else \"\"\n\n    url += \"&amp;$orderby=Filename desc\" if descending else \"\"\n\n    response = self._rest.GET(url=url, **kwargs)\n    return [log[\"Filename\"] for log in response.json()[\"value\"]]\n</code></pre>"},{"location":"reference/services/processservice/#TM1py.Services.ProcessService.ProcessService.search_string_in_code","title":"<code>search_string_in_code(search_string, skip_control_processes=False, **kwargs)</code>","text":"<p>Ask TM1 Server for list of process names that contain string anywhere in code tabs: Prolog,Metadata,Data,Epilog will not search DataSource, Parameters, Variables, or Attributes</p> <p>:Returns:     List of strings</p> <p>Parameters:</p> Name Type Description Default <code>search_string</code> <code>str</code> <p>case insensitive string to search for</p> required <code>skip_control_processes</code> <code>bool</code> <p>bool, True to exclude processes that begin with \"}\" or \"{\"</p> <code>False</code> Source code in <code>TM1py/Services/ProcessService.py</code> <pre><code>def search_string_in_code(self, search_string: str, skip_control_processes: bool = False, **kwargs) -&gt; List[str]:\n    \"\"\"Ask TM1 Server for list of process names that contain string anywhere in code tabs: Prolog,Metadata,Data,Epilog\n    will not search DataSource, Parameters, Variables, or Attributes\n\n    :param search_string: case insensitive string to search for\n    :param skip_control_processes: bool, True to exclude processes that begin with \"}\" or \"{\"\n    :Returns:\n        List of strings\n    \"\"\"\n    search_string = search_string.lower().replace(\" \", \"\")\n    model_process_filter = \"and (startswith(Name,'}') eq false and startswith(Name,'{') eq false)\"\n    url = format_url(\n        \"/Processes?$select=Name&amp;$filter=\"\n        \"contains(tolower(replace(PrologProcedure, ' ', '')),'{}') \"\n        \"or contains(tolower(replace(MetadataProcedure, ' ', '')),'{}') \"\n        \"or contains(tolower(replace(DataProcedure, ' ', '')),'{}') \"\n        \"or contains(tolower(replace(EpilogProcedure, ' ', '')),'{}')\",\n        search_string,\n        search_string,\n        search_string,\n        search_string,\n    )\n    url += \"{}\".format(model_process_filter if skip_control_processes else \"\")\n    response = self._rest.GET(url, **kwargs)\n    processes = list(process[\"Name\"] for process in response.json()[\"value\"])\n    return processes\n</code></pre>"},{"location":"reference/services/processservice/#TM1py.Services.ProcessService.ProcessService.search_string_in_name","title":"<code>search_string_in_name(name_startswith=None, name_contains=None, name_contains_operator='and', skip_control_processes=False, **kwargs)</code>","text":"<p>Ask TM1 Server for list of process names that contain or start with string</p> <p>Parameters:</p> Name Type Description Default <code>name_startswith</code> <code>str</code> <p>str, process name begins with (case insensitive)</p> <code>None</code> <code>name_contains</code> <code>Iterable</code> <p>iterable, found anywhere in name (case insensitive)</p> <code>None</code> <code>name_contains_operator</code> <code>str</code> <p>'and' or 'or'</p> <code>'and'</code> <code>skip_control_processes</code> <code>bool</code> <p>bool, True to exclude processes that begin with \"}\" or \"{\"</p> <code>False</code> Source code in <code>TM1py/Services/ProcessService.py</code> <pre><code>def search_string_in_name(\n    self,\n    name_startswith: str = None,\n    name_contains: Iterable = None,\n    name_contains_operator: str = \"and\",\n    skip_control_processes: bool = False,\n    **kwargs,\n) -&gt; List[str]:\n    \"\"\"Ask TM1 Server for list of process names that contain or start with string\n\n    :param name_startswith: str, process name begins with (case insensitive)\n    :param name_contains: iterable, found anywhere in name (case insensitive)\n    :param name_contains_operator: 'and' or 'or'\n    :param skip_control_processes: bool, True to exclude processes that begin with \"}\" or \"{\"\n    \"\"\"\n    model_process_filter = \"and (startswith(Name,'}') eq false and startswith(Name,'{') eq false)\"\n    name_contains_operator = name_contains_operator.strip().lower()\n    if name_contains_operator not in (\"and\", \"or\"):\n        raise ValueError(\"'name_contains_operator' must be either 'AND' or 'OR'\")\n\n    url = \"/Processes?$select=Name\"\n    name_filters = []\n\n    if name_startswith:\n        name_filters.append(format_url(\"startswith(toupper(Name),toupper('{}'))\", name_startswith))\n\n    if name_contains:\n        if isinstance(name_contains, str):\n            name_filters.append(format_url(\"contains(toupper(Name),toupper('{}'))\", name_contains))\n\n        elif isinstance(name_contains, Iterable):\n            name_contains_filters = [\n                format_url(\"contains(toupper(Name),toupper('{}'))\", wildcard) for wildcard in name_contains\n            ]\n            name_filters.append(\"({})\".format(f\" {name_contains_operator} \".join(name_contains_filters)))\n\n        else:\n            raise ValueError(\"'name_contains' must be str or iterable\")\n\n    url += \"&amp;$filter={}\".format(\" and \".join(name_filters))\n    url += \"{}\".format(model_process_filter if skip_control_processes else \"\")\n    response = self._rest.GET(url, **kwargs)\n    return list(process[\"Name\"] for process in response.json()[\"value\"])\n</code></pre>"},{"location":"reference/services/processservice/#TM1py.Services.ProcessService.ProcessService.update","title":"<code>update(process, **kwargs)</code>","text":"<p>Update an existing Process on TM1 Server</p> <p>Parameters:</p> Name Type Description Default <code>process</code> <code>Process</code> <p>Instance of TM1py.Process class</p> required <p>Returns:</p> Type Description <code>Response</code> <p>Response</p> Source code in <code>TM1py/Services/ProcessService.py</code> <pre><code>def update(self, process: Process, **kwargs) -&gt; Response:\n    \"\"\"Update an existing Process on TM1 Server\n\n    :param process: Instance of TM1py.Process class\n    :return: Response\n    \"\"\"\n    url = format_url(\"/Processes('{}')\", process.name)\n    # Adjust process body if TM1 version is lower than 11 due to change in Process Parameters structure\n    # https://www.ibm.com/developerworks/community/forums/html/topic?id=9188d139-8905-4895-9229-eaaf0e7fa683\n    if int(self.version[0:2]) &lt; 11:\n        process.drop_parameter_types()\n    response = self._rest.PATCH(url, process.body, **kwargs)\n    return response\n</code></pre>"},{"location":"reference/services/processservice/#TM1py.Services.ProcessService.ProcessService.update_or_create","title":"<code>update_or_create(process, **kwargs)</code>","text":"<p>Update or Create a Process on TM1 Server</p> <p>Parameters:</p> Name Type Description Default <code>process</code> <code>Process</code> <p>Instance of TM1py.Process class</p> required <p>Returns:</p> Type Description <code>Response</code> <p>Response</p> Source code in <code>TM1py/Services/ProcessService.py</code> <pre><code>def update_or_create(self, process: Process, **kwargs) -&gt; Response:\n    \"\"\"Update or Create a Process on TM1 Server\n\n    :param process: Instance of TM1py.Process class\n    :return: Response\n    \"\"\"\n    if self.exists(name=process.name, **kwargs):\n        return self.update(process=process, **kwargs)\n\n    return self.create(process=process, **kwargs)\n</code></pre>"},{"location":"reference/services/restservice/","title":"RestService","text":""},{"location":"reference/services/restservice/#TM1py.Services.RestService.AuthenticationMode","title":"<code>AuthenticationMode</code>","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"reference/services/restservice/#TM1py.Services.RestService.AuthenticationMode.ACCESS_TOKEN","title":"<code>ACCESS_TOKEN = 9</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/services/restservice/#TM1py.Services.RestService.AuthenticationMode.BASIC","title":"<code>BASIC = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/services/restservice/#TM1py.Services.RestService.AuthenticationMode.BASIC_API_KEY","title":"<code>BASIC_API_KEY = 8</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/services/restservice/#TM1py.Services.RestService.AuthenticationMode.CAM","title":"<code>CAM = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/services/restservice/#TM1py.Services.RestService.AuthenticationMode.CAM_SSO","title":"<code>CAM_SSO = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/services/restservice/#TM1py.Services.RestService.AuthenticationMode.IBM_CLOUD_API_KEY","title":"<code>IBM_CLOUD_API_KEY = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/services/restservice/#TM1py.Services.RestService.AuthenticationMode.PA_PROXY","title":"<code>PA_PROXY = 7</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/services/restservice/#TM1py.Services.RestService.AuthenticationMode.SERVICE_TO_SERVICE","title":"<code>SERVICE_TO_SERVICE = 6</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/services/restservice/#TM1py.Services.RestService.AuthenticationMode.WIA","title":"<code>WIA = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/services/restservice/#TM1py.Services.RestService.AuthenticationMode.use_v12_auth","title":"<code>use_v12_auth</code>  <code>property</code>","text":""},{"location":"reference/services/restservice/#TM1py.Services.RestService.BytesIOSocket","title":"<code>BytesIOSocket(content)</code>","text":"<p>used in urllib3_response_from_bytes method to construct urllib3 response from raw bytes</p> Source code in <code>TM1py/Services/RestService.py</code> <pre><code>def __init__(self, content: bytes):\n    self.handle = BytesIO(content)\n</code></pre>"},{"location":"reference/services/restservice/#TM1py.Services.RestService.BytesIOSocket.handle","title":"<code>handle = BytesIO(content)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/services/restservice/#TM1py.Services.RestService.BytesIOSocket.makefile","title":"<code>makefile(mode)</code>","text":"Source code in <code>TM1py/Services/RestService.py</code> <pre><code>def makefile(self, mode) -&gt; BytesIO:\n    return self.handle\n</code></pre>"},{"location":"reference/services/restservice/#TM1py.Services.RestService.RestService","title":"<code>RestService(**kwargs)</code>","text":"<p>Low level communication with TM1 instance through HTTP. Allows to execute HTTP Methods     - GET     - POST     - PATCH     - DELETE Takes Care of     - Encodings     - TM1 User-Login     - HTTP Headers     - HTTP Session Management     - Response Handling Based on requests module</p> <p>Create an instance of RESTService</p> <p>Supported kwargs arguments:</p> <ul> <li>address (str): Address of the TM1 instance.</li> <li>port (int): HTTPPortNumber as specified in the tm1s.cfg.</li> <li>ssl (bool): Use SSL as specified in the tm1s.cfg.</li> <li>instance (str): Planning Analytics Engine (v12) instance name.</li> <li>database (str): Planning Analytics Engine (v12) database name.</li> <li>base_url (str): Base URL.</li> <li>auth_url (str): Auth URL for Planning Analytics Engine (v12).</li> <li>user (str): Name of the user.</li> <li>password (str): Password of the user.</li> <li>decode_b64 (bool): Whether password argument is b64 encoded.</li> <li>namespace (str): Optional CAM namespace.</li> <li>cam_passport (str): The CAM passport.</li> <li>session_id (str): TM1SessionId, e.g. q7O6e1w49AixeuLVxJ1GZg.</li> <li>application_client_id (str): Planning Analytics Engine (v12) named application client ID created via manage service.</li> <li>application_client_secret (str): Planning Analytics Engine (v12) named application secret created via manage service.</li> <li>api_key (str): Planning Analytics Engine (v12) API Key from https://cloud.ibm.com/iam/apikeys.</li> <li>iam_url (str): Planning Analytics Engine (v12) IBM Cloud IAM URL. Default: \"https://iam.cloud.ibm.com\".</li> <li>pa_url (str): Planning Analytics Engine (v12) PA URL, e.g., \"https://us-east-2.aws.planninganalytics.ibm.com\".</li> <li>cpd_url (str): Cloud Pack for Data URL (aka ZEN) CPD URL, e.g., \"https://cpd-zen.apps.cp4dpa-test11.cp.fyre.ibm.com\".</li> <li>tenant (str): Planning Analytics Engine (v12) Tenant, e.g., YC4B2M1AG2Y6.</li> <li>session_context (str): Name of the Application. Controls \"Context\" column in Arc / TM1top. If None, uses default: TM1py.</li> <li>verify (str|bool): Path to .cer file or 'True' / True / 'False' / False (if no SSL verification is required).</li> <li>logging (bool): Switch on/off verbose HTTP logging into sys.stdout.</li> <li>timeout (float): Number of seconds that the client will wait to receive the first byte.</li> <li>cancel_at_timeout (bool): Abort operation in TM1 when timeout is reached.</li> <li>async_requests_mode (bool): Changes internal REST execution mode to avoid 60s timeout on IBM cloud.</li> <li>connection_pool_size (int): Maximum number of connections to save in the pool (default: 10). In a multi-threaded environment, set higher.</li> <li>pool_connections (int): Number of connection pools to cache (default: 1 for a single TM1 instance).</li> <li>integrated_login (bool): True for IntegratedSecurityMode3.</li> <li>integrated_login_domain (str): NT Domain name. Default: '.' for local account.</li> <li>integrated_login_service (str): Kerberos Service type for remote Service Principal Name. Default: 'HTTP'.</li> <li>integrated_login_host (str): Host name for Service Principal Name. Default: Extracted from request URI.</li> <li>integrated_login_delegate (bool): Indicates that the user's credentials are to be delegated to the server. Default: False.</li> <li>impersonate (str): Name of user to impersonate.</li> <li>re_connect_on_session_timeout (bool): Attempt to reconnect once if session is timed out.</li> <li>re_connect_on_remote_disconnect (bool): Attempt to reconnect once if connection is aborted by remote end.</li> <li>remote_disconnect_max_retries (int): Maximum number of retry attempts after remote disconnect (default: 5).</li> <li>remote_disconnect_retry_delay (float): Initial delay in seconds before first retry attempt (default: 1).</li> <li>remote_disconnect_max_delay (float): Maximum delay cap in seconds between retry attempts (default: 30).</li> <li>remote_disconnect_backoff_factor (float): Multiplier for exponential backoff between retry attempts (default: 2).</li> <li>async_polling_initial_delay (float): Initial polling delay in seconds for async operations (default: 0.1).</li> <li>async_polling_max_delay (float): Maximum polling delay cap in seconds for async operations (default: 1.0).</li> <li>async_polling_backoff_factor (float): Multiplier for exponential backoff in async polling (default: 2).</li> <li>proxies (dict): Dictionary with proxies, e.g. {'http': 'http://proxy.example.com:8080', 'https': 'http://secureproxy.example.com:8090'}.</li> <li>ssl_context: User-defined SSL context.</li> <li>cert (str|tuple): (Optional) If string, path to SSL client cert file (.pem). If tuple, ('cert', 'key') pair.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <p>See description above for all supported arguments</p> <code>{}</code> Source code in <code>TM1py/Services/RestService.py</code> <pre><code>def __init__(self, **kwargs):\n    \"\"\"Create an instance of RESTService\n\n    Supported kwargs arguments:\n\n    - **address** (str): Address of the TM1 instance.\n    - **port** (int): HTTPPortNumber as specified in the tm1s.cfg.\n    - **ssl** (bool): Use SSL as specified in the tm1s.cfg.\n    - **instance** (str): Planning Analytics Engine (v12) instance name.\n    - **database** (str): Planning Analytics Engine (v12) database name.\n    - **base_url** (str): Base URL.\n    - **auth_url** (str): Auth URL for Planning Analytics Engine (v12).\n    - **user** (str): Name of the user.\n    - **password** (str): Password of the user.\n    - **decode_b64** (bool): Whether password argument is b64 encoded.\n    - **namespace** (str): Optional CAM namespace.\n    - **cam_passport** (str): The CAM passport.\n    - **session_id** (str): TM1SessionId, e.g. q7O6e1w49AixeuLVxJ1GZg.\n    - **application_client_id** (str): Planning Analytics Engine (v12) named application client ID created via manage service.\n    - **application_client_secret** (str): Planning Analytics Engine (v12) named application secret created via manage service.\n    - **api_key** (str): Planning Analytics Engine (v12) API Key from https://cloud.ibm.com/iam/apikeys.\n    - **iam_url** (str): Planning Analytics Engine (v12) IBM Cloud IAM URL. Default: \"https://iam.cloud.ibm.com\".\n    - **pa_url** (str): Planning Analytics Engine (v12) PA URL, e.g., \"https://us-east-2.aws.planninganalytics.ibm.com\".\n    - **cpd_url** (str): Cloud Pack for Data URL (aka ZEN) CPD URL, e.g., \"https://cpd-zen.apps.cp4dpa-test11.cp.fyre.ibm.com\".\n    - **tenant** (str): Planning Analytics Engine (v12) Tenant, e.g., YC4B2M1AG2Y6.\n    - **session_context** (str): Name of the Application. Controls \"Context\" column in Arc / TM1top. If None, uses default: TM1py.\n    - **verify** (str|bool): Path to .cer file or 'True' / True / 'False' / False (if no SSL verification is required).\n    - **logging** (bool): Switch on/off verbose HTTP logging into sys.stdout.\n    - **timeout** (float): Number of seconds that the client will wait to receive the first byte.\n    - **cancel_at_timeout** (bool): Abort operation in TM1 when timeout is reached.\n    - **async_requests_mode** (bool): Changes internal REST execution mode to avoid 60s timeout on IBM cloud.\n    - **connection_pool_size** (int): Maximum number of connections to save in the pool (default: 10). In a multi-threaded environment, set higher.\n    - **pool_connections** (int): Number of connection pools to cache (default: 1 for a single TM1 instance).\n    - **integrated_login** (bool): True for IntegratedSecurityMode3.\n    - **integrated_login_domain** (str): NT Domain name. Default: '.' for local account.\n    - **integrated_login_service** (str): Kerberos Service type for remote Service Principal Name. Default: 'HTTP'.\n    - **integrated_login_host** (str): Host name for Service Principal Name. Default: Extracted from request URI.\n    - **integrated_login_delegate** (bool): Indicates that the user's credentials are to be delegated to the server. Default: False.\n    - **impersonate** (str): Name of user to impersonate.\n    - **re_connect_on_session_timeout** (bool): Attempt to reconnect once if session is timed out.\n    - **re_connect_on_remote_disconnect** (bool): Attempt to reconnect once if connection is aborted by remote end.\n    - **remote_disconnect_max_retries** (int): Maximum number of retry attempts after remote disconnect (default: 5).\n    - **remote_disconnect_retry_delay** (float): Initial delay in seconds before first retry attempt (default: 1).\n    - **remote_disconnect_max_delay** (float): Maximum delay cap in seconds between retry attempts (default: 30).\n    - **remote_disconnect_backoff_factor** (float): Multiplier for exponential backoff between retry attempts (default: 2).\n    - **async_polling_initial_delay** (float): Initial polling delay in seconds for async operations (default: 0.1).\n    - **async_polling_max_delay** (float): Maximum polling delay cap in seconds for async operations (default: 1.0).\n    - **async_polling_backoff_factor** (float): Multiplier for exponential backoff in async polling (default: 2).\n    - **proxies** (dict): Dictionary with proxies, e.g. {'http': 'http://proxy.example.com:8080', 'https': 'http://secureproxy.example.com:8090'}.\n    - **ssl_context**: User-defined SSL context.\n    - **cert** (str|tuple): (Optional) If string, path to SSL client cert file (.pem). If tuple, ('cert', 'key') pair.\n\n    :param kwargs: See description above for all supported arguments\t\n    \"\"\"\n    # store kwargs for future use e.g. re_connect on 401 session timeout\n    self._kwargs = kwargs\n\n    # core arguments for connection\n    self._ssl = self.translate_to_boolean(kwargs.get(\"ssl\", True))\n    self._address = kwargs.get(\"address\", None)\n    self._port = kwargs.get(\"port\", None)\n    self._base_url = kwargs.get(\"base_url\", None)\n    self._auth_url = kwargs.get(\"auth_url\", None)\n    self._instance = kwargs.get(\"instance\", None)\n    self._database = kwargs.get(\"database\", None)\n    self._api_key = kwargs.get(\"api_key\", None)\n    self._iam_url = kwargs.get(\"iam_url\", None)\n    self._pa_url = kwargs.get(\"pa_url\", None)\n    self._cpd_url = kwargs.get(\"cpd_url\", None)\n    self._tenant = kwargs.get(\"tenant\", None)\n    self._user = kwargs.get(\"user\", kwargs.get(\"username\", None))\n\n    # other arguments\n    self._auth_mode = self._determine_auth_mode()\n    self._timeout = None if kwargs.get(\"timeout\", None) is None else float(kwargs.get(\"timeout\"))\n    self._cancel_at_timeout = kwargs.get(\"cancel_at_timeout\", False)\n    self._async_requests_mode = self.translate_to_boolean(kwargs.get(\"async_requests_mode\", False))\n    self._connection_pool_size = int(kwargs.get(\"connection_pool_size\", self.DEFAULT_CONNECTION_POOL_SIZE))\n    self._pool_connections = int(kwargs.get(\"pool_connections\", self.DEFAULT_POOL_CONNECTIONS))\n    self._re_connect_on_session_timeout = kwargs.get(\"re_connect_on_session_timeout\", True)\n    self._re_connect_on_remote_disconnect = kwargs.get(\"re_connect_on_remote_disconnect\", True)\n    self._remote_disconnect_max_retries = int(kwargs.get(\"remote_disconnect_max_retries\", 5))\n    self._remote_disconnect_retry_delay = float(kwargs.get(\"remote_disconnect_retry_delay\", 1))\n    self._remote_disconnect_max_delay = float(kwargs.get(\"remote_disconnect_max_delay\", 30))\n    self._remote_disconnect_backoff_factor = float(kwargs.get(\"remote_disconnect_backoff_factor\", 2))\n    self._async_polling_initial_delay = float(kwargs.get(\"async_polling_initial_delay\", 0.1))\n    self._async_polling_max_delay = float(kwargs.get(\"async_polling_max_delay\", 1.0))\n    self._async_polling_backoff_factor = float(kwargs.get(\"async_polling_backoff_factor\", 2))\n    # is retrieved on demand and then cached\n    self._sandboxing_disabled = None\n    # optional verbose logging to stdout\n    self.handle_logging(kwargs.get(\"logging\", False))\n\n    self._proxies = self._handle_proxies(kwargs.get(\"proxies\", None))\n    self._is_admin = None\n    self._is_data_admin = None\n    self._is_security_admin = None\n    self._is_ops_admin = None\n    self._ssl_context = kwargs.get(\"ssl_context\", None)\n\n    # populated later on the fly for users with the name different from 'Admin'\n    if self._user and case_and_space_insensitive_equals(self._user, \"ADMIN\"):\n        self._is_admin = True\n        self._is_data_admin = True\n        self._is_security_admin = True\n        self._is_ops_admin = True\n\n    self._verify = self._determine_verify(kwargs.get(\"verify\", None))\n\n    self._base_url, self._auth_url = self._construct_service_and_auth_root()\n\n    self._version = None\n    self._headers = self.HEADERS.copy()\n    if \"session_context\" in kwargs:\n        self._headers[\"TM1-SessionContext\"] = kwargs[\"session_context\"]\n\n    self.disable_http_warnings()\n\n    self._s = Session()\n    self._manage_http_adapter()\n\n    self._cert = kwargs.get(\"cert\")\n    self._s.cert = self._cert\n\n    if self._proxies:\n        self._s.proxies = self._proxies\n\n    # First contact with TM1\n    self.connect()\n    if not self._version:\n        self.set_version()\n</code></pre>"},{"location":"reference/services/restservice/#TM1py.Services.RestService.RestService.DEFAULT_CONNECTION_POOL_SIZE","title":"<code>DEFAULT_CONNECTION_POOL_SIZE = 10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/services/restservice/#TM1py.Services.RestService.RestService.DEFAULT_POOL_CONNECTIONS","title":"<code>DEFAULT_POOL_CONNECTIONS = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/services/restservice/#TM1py.Services.RestService.RestService.HEADERS","title":"<code>HEADERS = {'Connection': 'keep-alive', 'User-Agent': 'TM1py', 'Content-Type': 'application/json; odata.streaming=true; charset=utf-8', 'Accept': 'application/json;odata.metadata=none,text/plain', 'TM1-SessionContext': 'TM1py'}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/services/restservice/#TM1py.Services.RestService.RestService.is_admin","title":"<code>is_admin</code>  <code>property</code>","text":""},{"location":"reference/services/restservice/#TM1py.Services.RestService.RestService.is_data_admin","title":"<code>is_data_admin</code>  <code>property</code>","text":""},{"location":"reference/services/restservice/#TM1py.Services.RestService.RestService.is_ops_admin","title":"<code>is_ops_admin</code>  <code>property</code>","text":""},{"location":"reference/services/restservice/#TM1py.Services.RestService.RestService.is_security_admin","title":"<code>is_security_admin</code>  <code>property</code>","text":""},{"location":"reference/services/restservice/#TM1py.Services.RestService.RestService.sandboxing_disabled","title":"<code>sandboxing_disabled</code>  <code>property</code>","text":""},{"location":"reference/services/restservice/#TM1py.Services.RestService.RestService.session_id","title":"<code>session_id</code>  <code>property</code>","text":""},{"location":"reference/services/restservice/#TM1py.Services.RestService.RestService.version","title":"<code>version</code>  <code>property</code>","text":""},{"location":"reference/services/restservice/#TM1py.Services.RestService.RestService.DELETE","title":"<code>DELETE(url, data='', headers=None, async_requests_mode=None, return_async_id=False, timeout=None, cancel_at_timeout=False, encoding='utf-8', idempotent=False, verify_response=True, **kwargs)</code>","text":"<p>Perform a DELETE request against TM1 instance</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> required <code>data</code> <code>Union[str, bytes, BytesIO]</code> <p>the payload</p> <code>''</code> <code>headers</code> <code>Dict</code> <p>custom headers</p> <code>None</code> <code>async_requests_mode</code> <code>bool</code> <p>changes internal REST execution mode to avoid 60s timeout on IBM cloud</p> <code>None</code> <code>return_async_id</code> <code>bool</code> <p>If True function will return async_id after initiation and not await the execution</p> <code>False</code> <code>timeout</code> <code>float</code> <p>Number of seconds that the client will wait to receive the first byte.</p> <code>None</code> <code>cancel_at_timeout</code> <code>bool</code> <p>Abort operation in TM1 when timeout is reached</p> <code>False</code> <code>encoding</code> <code>str</code> <code>'utf-8'</code> <p>Returns:</p> Type Description <p>response object or async_id</p> Source code in <code>TM1py/Services/RestService.py</code> <pre><code>def DELETE(\n    self,\n    url: str,\n    data: Union[str, bytes, BytesIO] = \"\",\n    headers: Dict = None,\n    async_requests_mode: bool = None,\n    return_async_id: bool = False,\n    timeout: float = None,\n    cancel_at_timeout: bool = False,\n    encoding: str = \"utf-8\",\n    idempotent: bool = False,\n    verify_response: bool = True,\n    **kwargs,\n):\n    \"\"\"Perform a DELETE request against TM1 instance\n    :param url:\n    :param data: the payload\n    :param headers: custom headers\n    :param async_requests_mode: changes internal REST execution mode to avoid 60s timeout on IBM cloud\n    :param return_async_id: If True function will return async_id after initiation and not await the execution\n    :param timeout: Number of seconds that the client will wait to receive the first byte.\n    :param cancel_at_timeout: Abort operation in TM1 when timeout is reached\n    :param encoding:\n    :return: response object or async_id\n    \"\"\"\n\n    return self.request(\n        method=\"delete\",\n        headers={**self._headers, **headers} if headers else dict(self._headers),\n        url=url,\n        data=data,\n        async_requests_mode=async_requests_mode,\n        return_async_id=return_async_id,\n        timeout=timeout if timeout else self._timeout,\n        cancel_at_timeout=cancel_at_timeout,\n        encoding=encoding,\n        idempotent=idempotent,\n        verify_response=verify_response,\n    )\n</code></pre>"},{"location":"reference/services/restservice/#TM1py.Services.RestService.RestService.GET","title":"<code>GET(url, data='', headers=None, async_requests_mode=None, return_async_id=False, timeout=None, cancel_at_timeout=False, encoding='utf-8', idempotent=True, verify_response=True, **kwargs)</code>","text":"<p>Perform a GET request against TM1 instance</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> required <code>data</code> <code>Union[str, bytes, BytesIO]</code> <p>the payload</p> <code>''</code> <code>headers</code> <code>Dict</code> <p>custom headers</p> <code>None</code> <code>async_requests_mode</code> <code>bool</code> <p>changes internal REST execution mode to avoid 60s timeout on IBM cloud</p> <code>None</code> <code>return_async_id</code> <code>bool</code> <p>If True function will return async_id after initiation and not await the execution</p> <code>False</code> <code>timeout</code> <code>float</code> <p>Number of seconds that the client will wait to receive the first byte.</p> <code>None</code> <code>cancel_at_timeout</code> <code>bool</code> <p>Abort operation in TM1 when timeout is reached</p> <code>False</code> <code>encoding</code> <code>str</code> <code>'utf-8'</code> <p>Returns:</p> Type Description <p>response object or async_id</p> Source code in <code>TM1py/Services/RestService.py</code> <pre><code>def GET(\n    self,\n    url: str,\n    data: Union[str, bytes, BytesIO] = \"\",\n    headers: Dict = None,\n    async_requests_mode: bool = None,\n    return_async_id: bool = False,\n    timeout: float = None,\n    cancel_at_timeout: bool = False,\n    encoding: str = \"utf-8\",\n    idempotent: bool = True,\n    verify_response: bool = True,\n    **kwargs,\n):\n    \"\"\"Perform a GET request against TM1 instance\n    :param url:\n    :param data: the payload\n    :param headers: custom headers\n    :param async_requests_mode: changes internal REST execution mode to avoid 60s timeout on IBM cloud\n    :param return_async_id: If True function will return async_id after initiation and not await the execution\n    :param timeout: Number of seconds that the client will wait to receive the first byte.\n    :param cancel_at_timeout: Abort operation in TM1 when timeout is reached\n    :param encoding:\n    :return: response object or async_id\n    \"\"\"\n\n    return self.request(\n        method=\"get\",\n        headers={**self._headers, **headers} if headers else dict(self._headers),\n        url=url,\n        data=data,\n        async_requests_mode=async_requests_mode,\n        return_async_id=return_async_id,\n        timeout=timeout if timeout else self._timeout,\n        cancel_at_timeout=cancel_at_timeout,\n        encoding=encoding,\n        idempotent=idempotent,\n        verify_response=verify_response,\n    )\n</code></pre>"},{"location":"reference/services/restservice/#TM1py.Services.RestService.RestService.PATCH","title":"<code>PATCH(url, data='', headers=None, async_requests_mode=None, return_async_id=False, timeout=None, cancel_at_timeout=False, encoding='utf-8', idempotent=False, verify_response=True, **kwargs)</code>","text":"<p>Perform a PATCH request against TM1 instance</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> required <code>data</code> <code>Union[str, bytes, BytesIO]</code> <p>the payload</p> <code>''</code> <code>headers</code> <code>Dict</code> <p>custom headers</p> <code>None</code> <code>async_requests_mode</code> <code>bool</code> <p>changes internal REST execution mode to avoid 60s timeout on IBM cloud</p> <code>None</code> <code>return_async_id</code> <code>bool</code> <p>If True function will return async_id after initiation and not await the execution</p> <code>False</code> <code>timeout</code> <code>float</code> <p>Number of seconds that the client will wait to receive the first byte.</p> <code>None</code> <code>cancel_at_timeout</code> <code>bool</code> <p>Abort operation in TM1 when timeout is reached</p> <code>False</code> <code>encoding</code> <code>str</code> <code>'utf-8'</code> <p>Returns:</p> Type Description <p>response object or async_id</p> Source code in <code>TM1py/Services/RestService.py</code> <pre><code>def PATCH(\n    self,\n    url: str,\n    data: Union[str, bytes, BytesIO] = \"\",\n    headers: Dict = None,\n    async_requests_mode: bool = None,\n    return_async_id: bool = False,\n    timeout: float = None,\n    cancel_at_timeout: bool = False,\n    encoding: str = \"utf-8\",\n    idempotent: bool = False,\n    verify_response: bool = True,\n    **kwargs,\n):\n    \"\"\"Perform a PATCH request against TM1 instance\n    :param url:\n    :param data: the payload\n    :param headers: custom headers\n    :param async_requests_mode: changes internal REST execution mode to avoid 60s timeout on IBM cloud\n    :param return_async_id: If True function will return async_id after initiation and not await the execution\n    :param timeout: Number of seconds that the client will wait to receive the first byte.\n    :param cancel_at_timeout: Abort operation in TM1 when timeout is reached\n    :param encoding:\n    :return: response object or async_id\n    \"\"\"\n\n    return self.request(\n        method=\"patch\",\n        headers={**self._headers, **headers} if headers else dict(self._headers),\n        url=url,\n        data=data,\n        async_requests_mode=async_requests_mode,\n        return_async_id=return_async_id,\n        timeout=timeout if timeout else self._timeout,\n        cancel_at_timeout=cancel_at_timeout,\n        encoding=encoding,\n        idempotent=idempotent,\n        verify_response=verify_response,\n    )\n</code></pre>"},{"location":"reference/services/restservice/#TM1py.Services.RestService.RestService.POST","title":"<code>POST(url, data='', headers=None, async_requests_mode=None, return_async_id=False, timeout=None, cancel_at_timeout=False, encoding='utf-8', idempotent=False, verify_response=True, **kwargs)</code>","text":"<p>Perform a POST request against TM1 instance</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> required <code>data</code> <code>Union[str, bytes, BytesIO]</code> <p>the payload</p> <code>''</code> <code>headers</code> <code>Dict</code> <p>custom headers</p> <code>None</code> <code>async_requests_mode</code> <code>bool</code> <p>changes internal REST execution mode to avoid 60s timeout on IBM cloud</p> <code>None</code> <code>return_async_id</code> <code>bool</code> <p>If True function will return async_id after initiation and not await the execution</p> <code>False</code> <code>timeout</code> <code>float</code> <p>Number of seconds that the client will wait to receive the first byte.</p> <code>None</code> <code>cancel_at_timeout</code> <code>bool</code> <p>Abort operation in TM1 when timeout is reached</p> <code>False</code> <code>encoding</code> <code>str</code> <code>'utf-8'</code> <p>Returns:</p> Type Description <p>response object or async_id</p> Source code in <code>TM1py/Services/RestService.py</code> <pre><code>def POST(\n    self,\n    url: str,\n    data: Union[str, bytes, BytesIO] = \"\",\n    headers: Dict = None,\n    async_requests_mode: bool = None,\n    return_async_id: bool = False,\n    timeout: float = None,\n    cancel_at_timeout: bool = False,\n    encoding: str = \"utf-8\",\n    idempotent: bool = False,\n    verify_response: bool = True,\n    **kwargs,\n):\n    \"\"\"Perform a POST request against TM1 instance\n    :param url:\n    :param data: the payload\n    :param headers: custom headers\n    :param async_requests_mode: changes internal REST execution mode to avoid 60s timeout on IBM cloud\n    :param return_async_id: If True function will return async_id after initiation and not await the execution\n    :param timeout: Number of seconds that the client will wait to receive the first byte.\n    :param cancel_at_timeout: Abort operation in TM1 when timeout is reached\n    :param encoding:\n    :return: response object or async_id\n    \"\"\"\n\n    response = self.request(\n        method=\"post\",\n        headers={**self._headers, **headers} if headers else dict(self._headers),\n        url=url,\n        data=data,\n        async_requests_mode=async_requests_mode,\n        return_async_id=return_async_id,\n        timeout=timeout if timeout else self._timeout,\n        cancel_at_timeout=cancel_at_timeout,\n        encoding=encoding,\n        idempotent=idempotent,\n        verify_response=verify_response,\n    )\n\n    return response\n</code></pre>"},{"location":"reference/services/restservice/#TM1py.Services.RestService.RestService.PUT","title":"<code>PUT(url, data='', headers=None, async_requests_mode=None, return_async_id=False, timeout=None, cancel_at_timeout=False, encoding='utf-8', idempotent=False, verify_response=True, **kwargs)</code>","text":"<p>Perform a PUT request against TM1 instance</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> required <code>data</code> <code>Union[str, bytes, BytesIO]</code> <p>the payload</p> <code>''</code> <code>headers</code> <code>Dict</code> <p>custom headers</p> <code>None</code> <code>async_requests_mode</code> <code>bool</code> <p>changes internal REST execution mode to avoid 60s timeout on IBM cloud</p> <code>None</code> <code>return_async_id</code> <code>bool</code> <p>If True function will return async_id after initiation and not await the execution</p> <code>False</code> <code>timeout</code> <code>float</code> <p>Number of seconds that the client will wait to receive the first byte.</p> <code>None</code> <code>cancel_at_timeout</code> <code>bool</code> <p>Abort operation in TM1 when timeout is reached</p> <code>False</code> <code>encoding</code> <code>str</code> <code>'utf-8'</code> <p>Returns:</p> Type Description <p>response object or async_id</p> Source code in <code>TM1py/Services/RestService.py</code> <pre><code>def PUT(\n    self,\n    url: str,\n    data: Union[str, bytes, BytesIO] = \"\",\n    headers: Dict = None,\n    async_requests_mode: bool = None,\n    return_async_id: bool = False,\n    timeout: float = None,\n    cancel_at_timeout: bool = False,\n    encoding: str = \"utf-8\",\n    idempotent: bool = False,\n    verify_response: bool = True,\n    **kwargs,\n):\n    \"\"\"Perform a PUT request against TM1 instance\n    :param url:\n    :param data: the payload\n    :param headers: custom headers\n    :param async_requests_mode: changes internal REST execution mode to avoid 60s timeout on IBM cloud\n    :param return_async_id: If True function will return async_id after initiation and not await the execution\n    :param timeout: Number of seconds that the client will wait to receive the first byte.\n    :param cancel_at_timeout: Abort operation in TM1 when timeout is reached\n    :param encoding:\n    :return: response object or async_id\n    \"\"\"\n\n    return self.request(\n        method=\"put\",\n        headers={**self._headers, **headers} if headers else dict(self._headers),\n        url=url,\n        data=data,\n        async_requests_mode=async_requests_mode,\n        return_async_id=return_async_id,\n        timeout=timeout if timeout else self._timeout,\n        cancel_at_timeout=cancel_at_timeout,\n        encoding=encoding,\n        idempotent=idempotent,\n        verify_response=verify_response,\n    )\n</code></pre>"},{"location":"reference/services/restservice/#TM1py.Services.RestService.RestService.__enter__","title":"<code>__enter__()</code>","text":"Source code in <code>TM1py/Services/RestService.py</code> <pre><code>def __enter__(self):\n    return self\n</code></pre>"},{"location":"reference/services/restservice/#TM1py.Services.RestService.RestService.__exit__","title":"<code>__exit__(exception_type, exception_value, traceback)</code>","text":"Source code in <code>TM1py/Services/RestService.py</code> <pre><code>def __exit__(self, exception_type, exception_value, traceback):\n    try:\n        self.logout()\n    except Exception as e:\n        warnings.warn(f\"Logout Failed due to Exception: {e}\")\n</code></pre>"},{"location":"reference/services/restservice/#TM1py.Services.RestService.RestService.add_compact_json_header","title":"<code>add_compact_json_header()</code>","text":"Source code in <code>TM1py/Services/RestService.py</code> <pre><code>def add_compact_json_header(self) -&gt; str:\n    original_header = self.get_http_header(\"Accept\")\n    parts = original_header.split(\";\")\n\n    # Point of insertion is important. Needs to come after application/json\n    parts.insert(1, \"tm1.compact=v0\")\n    modified_header = \";\".join(parts)\n    self.add_http_header(\"Accept\", modified_header)\n\n    return original_header\n</code></pre>"},{"location":"reference/services/restservice/#TM1py.Services.RestService.RestService.add_http_header","title":"<code>add_http_header(key, value)</code>","text":"Source code in <code>TM1py/Services/RestService.py</code> <pre><code>def add_http_header(self, key: str, value: str):\n    self._headers[key] = value\n</code></pre>"},{"location":"reference/services/restservice/#TM1py.Services.RestService.RestService.b64_decode_password","title":"<code>b64_decode_password(encrypted_password)</code>  <code>staticmethod</code>","text":"<p>b64 decoding</p> <p>Parameters:</p> Name Type Description Default <code>encrypted_password</code> <code>str</code> <p>encrypted password with b64</p> required <p>Returns:</p> Type Description <code>str</code> <p>password in plain text</p> Source code in <code>TM1py/Services/RestService.py</code> <pre><code>@staticmethod\ndef b64_decode_password(encrypted_password: str) -&gt; str:\n    \"\"\"b64 decoding\n    :param encrypted_password: encrypted password with b64\n    :return: password in plain text\n    \"\"\"\n    return b64decode(encrypted_password).decode(\"UTF-8\")\n</code></pre>"},{"location":"reference/services/restservice/#TM1py.Services.RestService.RestService.build_response_from_binary_response","title":"<code>build_response_from_binary_response(data)</code>  <code>staticmethod</code>","text":"Source code in <code>TM1py/Services/RestService.py</code> <pre><code>@staticmethod\ndef build_response_from_binary_response(data: bytes) -&gt; Response:\n    urllib_response = RestService.urllib3_response_from_bytes(data)\n\n    adapter = HTTPAdapter()\n    requests_response = adapter.build_response(requests.PreparedRequest(), urllib_response)\n    # actual content of response needs to be set explicitly\n    requests_response._content = urllib_response.data\n\n    return requests_response\n</code></pre>"},{"location":"reference/services/restservice/#TM1py.Services.RestService.RestService.cancel_async_operation","title":"<code>cancel_async_operation(async_id, **kwargs)</code>","text":"Source code in <code>TM1py/Services/RestService.py</code> <pre><code>def cancel_async_operation(self, async_id: str, **kwargs):\n    url = f\"/_async('{async_id}')\"\n    # Use DELETE method which includes reconnect logic, but force sync mode\n    response = self.DELETE(url, async_requests_mode=False, **kwargs)\n    self.verify_response(response)\n</code></pre>"},{"location":"reference/services/restservice/#TM1py.Services.RestService.RestService.cancel_running_operation","title":"<code>cancel_running_operation()</code>","text":"Source code in <code>TM1py/Services/RestService.py</code> <pre><code>def cancel_running_operation(self):\n    monitoring_service = self.get_monitoring_service()\n    threads = monitoring_service.get_active_session_threads(exclude_idle=True)\n\n    # if more than one thread is running in session, operation can not be identified unambiguously\n    if not len(threads) == 1:\n        return\n\n    monitoring_service.cancel_thread(threads[0][\"ID\"])\n</code></pre>"},{"location":"reference/services/restservice/#TM1py.Services.RestService.RestService.connect","title":"<code>connect()</code>","text":"Source code in <code>TM1py/Services/RestService.py</code> <pre><code>def connect(self):\n    if \"session_id\" in self._kwargs:\n        self._set_session_id_cookie()\n    else:\n        self._start_session(\n            user=self._kwargs.get(\"user\", None),\n            password=self._kwargs.get(\"password\", None),\n            namespace=self._kwargs.get(\"namespace\", None),\n            gateway=self._kwargs.get(\"gateway\", None),\n            cam_passport=self._kwargs.get(\"cam_passport\", None),\n            decode_b64=self.translate_to_boolean(self._kwargs.get(\"decode_b64\", False)),\n            integrated_login=self.translate_to_boolean(self._kwargs.get(\"integrated_login\", False)),\n            integrated_login_domain=self._kwargs.get(\"integrated_login_domain\"),\n            integrated_login_service=self._kwargs.get(\"integrated_login_service\"),\n            integrated_login_host=self._kwargs.get(\"integrated_login_host\"),\n            integrated_login_delegate=self._kwargs.get(\"integrated_login_delegate\"),\n            impersonate=self._kwargs.get(\"impersonate\", None),\n            application_client_id=self._kwargs.get(\"application_client_id\", None),\n            application_client_secret=self._kwargs.get(\"application_client_secret\", None),\n        )\n</code></pre>"},{"location":"reference/services/restservice/#TM1py.Services.RestService.RestService.disable_http_warnings","title":"<code>disable_http_warnings()</code>  <code>staticmethod</code>","text":"Source code in <code>TM1py/Services/RestService.py</code> <pre><code>@staticmethod\ndef disable_http_warnings():\n    # disable HTTP verification warnings from requests library\n    requests.packages.urllib3.disable_warnings()\n</code></pre>"},{"location":"reference/services/restservice/#TM1py.Services.RestService.RestService.get_api_metadata","title":"<code>get_api_metadata()</code>","text":"<p>Get API Metadata</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary</p> Source code in <code>TM1py/Services/RestService.py</code> <pre><code>def get_api_metadata(self) -&gt; dict:\n    \"\"\"Get API Metadata\n\n    :return: Dictionary\n    \"\"\"\n    url = \"/$metadata\"\n    metadata = self.GET(url=url).content.decode(\"utf-8\")\n    return json.loads(metadata)\n</code></pre>"},{"location":"reference/services/restservice/#TM1py.Services.RestService.RestService.get_http_header","title":"<code>get_http_header(key)</code>","text":"Source code in <code>TM1py/Services/RestService.py</code> <pre><code>def get_http_header(self, key: str) -&gt; str:\n    return self._headers[key]\n</code></pre>"},{"location":"reference/services/restservice/#TM1py.Services.RestService.RestService.get_monitoring_service","title":"<code>get_monitoring_service()</code>","text":"Source code in <code>TM1py/Services/RestService.py</code> <pre><code>def get_monitoring_service(self):\n    from TM1py.Services import MonitoringService\n\n    return MonitoringService(self)\n</code></pre>"},{"location":"reference/services/restservice/#TM1py.Services.RestService.RestService.handle_logging","title":"<code>handle_logging(logging)</code>","text":"Source code in <code>TM1py/Services/RestService.py</code> <pre><code>def handle_logging(self, logging: Union[str, bool]):\n    if logging:\n        if self.translate_to_boolean(value=logging):\n            http_client.HTTPConnection.debuglevel = 1\n</code></pre>"},{"location":"reference/services/restservice/#TM1py.Services.RestService.RestService.is_connected","title":"<code>is_connected()</code>","text":"<p>Check if Connection to TM1 Server is established. :Returns:     Boolean</p> Source code in <code>TM1py/Services/RestService.py</code> <pre><code>def is_connected(self) -&gt; bool:\n    \"\"\"Check if Connection to TM1 Server is established.\n    :Returns:\n        Boolean\n    \"\"\"\n    try:\n        self.GET(\"/Configuration/ServerName/$value\")\n        return True\n    except Exception:\n        return False\n</code></pre>"},{"location":"reference/services/restservice/#TM1py.Services.RestService.RestService.logout","title":"<code>logout(timeout=None, **kwargs)</code>","text":"<p>End TM1 Session and HTTP session</p> Source code in <code>TM1py/Services/RestService.py</code> <pre><code>def logout(self, timeout: float = None, **kwargs):\n    \"\"\"End TM1 Session and HTTP session\"\"\"\n\n    try:\n        self.POST(\n            \"/ActiveSession/tm1.Close\",\n            \"\",\n            headers={\"Connection\": \"close\"},\n            timeout=timeout,\n            async_requests_mode=False,\n            **kwargs,\n        )\n    finally:\n        self._s.close()\n</code></pre>"},{"location":"reference/services/restservice/#TM1py.Services.RestService.RestService.remove_http_header","title":"<code>remove_http_header(key)</code>","text":"Source code in <code>TM1py/Services/RestService.py</code> <pre><code>def remove_http_header(self, key: str):\n    if key in self._headers:\n        self._headers.pop(key)\n</code></pre>"},{"location":"reference/services/restservice/#TM1py.Services.RestService.RestService.request","title":"<code>request(method, url, data='', encoding='utf-8', async_requests_mode=None, return_async_id=False, timeout=None, cancel_at_timeout=False, idempotent=False, verify_response=True, **kwargs)</code>","text":"<p>Execute a request to TM1 REST API</p> Source code in <code>TM1py/Services/RestService.py</code> <pre><code>def request(\n    self,\n    method: str,\n    url: str,\n    data: str = \"\",\n    encoding=\"utf-8\",\n    async_requests_mode: Optional[bool] = None,\n    return_async_id=False,\n    timeout: float = None,\n    cancel_at_timeout: bool = False,\n    idempotent: bool = False,\n    verify_response: bool = True,\n    **kwargs,\n):\n    \"\"\"\n    Execute a request to TM1 REST API\n    \"\"\"\n    url, data = self._url_and_body(url=url, data=data, encoding=encoding)\n\n    timeout = timeout if timeout else self._timeout\n\n    try:\n        # Determine async mode\n        if return_async_id:\n            async_requests_mode = True\n        elif async_requests_mode is None:\n            async_requests_mode = self._async_requests_mode\n\n        # Execute request based on mode\n        if not async_requests_mode:\n            response = self._execute_sync_request(method=method, url=url, data=data, timeout=timeout, **kwargs)\n        else:\n            response = self._execute_async_request(\n                method=method,\n                url=url,\n                data=data,\n                timeout=timeout,\n                cancel_at_timeout=cancel_at_timeout,\n                return_async_id=return_async_id,\n                **kwargs,\n            )\n\n        # If async_id is returned as string, return it directly\n        if return_async_id and isinstance(response, str):\n            return response\n\n        # Verify and encode response\n        if verify_response:\n            self.verify_response(response=response)\n        response.encoding = encoding\n        return response\n\n    except Timeout:\n        if cancel_at_timeout or (cancel_at_timeout is None and self._cancel_at_timeout):\n            self.cancel_running_operation()\n        raise TM1pyTimeout(method=method, url=url, timeout=timeout)\n\n    except ConnectionError as e:\n        # Handle read timeout issue in requests library\n        if re.search(\"Read timed out\", str(e), re.IGNORECASE):\n            if cancel_at_timeout or (cancel_at_timeout is None and self._cancel_at_timeout):\n                self.cancel_running_operation()\n            raise TM1pyTimeout(method=method, url=url, timeout=timeout)\n\n        # Handle RemoteDisconnected errors\n        elif re.search(\"RemoteDisconnected|Connection aborted\", str(e), re.IGNORECASE):\n            if self._re_connect_on_remote_disconnect:\n                return self._handle_remote_disconnect(\n                    e,\n                    method,\n                    url,\n                    data,\n                    timeout,\n                    idempotent,\n                    async_requests_mode,\n                    cancel_at_timeout,\n                    return_async_id,\n                    encoding,\n                    **kwargs,\n                )\n            else:\n                raise e\n\n        # Other connection errors\n        raise e\n</code></pre>"},{"location":"reference/services/restservice/#TM1py.Services.RestService.RestService.retrieve_async_response","title":"<code>retrieve_async_response(async_id, **kwargs)</code>","text":"Source code in <code>TM1py/Services/RestService.py</code> <pre><code>def retrieve_async_response(self, async_id: str, **kwargs) -&gt; Response:\n    url = f\"/_async('{async_id}')\"\n    # Use GET method which includes reconnect logic, but force sync mode\n    return self.GET(url, async_requests_mode=False, **kwargs)\n</code></pre>"},{"location":"reference/services/restservice/#TM1py.Services.RestService.RestService.set_version","title":"<code>set_version()</code>","text":"Source code in <code>TM1py/Services/RestService.py</code> <pre><code>def set_version(self):\n    url = \"/Configuration/ProductVersion/$value\"\n    response = self.GET(url=url)\n    self._version = response.text\n</code></pre>"},{"location":"reference/services/restservice/#TM1py.Services.RestService.RestService.translate_to_boolean","title":"<code>translate_to_boolean(value)</code>  <code>staticmethod</code>","text":"<p>Takes a boolean or string (eg. true, True, FALSE, etc.) value and returns (boolean) True or False</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <p>True, 'true', 'false' or 'False' ...</p> required <p>Returns:</p> Type Description <code>bool</code> Source code in <code>TM1py/Services/RestService.py</code> <pre><code>@staticmethod\ndef translate_to_boolean(value) -&gt; bool:\n    \"\"\"Takes a boolean or string (eg. true, True, FALSE, etc.) value and returns (boolean) True or False\n    :param value: True, 'true', 'false' or 'False' ...\n    :return:\n    \"\"\"\n    if isinstance(value, bool) or isinstance(value, int):\n        return bool(value)\n    elif isinstance(value, str):\n        return value.replace(\" \", \"\").lower() == \"true\"\n    else:\n        raise ValueError(\"Invalid argument: '\" + value + \"'. Must be to be of type 'bool' or 'str'\")\n</code></pre>"},{"location":"reference/services/restservice/#TM1py.Services.RestService.RestService.urllib3_response_from_bytes","title":"<code>urllib3_response_from_bytes(data)</code>  <code>staticmethod</code>","text":"<p>Build urllib3.HTTPResponse based on raw bytes string</p> Source code in <code>TM1py/Services/RestService.py</code> <pre><code>@staticmethod\ndef urllib3_response_from_bytes(data: bytes) -&gt; HTTPResponse:\n    \"\"\"Build urllib3.HTTPResponse based on raw bytes string\"\"\"\n    sock = BytesIOSocket(data)\n\n    response = HTTPResponse(sock)\n    response.begin()\n\n    headers = response.msg\n    if not isinstance(headers, HTTPHeaderDict):\n        headers = HTTPHeaderDict(headers.items())\n\n    urllib3_http_response = urllib3.HTTPResponse(\n        body=response,\n        headers=headers,\n        status=response.status,\n        version=response.version,\n        reason=response.reason,\n        original_response=response,\n    )\n    return urllib3_http_response\n</code></pre>"},{"location":"reference/services/restservice/#TM1py.Services.RestService.RestService.verify_response","title":"<code>verify_response(response)</code>  <code>staticmethod</code>","text":"<p>check if Status Code is OK :Parameters:     <code>response</code>: String         the response that is returned from a method call :Exceptions:     TM1pyException, raises TM1pyException when Code is not 200, 204 etc.</p> Source code in <code>TM1py/Services/RestService.py</code> <pre><code>@staticmethod\ndef verify_response(response: Response):\n    \"\"\"check if Status Code is OK\n    :Parameters:\n        `response`: String\n            the response that is returned from a method call\n    :Exceptions:\n        TM1pyException, raises TM1pyException when Code is not 200, 204 etc.\n    \"\"\"\n    if not response.ok:\n        raise TM1pyRestException(\n            response.text, status_code=response.status_code, reason=response.reason, headers=response.headers\n        )\n</code></pre>"},{"location":"reference/services/restservice/#TM1py.Services.RestService.RestService.wait_time_generator","title":"<code>wait_time_generator(timeout)</code>","text":"<p>Generate wait times for async polling with capped exponential backoff.</p> <p>Uses configurable parameters: - async_polling_initial_delay: Starting delay - async_polling_max_delay: Maximum delay cap - async_polling_backoff_factor: Multiplier for each iteration</p> <p>Default behavior (0.1s initial, 1.0s max, 2x factor) produces: 0.1s -&gt; 0.2s -&gt; 0.4s -&gt; 0.8s -&gt; 1.0s -&gt; 1.0s -&gt; ...</p> Source code in <code>TM1py/Services/RestService.py</code> <pre><code>def wait_time_generator(self, timeout: float):\n    \"\"\"\n    Generate wait times for async polling with capped exponential backoff.\n\n    Uses configurable parameters:\n    - async_polling_initial_delay: Starting delay\n    - async_polling_max_delay: Maximum delay cap\n    - async_polling_backoff_factor: Multiplier for each iteration\n\n    Default behavior (0.1s initial, 1.0s max, 2x factor) produces:\n    0.1s -&gt; 0.2s -&gt; 0.4s -&gt; 0.8s -&gt; 1.0s -&gt; 1.0s -&gt; ...\n    \"\"\"\n    delay = self._async_polling_initial_delay\n    elapsed = 0.0\n\n    if timeout:\n        while elapsed &lt; timeout:\n            yield delay\n            elapsed += delay\n            delay = min(delay * self._async_polling_backoff_factor, self._async_polling_max_delay)\n    else:\n        while True:\n            yield delay\n            delay = min(delay * self._async_polling_backoff_factor, self._async_polling_max_delay)\n</code></pre>"},{"location":"reference/services/sandboxservice/","title":"SandboxService","text":""},{"location":"reference/services/sandboxservice/#TM1py.Services.SandboxService.SandboxService","title":"<code>SandboxService(rest)</code>","text":"<p>               Bases: <code>ObjectService</code></p> <p>Service to handle sandboxes in TM1</p> Source code in <code>TM1py/Services/SandboxService.py</code> <pre><code>def __init__(self, rest: RestService):\n    super().__init__(rest)\n</code></pre>"},{"location":"reference/services/sandboxservice/#TM1py.Services.SandboxService.SandboxService.create","title":"<code>create(sandbox, **kwargs)</code>","text":"<p>create a new sandbox in TM1 Server</p> <p>Parameters:</p> Name Type Description Default <code>sandbox</code> <code>Sandbox</code> <p>Sandbox</p> required <p>Returns:</p> Type Description <code>Response</code> <p>response</p> Source code in <code>TM1py/Services/SandboxService.py</code> <pre><code>def create(self, sandbox: Sandbox, **kwargs) -&gt; Response:\n    \"\"\"create a new sandbox in TM1 Server\n\n    :param sandbox: Sandbox\n    :return: response\n    \"\"\"\n    url = \"/Sandboxes\"\n    return self._rest.POST(url=url, data=sandbox.body, **kwargs)\n</code></pre>"},{"location":"reference/services/sandboxservice/#TM1py.Services.SandboxService.SandboxService.delete","title":"<code>delete(sandbox_name, **kwargs)</code>","text":"<p>delete a sandbox in TM1</p> <p>Parameters:</p> Name Type Description Default <code>sandbox_name</code> <code>str</code> required <p>Returns:</p> Type Description <code>Response</code> <p>response</p> Source code in <code>TM1py/Services/SandboxService.py</code> <pre><code>def delete(self, sandbox_name: str, **kwargs) -&gt; Response:\n    \"\"\"delete a sandbox in TM1\n\n    :param sandbox_name:\n    :return: response\n    \"\"\"\n    url = format_url(\"/Sandboxes('{}')\", sandbox_name)\n    return self._rest.DELETE(url, **kwargs)\n</code></pre>"},{"location":"reference/services/sandboxservice/#TM1py.Services.SandboxService.SandboxService.exists","title":"<code>exists(sandbox_name, **kwargs)</code>","text":"<p>check if the sandbox exists in TM1</p> <p>Parameters:</p> Name Type Description Default <code>sandbox_name</code> <code>str</code> <p>String</p> required <p>Returns:</p> Type Description <code>bool</code> <p>bool</p> Source code in <code>TM1py/Services/SandboxService.py</code> <pre><code>def exists(self, sandbox_name: str, **kwargs) -&gt; bool:\n    \"\"\"check if the sandbox exists in TM1\n\n    :param sandbox_name: String\n    :return: bool\n    \"\"\"\n    url = format_url(\"/Sandboxes('{}')\", sandbox_name)\n    return self._exists(url, **kwargs)\n</code></pre>"},{"location":"reference/services/sandboxservice/#TM1py.Services.SandboxService.SandboxService.get","title":"<code>get(sandbox_name, **kwargs)</code>","text":"<p>get a sandbox from TM1 Server</p> <p>Parameters:</p> Name Type Description Default <code>sandbox_name</code> <code>str</code> <p>str</p> required <p>Returns:</p> Type Description <code>Sandbox</code> <p>instance of TM1py.Sandbox</p> Source code in <code>TM1py/Services/SandboxService.py</code> <pre><code>def get(self, sandbox_name: str, **kwargs) -&gt; Sandbox:\n    \"\"\"get a sandbox from TM1 Server\n\n    :param sandbox_name: str\n    :return: instance of TM1py.Sandbox\n    \"\"\"\n    url = format_url(\"/Sandboxes('{}')\", sandbox_name)\n    response = self._rest.GET(url=url, **kwargs)\n    sandbox = Sandbox.from_json(response.text)\n    return sandbox\n</code></pre>"},{"location":"reference/services/sandboxservice/#TM1py.Services.SandboxService.SandboxService.get_all","title":"<code>get_all(**kwargs)</code>","text":"<p>get all sandboxes from TM1 Server</p> <p>Returns:</p> Type Description <code>List[Sandbox]</code> <p>List of TM1py.Sandbox instances</p> Source code in <code>TM1py/Services/SandboxService.py</code> <pre><code>def get_all(self, **kwargs) -&gt; List[Sandbox]:\n    \"\"\"get all sandboxes from TM1 Server\n\n    :return: List of TM1py.Sandbox instances\n    \"\"\"\n    url = \"/Sandboxes?$select=Name,IncludeInSandboxDimension,IsLoaded,IsActive,IsQueued\"\n    response = self._rest.GET(url, **kwargs)\n    sandboxes = [Sandbox.from_dict(sandbox_as_dict=sandbox) for sandbox in response.json()[\"value\"]]\n    return sandboxes\n</code></pre>"},{"location":"reference/services/sandboxservice/#TM1py.Services.SandboxService.SandboxService.get_all_names","title":"<code>get_all_names(**kwargs)</code>","text":"<p>get all sandbox names</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>{}</code> <p>Returns:</p> Type Description <code>List[str]</code> Source code in <code>TM1py/Services/SandboxService.py</code> <pre><code>def get_all_names(self, **kwargs) -&gt; List[str]:\n    \"\"\"get all sandbox names\n\n    :param kwargs:\n    :return:\n    \"\"\"\n    url = \"/Sandboxes?$select=Name\"\n    response = self._rest.GET(url, **kwargs)\n    return [entry[\"Name\"] for entry in response.json()[\"value\"]]\n</code></pre>"},{"location":"reference/services/sandboxservice/#TM1py.Services.SandboxService.SandboxService.load","title":"<code>load(sandbox_name, **kwargs)</code>","text":"<p>load sandbox into memory</p> <p>Parameters:</p> Name Type Description Default <code>sandbox_name</code> <code>str</code> <p>str</p> required <p>Returns:</p> Type Description <code>Response</code> <p>response</p> Source code in <code>TM1py/Services/SandboxService.py</code> <pre><code>def load(self, sandbox_name: str, **kwargs) -&gt; Response:\n    \"\"\"load sandbox into memory\n\n    :param sandbox_name: str\n    :return: response\n    \"\"\"\n    url = format_url(\"/Sandboxes('{}')/tm1.Load\", sandbox_name)\n    return self._rest.POST(url=url, **kwargs)\n</code></pre>"},{"location":"reference/services/sandboxservice/#TM1py.Services.SandboxService.SandboxService.merge","title":"<code>merge(source_sandbox_name, target_sandbox_name, clean_after=False, **kwargs)</code>","text":"<p>merge one sandbox into another</p> <p>Parameters:</p> Name Type Description Default <code>source_sandbox_name</code> <code>str</code> <p>str</p> required <code>target_sandbox_name</code> <code>str</code> <p>str</p> required <code>clean_after</code> <code>bool</code> <p>bool: Reset source sandbox after merging</p> <code>False</code> <p>Returns:</p> Type Description <code>Response</code> <p>response</p> Source code in <code>TM1py/Services/SandboxService.py</code> <pre><code>def merge(\n    self, source_sandbox_name: str, target_sandbox_name: str, clean_after: bool = False, **kwargs\n) -&gt; Response:\n    \"\"\"merge one sandbox into another\n\n    :param source_sandbox_name: str\n    :param target_sandbox_name: str\n    :param clean_after: bool: Reset source sandbox after merging\n    :return: response\n    \"\"\"\n    url = format_url(\"/Sandboxes('{}')/tm1.Merge\", source_sandbox_name)\n    payload = dict()\n    payload[\"Target@odata.bind\"] = format_url(\"Sandboxes('{}')\", target_sandbox_name)\n    payload[\"CleanAfter\"] = clean_after\n    return self._rest.POST(url=url, data=json.dumps(payload), **kwargs)\n</code></pre>"},{"location":"reference/services/sandboxservice/#TM1py.Services.SandboxService.SandboxService.publish","title":"<code>publish(sandbox_name, **kwargs)</code>","text":"<p>publish existing sandbox to base</p> <p>Parameters:</p> Name Type Description Default <code>sandbox_name</code> <code>str</code> <p>str</p> required <p>Returns:</p> Type Description <code>Response</code> <p>response</p> Source code in <code>TM1py/Services/SandboxService.py</code> <pre><code>def publish(self, sandbox_name: str, **kwargs) -&gt; Response:\n    \"\"\"publish existing sandbox to base\n\n    :param sandbox_name: str\n    :return: response\n    \"\"\"\n    url = format_url(\"/Sandboxes('{}')/tm1.Publish\", sandbox_name)\n    return self._rest.POST(url=url, **kwargs)\n</code></pre>"},{"location":"reference/services/sandboxservice/#TM1py.Services.SandboxService.SandboxService.reset","title":"<code>reset(sandbox_name, **kwargs)</code>","text":"<p>reset all changes in specified sandbox</p> <p>Parameters:</p> Name Type Description Default <code>sandbox_name</code> <code>str</code> <p>str</p> required <p>Returns:</p> Type Description <code>Response</code> <p>response</p> Source code in <code>TM1py/Services/SandboxService.py</code> <pre><code>def reset(self, sandbox_name: str, **kwargs) -&gt; Response:\n    \"\"\"reset all changes in specified sandbox\n\n    :param sandbox_name: str\n    :return: response\n    \"\"\"\n    url = format_url(\"/Sandboxes('{}')/tm1.DiscardChanges\", sandbox_name)\n    return self._rest.POST(url=url, **kwargs)\n</code></pre>"},{"location":"reference/services/sandboxservice/#TM1py.Services.SandboxService.SandboxService.unload","title":"<code>unload(sandbox_name, **kwargs)</code>","text":"<p>unload sandbox from memory</p> <p>Parameters:</p> Name Type Description Default <code>sandbox_name</code> <code>str</code> <p>str</p> required <p>Returns:</p> Type Description <code>Response</code> <p>response</p> Source code in <code>TM1py/Services/SandboxService.py</code> <pre><code>def unload(self, sandbox_name: str, **kwargs) -&gt; Response:\n    \"\"\"unload sandbox from memory\n\n    :param sandbox_name: str\n    :return: response\n    \"\"\"\n    url = format_url(\"/Sandboxes('{}')/tm1.Unload\", sandbox_name)\n    return self._rest.POST(url=url, **kwargs)\n</code></pre>"},{"location":"reference/services/sandboxservice/#TM1py.Services.SandboxService.SandboxService.update","title":"<code>update(sandbox, **kwargs)</code>","text":"<p>update a sandbox in TM1</p> <p>Parameters:</p> Name Type Description Default <code>sandbox</code> <code>Sandbox</code> required <p>Returns:</p> Type Description <code>Response</code> <p>response</p> Source code in <code>TM1py/Services/SandboxService.py</code> <pre><code>def update(self, sandbox: Sandbox, **kwargs) -&gt; Response:\n    \"\"\"update a sandbox in TM1\n\n    :param sandbox:\n    :return: response\n    \"\"\"\n    url = format_url(\"/Sandboxes('{}')\", sandbox.name)\n    return self._rest.PATCH(url=url, data=sandbox.body, **kwargs)\n</code></pre>"},{"location":"reference/services/securityservice/","title":"SecurityService","text":""},{"location":"reference/services/securityservice/#TM1py.Services.SecurityService.SecurityService","title":"<code>SecurityService(rest)</code>","text":"<p>               Bases: <code>ObjectService</code></p> <p>Service to handle Security stuff</p> Source code in <code>TM1py/Services/SecurityService.py</code> <pre><code>def __init__(self, rest: RestService):\n    super().__init__(rest)\n</code></pre>"},{"location":"reference/services/securityservice/#TM1py.Services.SecurityService.SecurityService.add_user_to_groups","title":"<code>add_user_to_groups(user_name, groups, **kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>user_name</code> <code>str</code> <p>name of user</p> required <code>groups</code> <code>Iterable[str]</code> <p>iterable of groups</p> required <p>Returns:</p> Type Description <code>Response</code> <p>response</p> Source code in <code>TM1py/Services/SecurityService.py</code> <pre><code>@require_security_admin\ndef add_user_to_groups(self, user_name: str, groups: Iterable[str], **kwargs) -&gt; Response:\n    \"\"\"\n\n    :param user_name: name of user\n    :param groups: iterable of groups\n    :return: response\n    \"\"\"\n    user_name = self.determine_actual_user_name(user_name, **kwargs)\n    url = format_url(\"/Users('{}')\", user_name)\n    body = {\n        \"Name\": user_name,\n        \"Groups@odata.bind\": [\n            format_url(\"Groups('{}')\", self.determine_actual_group_name(group)) for group in groups\n        ],\n    }\n    return self._rest.PATCH(url, json.dumps(body), **kwargs)\n</code></pre>"},{"location":"reference/services/securityservice/#TM1py.Services.SecurityService.SecurityService.create_group","title":"<code>create_group(group_name, **kwargs)</code>","text":"<p>Create a Security group in the TM1 Server</p> <p>Parameters:</p> Name Type Description Default <code>group_name</code> <code>str</code> required <p>Returns:</p> Type Description <code>Response</code> Source code in <code>TM1py/Services/SecurityService.py</code> <pre><code>@require_security_admin\ndef create_group(self, group_name: str, **kwargs) -&gt; Response:\n    \"\"\"Create a Security group in the TM1 Server\n\n    :param group_name:\n    :return:\n    \"\"\"\n    url = \"/Groups\"\n    return self._rest.POST(url, json.dumps({\"Name\": group_name}), **kwargs)\n</code></pre>"},{"location":"reference/services/securityservice/#TM1py.Services.SecurityService.SecurityService.create_user","title":"<code>create_user(user, **kwargs)</code>","text":"<p>Create a user on TM1 Server</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>User</code> <p>instance of TM1py.User</p> required <p>Returns:</p> Type Description <code>Response</code> <p>response</p> Source code in <code>TM1py/Services/SecurityService.py</code> <pre><code>@require_security_admin\ndef create_user(self, user: User, **kwargs) -&gt; Response:\n    \"\"\"Create a user on TM1 Server\n\n    :param user: instance of TM1py.User\n    :return: response\n    \"\"\"\n    url = \"/Users\"\n    return self._rest.POST(url, user.body, **kwargs)\n</code></pre>"},{"location":"reference/services/securityservice/#TM1py.Services.SecurityService.SecurityService.delete_group","title":"<code>delete_group(group_name, **kwargs)</code>","text":"<p>Delete a group in the TM1 Server</p> <p>Parameters:</p> Name Type Description Default <code>group_name</code> <code>str</code> required <p>Returns:</p> Type Description <code>Response</code> Source code in <code>TM1py/Services/SecurityService.py</code> <pre><code>@require_security_admin\ndef delete_group(self, group_name: str, **kwargs) -&gt; Response:\n    \"\"\"Delete a group in the TM1 Server\n\n    :param group_name:\n    :return:\n    \"\"\"\n    group_name = self.determine_actual_group_name(group_name, **kwargs)\n    url = format_url(\"/Groups('{}')\", group_name)\n    return self._rest.DELETE(url, **kwargs)\n</code></pre>"},{"location":"reference/services/securityservice/#TM1py.Services.SecurityService.SecurityService.delete_user","title":"<code>delete_user(user_name, **kwargs)</code>","text":"<p>Delete user on TM1 Server</p> <p>Parameters:</p> Name Type Description Default <code>user_name</code> <code>str</code> required <p>Returns:</p> Type Description <code>Response</code> <p>response</p> Source code in <code>TM1py/Services/SecurityService.py</code> <pre><code>@require_security_admin\ndef delete_user(self, user_name: str, **kwargs) -&gt; Response:\n    \"\"\"Delete user on TM1 Server\n\n    :param user_name:\n    :return: response\n    \"\"\"\n    user_name = self.determine_actual_user_name(user_name, **kwargs)\n    url = format_url(\"/Users('{}')\", user_name)\n    return self._rest.DELETE(url, **kwargs)\n</code></pre>"},{"location":"reference/services/securityservice/#TM1py.Services.SecurityService.SecurityService.determine_actual_group_name","title":"<code>determine_actual_group_name(group_name, **kwargs)</code>","text":"Source code in <code>TM1py/Services/SecurityService.py</code> <pre><code>def determine_actual_group_name(self, group_name: str, **kwargs) -&gt; str:\n    return self.determine_actual_object_name(object_class=\"Groups\", object_name=group_name, **kwargs)\n</code></pre>"},{"location":"reference/services/securityservice/#TM1py.Services.SecurityService.SecurityService.determine_actual_user_name","title":"<code>determine_actual_user_name(user_name, **kwargs)</code>","text":"Source code in <code>TM1py/Services/SecurityService.py</code> <pre><code>def determine_actual_user_name(self, user_name: str, **kwargs) -&gt; str:\n    return self.determine_actual_object_name(object_class=\"Users\", object_name=user_name, **kwargs)\n</code></pre>"},{"location":"reference/services/securityservice/#TM1py.Services.SecurityService.SecurityService.get_all_groups","title":"<code>get_all_groups(**kwargs)</code>","text":"<p>Get all groups from TM1 Server</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of strings</p> Source code in <code>TM1py/Services/SecurityService.py</code> <pre><code>def get_all_groups(self, **kwargs) -&gt; List[str]:\n    \"\"\"Get all groups from TM1 Server\n\n    :return: List of strings\n    \"\"\"\n    url = \"/Groups?$select=Name\"\n    response = self._rest.GET(url, **kwargs)\n    groups = [entry[\"Name\"] for entry in response.json()[\"value\"]]\n    return groups\n</code></pre>"},{"location":"reference/services/securityservice/#TM1py.Services.SecurityService.SecurityService.get_all_user_names","title":"<code>get_all_user_names(**kwargs)</code>","text":"<p>Get all user names from TM1 Server</p> <p>Returns:</p> Type Description <p>List of TM1py.User instances</p> Source code in <code>TM1py/Services/SecurityService.py</code> <pre><code>def get_all_user_names(self, **kwargs):\n    \"\"\"Get all user names from TM1 Server\n\n    :return: List of TM1py.User instances\n    \"\"\"\n    url = \"/Users?select=Name\"\n    response = self._rest.GET(url, **kwargs)\n    users = [user[\"Name\"] for user in response.json()[\"value\"]]\n    return users\n</code></pre>"},{"location":"reference/services/securityservice/#TM1py.Services.SecurityService.SecurityService.get_all_users","title":"<code>get_all_users(**kwargs)</code>","text":"<p>Get all users from TM1 Server</p> <p>Returns:</p> Type Description <p>List of TM1py.User instances</p> Source code in <code>TM1py/Services/SecurityService.py</code> <pre><code>def get_all_users(self, **kwargs):\n    \"\"\"Get all users from TM1 Server\n\n    :return: List of TM1py.User instances\n    \"\"\"\n    url = \"/Users?$select=Name,FriendlyName,Password,Type,Enabled&amp;$expand=Groups\"\n    response = self._rest.GET(url, **kwargs)\n    users = [User.from_dict(user) for user in response.json()[\"value\"]]\n    return users\n</code></pre>"},{"location":"reference/services/securityservice/#TM1py.Services.SecurityService.SecurityService.get_current_user","title":"<code>get_current_user(**kwargs)</code>","text":"<p>Get user and group assignments of this session</p> <p>Returns:</p> Type Description <code>User</code> <p>instance of TM1py.User</p> Source code in <code>TM1py/Services/SecurityService.py</code> <pre><code>def get_current_user(self, **kwargs) -&gt; User:\n    \"\"\"Get user and group assignments of this session\n\n    :return: instance of TM1py.User\n    \"\"\"\n    url = \"/ActiveUser?$select=Name,FriendlyName,Password,Type,Enabled&amp;$expand=Groups\"\n    response = self._rest.GET(url, **kwargs)\n    return User.from_dict(response.json())\n</code></pre>"},{"location":"reference/services/securityservice/#TM1py.Services.SecurityService.SecurityService.get_custom_security_groups","title":"<code>get_custom_security_groups(**kwargs)</code>","text":"Source code in <code>TM1py/Services/SecurityService.py</code> <pre><code>def get_custom_security_groups(self, **kwargs) -&gt; List[str]:\n    custom_groups = CaseAndSpaceInsensitiveSet(*self.get_all_groups(**kwargs))\n    custom_groups.discard(\"Admin\")\n    custom_groups.discard(\"DataAdmin\")\n    custom_groups.discard(\"SecurityAdmin\")\n    custom_groups.discard(\"OperationsAdmin\")\n    custom_groups.discard(\"}tp_Everyone\")\n\n    return list(custom_groups)\n</code></pre>"},{"location":"reference/services/securityservice/#TM1py.Services.SecurityService.SecurityService.get_groups","title":"<code>get_groups(user_name, **kwargs)</code>","text":"<p>Get the groups of a user in TM1 Server</p> <p>Parameters:</p> Name Type Description Default <code>user_name</code> <code>str</code> required <p>Returns:</p> Type Description <code>List[str]</code> <p>List of strings</p> Source code in <code>TM1py/Services/SecurityService.py</code> <pre><code>def get_groups(self, user_name: str, **kwargs) -&gt; List[str]:\n    \"\"\"Get the groups of a user in TM1 Server\n\n    :param user_name:\n    :return: List of strings\n    \"\"\"\n    user_name = self.determine_actual_user_name(user_name, **kwargs)\n    url = format_url(\"/Users('{}')/Groups\", user_name)\n    response = self._rest.GET(url, **kwargs)\n    return [group[\"Name\"] for group in response.json()[\"value\"]]\n</code></pre>"},{"location":"reference/services/securityservice/#TM1py.Services.SecurityService.SecurityService.get_read_only_users","title":"<code>get_read_only_users(**kwargs)</code>","text":"Source code in <code>TM1py/Services/SecurityService.py</code> <pre><code>def get_read_only_users(self, **kwargs) -&gt; List[str]:\n    read_only_users = list()\n\n    mdx = \"\"\"\n    SELECT\n    {[}ClientProperties].[ReadOnlyUser]} ON COLUMNS,\n    NON EMPTY {[}Clients].MEMBERS} ON ROWS\n    FROM [}ClientProperties]\n    \"\"\"\n\n    from TM1py import CellService\n\n    cell_service = CellService(self._rest)\n\n    users_with_flag = cell_service.execute_mdx_rows_and_values(mdx=mdx, element_unique_names=False, **kwargs)\n\n    for row, values in users_with_flag.items():\n        user = row[0]\n        read_only = values[0]\n        if read_only:\n            read_only_users.append(user)\n    return read_only_users\n</code></pre>"},{"location":"reference/services/securityservice/#TM1py.Services.SecurityService.SecurityService.get_user","title":"<code>get_user(user_name, **kwargs)</code>","text":"<p>Get user from TM1 Server</p> <p>Parameters:</p> Name Type Description Default <code>user_name</code> <code>str</code> required <p>Returns:</p> Type Description <code>User</code> <p>instance of TM1py.User</p> Source code in <code>TM1py/Services/SecurityService.py</code> <pre><code>def get_user(self, user_name: str, **kwargs) -&gt; User:\n    \"\"\"Get user from TM1 Server\n\n    :param user_name:\n    :return: instance of TM1py.User\n    \"\"\"\n    user_name = self.determine_actual_user_name(user_name, **kwargs)\n    url = format_url(\"/Users('{}')?$select=Name,FriendlyName,Password,Type,Enabled&amp;$expand=Groups\", user_name)\n    response = self._rest.GET(url, **kwargs)\n    return User.from_dict(response.json())\n</code></pre>"},{"location":"reference/services/securityservice/#TM1py.Services.SecurityService.SecurityService.get_user_names_from_group","title":"<code>get_user_names_from_group(group_name, **kwargs)</code>","text":"<p>Get all users from group</p> <p>Parameters:</p> Name Type Description Default <code>group_name</code> <code>str</code> required <p>Returns:</p> Type Description <code>List[str]</code> <p>List of strings</p> Source code in <code>TM1py/Services/SecurityService.py</code> <pre><code>def get_user_names_from_group(self, group_name: str, **kwargs) -&gt; List[str]:\n    \"\"\"Get all users from group\n\n    :param group_name:\n    :return: List of strings\n    \"\"\"\n    url = format_url(\"/Groups('{}')?$expand=Users($expand=Groups)\", group_name)\n    response = self._rest.GET(url, **kwargs)\n    users = [user[\"Name\"] for user in response.json()[\"Users\"]]\n    return users\n</code></pre>"},{"location":"reference/services/securityservice/#TM1py.Services.SecurityService.SecurityService.get_users_from_group","title":"<code>get_users_from_group(group_name, **kwargs)</code>","text":"<p>Get all users from group</p> <p>Parameters:</p> Name Type Description Default <code>group_name</code> <code>str</code> required <p>Returns:</p> Type Description <p>List of TM1py.User instances</p> Source code in <code>TM1py/Services/SecurityService.py</code> <pre><code>def get_users_from_group(self, group_name: str, **kwargs):\n    \"\"\"Get all users from group\n\n    :param group_name:\n    :return: List of TM1py.User instances\n    \"\"\"\n    url = format_url(\n        \"/Groups('{}')?$expand=Users($select=Name,FriendlyName,Password,Type,Enabled;$expand=Groups)\", group_name\n    )\n    response = self._rest.GET(url, **kwargs)\n    users = [User.from_dict(user) for user in response.json()[\"Users\"]]\n    return users\n</code></pre>"},{"location":"reference/services/securityservice/#TM1py.Services.SecurityService.SecurityService.group_exists","title":"<code>group_exists(group_name, **kwargs)</code>","text":"Source code in <code>TM1py/Services/SecurityService.py</code> <pre><code>def group_exists(self, group_name: str, **kwargs) -&gt; bool:\n    url = format_url(\"/Groups('{}')\", group_name)\n    return self._exists(url, **kwargs)\n</code></pre>"},{"location":"reference/services/securityservice/#TM1py.Services.SecurityService.SecurityService.remove_user_from_group","title":"<code>remove_user_from_group(group_name, user_name, **kwargs)</code>","text":"<p>Remove user from group in TM1 Server</p> <p>Parameters:</p> Name Type Description Default <code>group_name</code> <code>str</code> required <code>user_name</code> <code>str</code> required <p>Returns:</p> Type Description <code>Response</code> <p>response</p> Source code in <code>TM1py/Services/SecurityService.py</code> <pre><code>@require_security_admin\ndef remove_user_from_group(self, group_name: str, user_name: str, **kwargs) -&gt; Response:\n    \"\"\"Remove user from group in TM1 Server\n\n    :param group_name:\n    :param user_name:\n    :return: response\n    \"\"\"\n    user_name = self.determine_actual_user_name(user_name, **kwargs)\n    group_name = self.determine_actual_group_name(group_name, **kwargs)\n    url = format_url(\"/Users('{}')/Groups?$id=Groups('{}')\", user_name, group_name)\n    return self._rest.DELETE(url, **kwargs)\n</code></pre>"},{"location":"reference/services/securityservice/#TM1py.Services.SecurityService.SecurityService.security_refresh","title":"<code>security_refresh(**kwargs)</code>","text":"Source code in <code>TM1py/Services/SecurityService.py</code> <pre><code>@require_admin\ndef security_refresh(self, **kwargs) -&gt; Response:\n    from TM1py.Services import ProcessService\n\n    ti = \"SecurityRefresh;\"\n    process_service = ProcessService(self._rest)\n    return process_service.execute_ti_code(ti, **kwargs)\n</code></pre>"},{"location":"reference/services/securityservice/#TM1py.Services.SecurityService.SecurityService.update_user","title":"<code>update_user(user, **kwargs)</code>","text":"<p>Update user on TM1 Server</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>User</code> <p>instance of TM1py.User</p> required <p>Returns:</p> Type Description <code>Response</code> <p>response</p> Source code in <code>TM1py/Services/SecurityService.py</code> <pre><code>@require_security_admin\ndef update_user(self, user: User, **kwargs) -&gt; Response:\n    \"\"\"Update user on TM1 Server\n\n    :param user: instance of TM1py.User\n    :return: response\n    \"\"\"\n    user.name = self.determine_actual_user_name(user.name, **kwargs)\n    for current_group in self.get_groups(user.name, **kwargs):\n        if current_group not in user.groups:\n            self.remove_user_from_group(current_group, user.name, **kwargs)\n    url = format_url(\"/Users('{}')\", user.name)\n    return self._rest.PATCH(url, user.body, **kwargs)\n</code></pre>"},{"location":"reference/services/securityservice/#TM1py.Services.SecurityService.SecurityService.update_user_password","title":"<code>update_user_password(user_name, password, **kwargs)</code>","text":"Source code in <code>TM1py/Services/SecurityService.py</code> <pre><code>def update_user_password(self, user_name: str, password: str, **kwargs) -&gt; Response:\n    url = format_url(\"/Users('{}')\", user_name)\n    body = {\"Password\": password}\n    return self._rest.PATCH(url, json.dumps(body), **kwargs)\n</code></pre>"},{"location":"reference/services/securityservice/#TM1py.Services.SecurityService.SecurityService.user_exists","title":"<code>user_exists(user_name, **kwargs)</code>","text":"Source code in <code>TM1py/Services/SecurityService.py</code> <pre><code>def user_exists(self, user_name: str, **kwargs) -&gt; bool:\n    url = format_url(\"/Users('{}')\", user_name)\n    return self._exists(url, **kwargs)\n</code></pre>"},{"location":"reference/services/serverservice/","title":"ServerService","text":""},{"location":"reference/services/serverservice/#TM1py.Services.ServerService.LogLevel","title":"<code>LogLevel</code>","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"reference/services/serverservice/#TM1py.Services.ServerService.LogLevel.DEBUG","title":"<code>DEBUG = 'debug'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/services/serverservice/#TM1py.Services.ServerService.LogLevel.ERROR","title":"<code>ERROR = 'error'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/services/serverservice/#TM1py.Services.ServerService.LogLevel.FATAL","title":"<code>FATAL = 'fatal'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/services/serverservice/#TM1py.Services.ServerService.LogLevel.INFO","title":"<code>INFO = 'info'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/services/serverservice/#TM1py.Services.ServerService.LogLevel.OFF","title":"<code>OFF = 'off'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/services/serverservice/#TM1py.Services.ServerService.LogLevel.WARNING","title":"<code>WARNING = 'warning'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/services/serverservice/#TM1py.Services.ServerService.ServerService","title":"<code>ServerService(rest)</code>","text":"<p>               Bases: <code>ObjectService</code></p> <p>Service to query common information from the TM1 Server</p> Source code in <code>TM1py/Services/ServerService.py</code> <pre><code>def __init__(self, rest: RestService):\n    super().__init__(rest)\n    warn(\"Server Service will be moved to a new location in a future version\", DeprecationWarning, 2)\n    self.transaction_logs = TransactionLogService(rest)\n    self.message_logs = MessageLogService(rest)\n    self.configuration = ConfigurationService(rest)\n    self.audit_logs = AuditLogService(rest)\n    self.loggers = LoggerService(rest)\n</code></pre>"},{"location":"reference/services/serverservice/#TM1py.Services.ServerService.ServerService.audit_logs","title":"<code>audit_logs = AuditLogService(rest)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/services/serverservice/#TM1py.Services.ServerService.ServerService.configuration","title":"<code>configuration = ConfigurationService(rest)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/services/serverservice/#TM1py.Services.ServerService.ServerService.loggers","title":"<code>loggers = LoggerService(rest)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/services/serverservice/#TM1py.Services.ServerService.ServerService.message_logs","title":"<code>message_logs = MessageLogService(rest)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/services/serverservice/#TM1py.Services.ServerService.ServerService.transaction_logs","title":"<code>transaction_logs = TransactionLogService(rest)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/services/serverservice/#TM1py.Services.ServerService.ServerService.activate_audit_log","title":"<code>activate_audit_log()</code>","text":"Source code in <code>TM1py/Services/ServerService.py</code> <pre><code>def activate_audit_log(self):\n    self.audit_logs.activate()\n</code></pre>"},{"location":"reference/services/serverservice/#TM1py.Services.ServerService.ServerService.deactivate_audit_log","title":"<code>deactivate_audit_log()</code>","text":"Source code in <code>TM1py/Services/ServerService.py</code> <pre><code>@require_ops_admin\ndef deactivate_audit_log(self):\n    config = {\"Administration\": {\"AuditLog\": {\"Enable\": False}}}\n    self.update_static_configuration(config)\n</code></pre>"},{"location":"reference/services/serverservice/#TM1py.Services.ServerService.ServerService.delete_persistent_feeders","title":"<code>delete_persistent_feeders(**kwargs)</code>","text":"Source code in <code>TM1py/Services/ServerService.py</code> <pre><code>@require_data_admin\ndef delete_persistent_feeders(self, **kwargs) -&gt; Response:\n    from TM1py.Services import ProcessService\n\n    ti = \"DeleteAllPersistentFeeders;\"\n    process_service = ProcessService(self._rest)\n    return process_service.execute_ti_code(ti, **kwargs)\n</code></pre>"},{"location":"reference/services/serverservice/#TM1py.Services.ServerService.ServerService.execute_audit_log_delta_request","title":"<code>execute_audit_log_delta_request(**kwargs)</code>","text":"Source code in <code>TM1py/Services/ServerService.py</code> <pre><code>def execute_audit_log_delta_request(self, **kwargs) -&gt; Dict:\n    return self.audit_logs.execute_delta_request(**kwargs)\n</code></pre>"},{"location":"reference/services/serverservice/#TM1py.Services.ServerService.ServerService.execute_message_log_delta_request","title":"<code>execute_message_log_delta_request(**kwargs)</code>","text":"Source code in <code>TM1py/Services/ServerService.py</code> <pre><code>def execute_message_log_delta_request(self, **kwargs) -&gt; Dict:\n    return self.message_logs.execute_delta_request(**kwargs)\n</code></pre>"},{"location":"reference/services/serverservice/#TM1py.Services.ServerService.ServerService.execute_transaction_log_delta_request","title":"<code>execute_transaction_log_delta_request(**kwargs)</code>","text":"Source code in <code>TM1py/Services/ServerService.py</code> <pre><code>def execute_transaction_log_delta_request(self, **kwargs) -&gt; Dict:\n    return self.transaction_logs.execute_delta_request(**kwargs)\n</code></pre>"},{"location":"reference/services/serverservice/#TM1py.Services.ServerService.ServerService.get_active_configuration","title":"<code>get_active_configuration(**kwargs)</code>","text":"<p>Read effective(!) TM1 config settings as dictionary from TM1 Server</p> <p>Returns:</p> Type Description <code>Dict</code> <p>config as dictionary</p> Source code in <code>TM1py/Services/ServerService.py</code> <pre><code>def get_active_configuration(self, **kwargs) -&gt; Dict:\n    \"\"\"Read effective(!) TM1 config settings as dictionary from TM1 Server\n\n    :return: config as dictionary\n    \"\"\"\n    return self.configuration.get_active()\n</code></pre>"},{"location":"reference/services/serverservice/#TM1py.Services.ServerService.ServerService.get_admin_host","title":"<code>get_admin_host(**kwargs)</code>","text":"Source code in <code>TM1py/Services/ServerService.py</code> <pre><code>def get_admin_host(self, **kwargs) -&gt; str:\n    return self.configuration.get_admin_host()\n</code></pre>"},{"location":"reference/services/serverservice/#TM1py.Services.ServerService.ServerService.get_all_message_logger_level","title":"<code>get_all_message_logger_level()</code>","text":"<p>Get all tm1 message loggers</p> <p>Returns:</p> Type Description Source code in <code>TM1py/Services/ServerService.py</code> <pre><code>@require_admin\ndef get_all_message_logger_level(self):\n    \"\"\"\n    Get all tm1 message loggers\n\n    :return:\n    \"\"\"\n\n    return self.loggers.get_all()\n</code></pre>"},{"location":"reference/services/serverservice/#TM1py.Services.ServerService.ServerService.get_api_metadata","title":"<code>get_api_metadata()</code>","text":"<p>Read effective(!) TM1 config settings as dictionary from TM1 Server</p> <p>Returns:</p> Type Description <p>config as dictionary</p> Source code in <code>TM1py/Services/ServerService.py</code> <pre><code>def get_api_metadata(self):\n    \"\"\"Read effective(!) TM1 config settings as dictionary from TM1 Server\n\n    :return: config as dictionary\n    \"\"\"\n    return self._rest.get_api_metadata()\n</code></pre>"},{"location":"reference/services/serverservice/#TM1py.Services.ServerService.ServerService.get_audit_log_entries","title":"<code>get_audit_log_entries(user=None, object_type=None, object_name=None, since=None, until=None, top=None, **kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>user</code> <code>str</code> <p>UserName</p> <code>None</code> <code>object_type</code> <code>str</code> <p>ObjectType</p> <code>None</code> <code>object_name</code> <code>str</code> <p>ObjectName</p> <code>None</code> <code>since</code> <code>datetime</code> <p>of type datetime. If it doesn't have tz information, UTC is assumed.</p> <code>None</code> <code>until</code> <code>datetime</code> <p>of type datetime. If it doesn't have tz information, UTC is assumed.</p> <code>None</code> <code>top</code> <code>int</code> <p>int</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict</code> Source code in <code>TM1py/Services/ServerService.py</code> <pre><code>@require_data_admin\n@deprecated_in_version(version=\"12.0.0\")\n@require_version(version=\"11.6\")\ndef get_audit_log_entries(\n    self,\n    user: str = None,\n    object_type: str = None,\n    object_name: str = None,\n    since: datetime = None,\n    until: datetime = None,\n    top: int = None,\n    **kwargs,\n) -&gt; Dict:\n    \"\"\"\n    :param user: UserName\n    :param object_type: ObjectType\n    :param object_name: ObjectName\n    :param since: of type datetime. If it doesn't have tz information, UTC is assumed.\n    :param until: of type datetime. If it doesn't have tz information, UTC is assumed.\n    :param top: int\n    :return:\n    \"\"\"\n    return self.audit_logs.get_entries(\n        user=user, object_type=object_type, object_name=object_name, since=since, until=until, top=top, **kwargs\n    )\n</code></pre>"},{"location":"reference/services/serverservice/#TM1py.Services.ServerService.ServerService.get_configuration","title":"<code>get_configuration(**kwargs)</code>","text":"Source code in <code>TM1py/Services/ServerService.py</code> <pre><code>def get_configuration(self, **kwargs) -&gt; Dict:\n    return self.configuration.get_all()\n</code></pre>"},{"location":"reference/services/serverservice/#TM1py.Services.ServerService.ServerService.get_data_directory","title":"<code>get_data_directory(**kwargs)</code>","text":"Source code in <code>TM1py/Services/ServerService.py</code> <pre><code>def get_data_directory(self, **kwargs) -&gt; str:\n    return self.configuration.get_data_directory()\n</code></pre>"},{"location":"reference/services/serverservice/#TM1py.Services.ServerService.ServerService.get_last_process_message_from_message_log","title":"<code>get_last_process_message_from_message_log(process_name, **kwargs)</code>","text":"<p>Get the latest message log entry for a process</p> <p>Parameters:</p> Name Type Description Default <code>process_name</code> <code>str</code> <p>name of the process</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>String - the message, for instance: \"Ausf\u00fchrung normal beendet, verstrichene Zeit 0.03  Sekunden\"</p> Source code in <code>TM1py/Services/ServerService.py</code> <pre><code>@require_ops_admin\n@deprecated_in_version(version=\"12.0.0\")\ndef get_last_process_message_from_message_log(self, process_name: str, **kwargs) -&gt; Optional[str]:\n    \"\"\"Get the latest message log entry for a process\n\n    :param process_name: name of the process\n    :return: String - the message, for instance: \"Ausf\u00fchrung normal beendet, verstrichene Zeit 0.03  Sekunden\"\n    \"\"\"\n    self.message_logs.get_last_process_message(process_name, **kwargs)\n</code></pre>"},{"location":"reference/services/serverservice/#TM1py.Services.ServerService.ServerService.get_message_log_entries","title":"<code>get_message_log_entries(reverse=True, since=None, until=None, top=None, logger=None, level=None, msg_contains=None, msg_contains_operator='and', **kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>reverse</code> <code>bool</code> <p>Boolean</p> <code>True</code> <code>since</code> <code>datetime</code> <p>of type datetime. If it doesn't have tz information, UTC is assumed.</p> <code>None</code> <code>until</code> <code>datetime</code> <p>of type datetime. If it doesn't have tz information, UTC is assumed.</p> <code>None</code> <code>top</code> <code>int</code> <p>Integer</p> <code>None</code> <code>logger</code> <code>str</code> <p>string, eg TM1.Server, TM1.Chore, TM1.Mdx.Interface, TM1.Process</p> <code>None</code> <code>level</code> <code>str</code> <p>string, ERROR, WARNING, INFO, DEBUG, UNKNOWN</p> <code>None</code> <code>msg_contains</code> <code>Iterable</code> <p>iterable, find substring in log message; list of substrings will be queried as AND statement</p> <code>None</code> <code>msg_contains_operator</code> <code>str</code> <p>'and' or 'or'</p> <code>'and'</code> <code>kwargs</code> <code>{}</code> <p>Returns:</p> Type Description <code>Dict</code> <p>Dict of server log</p> Source code in <code>TM1py/Services/ServerService.py</code> <pre><code>@deprecated_in_version(version=\"12.0.0\")\n@require_ops_admin\ndef get_message_log_entries(\n    self,\n    reverse: bool = True,\n    since: datetime = None,\n    until: datetime = None,\n    top: int = None,\n    logger: str = None,\n    level: str = None,\n    msg_contains: Iterable = None,\n    msg_contains_operator: str = \"and\",\n    **kwargs,\n) -&gt; Dict:\n    \"\"\"\n    :param reverse: Boolean\n    :param since: of type datetime. If it doesn't have tz information, UTC is assumed.\n    :param until: of type datetime. If it doesn't have tz information, UTC is assumed.\n    :param top: Integer\n    :param logger: string, eg TM1.Server, TM1.Chore, TM1.Mdx.Interface, TM1.Process\n    :param level: string, ERROR, WARNING, INFO, DEBUG, UNKNOWN\n    :param msg_contains: iterable, find substring in log message; list of substrings will be queried as AND statement\n    :param msg_contains_operator: 'and' or 'or'\n\n    :param kwargs:\n    :return: Dict of server log\n    \"\"\"\n\n    return self.message_logs.get_entries(\n        reverse=reverse,\n        since=since,\n        until=until,\n        top=top,\n        logger=logger,\n        level=level,\n        msg_contains=msg_contains,\n        msg_contains_operator=msg_contains_operator,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/services/serverservice/#TM1py.Services.ServerService.ServerService.get_product_version","title":"<code>get_product_version(**kwargs)</code>","text":"<p>Ask TM1 Server for its version</p> <p>:Returns:     String, the version</p> Source code in <code>TM1py/Services/ServerService.py</code> <pre><code>def get_product_version(self, **kwargs) -&gt; str:\n    \"\"\"Ask TM1 Server for its version\n\n    :Returns:\n        String, the version\n    \"\"\"\n    return self.configuration.get_product_version()\n</code></pre>"},{"location":"reference/services/serverservice/#TM1py.Services.ServerService.ServerService.get_server_name","title":"<code>get_server_name(**kwargs)</code>","text":"<p>Ask TM1 Server for its name</p> <p>:Returns:     String, the server name</p> Source code in <code>TM1py/Services/ServerService.py</code> <pre><code>def get_server_name(self, **kwargs) -&gt; str:\n    \"\"\"Ask TM1 Server for its name\n\n    :Returns:\n        String, the server name\n    \"\"\"\n    return self.configuration.get_server_name()\n</code></pre>"},{"location":"reference/services/serverservice/#TM1py.Services.ServerService.ServerService.get_static_configuration","title":"<code>get_static_configuration(**kwargs)</code>","text":"Source code in <code>TM1py/Services/ServerService.py</code> <pre><code>def get_static_configuration(self, **kwargs) -&gt; Dict:\n    return self.configuration.get_static()\n</code></pre>"},{"location":"reference/services/serverservice/#TM1py.Services.ServerService.ServerService.get_transaction_log_entries","title":"<code>get_transaction_log_entries(reverse=True, user=None, cube=None, since=None, until=None, top=None, element_tuple_filter=None, element_position_filter=None, **kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>reverse</code> <code>bool</code> <p>Boolean</p> <code>True</code> <code>user</code> <code>str</code> <p>UserName</p> <code>None</code> <code>cube</code> <code>str</code> <p>CubeName</p> <code>None</code> <code>since</code> <code>datetime</code> <p>of type datetime. If it doesn't have tz information, UTC is assumed.</p> <code>None</code> <code>until</code> <code>datetime</code> <p>of type datetime. If it doesn't have tz information, UTC is assumed.</p> <code>None</code> <code>top</code> <code>int</code> <p>int</p> <code>None</code> <code>element_tuple_filter</code> <code>Dict[str, str]</code> <p>of type dict. Element name as key and comparison operator as value</p> <code>None</code> <code>element_position_filter</code> <code>Dict[int, Dict[str, str]]</code> <p>not yet implemented tuple={'Actual':'eq','2020': 'ge'}</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict</code> Source code in <code>TM1py/Services/ServerService.py</code> <pre><code>@deprecated_in_version(version=\"12.0.0\")\n@require_admin\ndef get_transaction_log_entries(\n    self,\n    reverse: bool = True,\n    user: str = None,\n    cube: str = None,\n    since: datetime = None,\n    until: datetime = None,\n    top: int = None,\n    element_tuple_filter: Dict[str, str] = None,\n    element_position_filter: Dict[int, Dict[str, str]] = None,\n    **kwargs,\n) -&gt; Dict:\n    \"\"\"\n    :param reverse: Boolean\n    :param user: UserName\n    :param cube: CubeName\n    :param since: of type datetime. If it doesn't have tz information, UTC is assumed.\n    :param until: of type datetime. If it doesn't have tz information, UTC is assumed.\n    :param top: int\n    :param element_tuple_filter: of type dict. Element name as key and comparison operator as value\n    :param element_position_filter: not yet implemented\n    tuple={'Actual':'eq','2020': 'ge'}\n    :return:\n    \"\"\"\n    return self.transaction_logs.get_entries(\n        reverse=reverse,\n        user=user,\n        cube=cube,\n        since=since,\n        until=until,\n        top=top,\n        element_tuple_filter=element_tuple_filter,\n        element_position_filter=element_position_filter,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/services/serverservice/#TM1py.Services.ServerService.ServerService.initialize_audit_log_delta_requests","title":"<code>initialize_audit_log_delta_requests(filter=None, **kwargs)</code>","text":"Source code in <code>TM1py/Services/ServerService.py</code> <pre><code>def initialize_audit_log_delta_requests(self, filter=None, **kwargs):\n    return self.audit_logs.initialize_delta_requests(filter, **kwargs)\n</code></pre>"},{"location":"reference/services/serverservice/#TM1py.Services.ServerService.ServerService.initialize_message_log_delta_requests","title":"<code>initialize_message_log_delta_requests(filter=None, **kwargs)</code>","text":"Source code in <code>TM1py/Services/ServerService.py</code> <pre><code>def initialize_message_log_delta_requests(self, filter=None, **kwargs):\n    return self.message_logs.initialize_delta_requests(filter, **kwargs)\n</code></pre>"},{"location":"reference/services/serverservice/#TM1py.Services.ServerService.ServerService.initialize_transaction_log_delta_requests","title":"<code>initialize_transaction_log_delta_requests(filter=None, **kwargs)</code>","text":"Source code in <code>TM1py/Services/ServerService.py</code> <pre><code>def initialize_transaction_log_delta_requests(self, filter=None, **kwargs):\n    return self.transaction_logs.initialize_delta_requests(filter, **kwargs)\n</code></pre>"},{"location":"reference/services/serverservice/#TM1py.Services.ServerService.ServerService.save_data","title":"<code>save_data(**kwargs)</code>","text":"Source code in <code>TM1py/Services/ServerService.py</code> <pre><code>@deprecated_in_version(version=\"12.0.0\")\n@require_data_admin\ndef save_data(self, **kwargs) -&gt; Response:\n    from TM1py.Services import ProcessService\n\n    ti = \"SaveDataAll;\"\n    process_service = ProcessService(self._rest)\n    return process_service.execute_ti_code(ti, **kwargs)\n</code></pre>"},{"location":"reference/services/serverservice/#TM1py.Services.ServerService.ServerService.start_performance_monitor","title":"<code>start_performance_monitor()</code>","text":"Source code in <code>TM1py/Services/ServerService.py</code> <pre><code>def start_performance_monitor(self):\n    config = {\"Administration\": {\"PerformanceMonitorOn\": True}}\n    self.configuration.update_static(config)\n</code></pre>"},{"location":"reference/services/serverservice/#TM1py.Services.ServerService.ServerService.stop_performance_monitor","title":"<code>stop_performance_monitor()</code>","text":"Source code in <code>TM1py/Services/ServerService.py</code> <pre><code>def stop_performance_monitor(self):\n    config = {\"Administration\": {\"PerformanceMonitorOn\": False}}\n    self.configuration.update_static(config)\n</code></pre>"},{"location":"reference/services/serverservice/#TM1py.Services.ServerService.ServerService.update_message_logger_level","title":"<code>update_message_logger_level(logger, level)</code>","text":"<p>Updates tm1 message log levels</p> <p>Parameters:</p> Name Type Description Default <code>logger</code> required <code>level</code> required <p>Returns:</p> Type Description Source code in <code>TM1py/Services/ServerService.py</code> <pre><code>@require_admin\ndef update_message_logger_level(self, logger, level):\n    \"\"\"\n    Updates tm1 message log levels\n    :param logger:\n    :param level:\n    :return:\n    \"\"\"\n\n    return self.loggers.set_level(logger, level)\n</code></pre>"},{"location":"reference/services/serverservice/#TM1py.Services.ServerService.ServerService.update_static_configuration","title":"<code>update_static_configuration(configuration)</code>","text":"<p>Update the .cfg file and triggers TM1 to re-read the file.</p> <p>Parameters:</p> Name Type Description Default <code>configuration</code> <code>Dict</code> required <p>Returns:</p> Type Description <code>Response</code> <p>Response</p> Source code in <code>TM1py/Services/ServerService.py</code> <pre><code>def update_static_configuration(self, configuration: Dict) -&gt; Response:\n    \"\"\"Update the .cfg file and triggers TM1 to re-read the file.\n\n    :param configuration:\n    :return: Response\n    \"\"\"\n    return self.configuration.update_static(configuration)\n</code></pre>"},{"location":"reference/services/serverservice/#TM1py.Services.ServerService.ServerService.write_to_message_log","title":"<code>write_to_message_log(level, message, **kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>level</code> <code>str</code> <p>string, FATAL, ERROR, WARN, INFO, DEBUG</p> required <code>message</code> <code>str</code> <p>string</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>TM1py/Services/ServerService.py</code> <pre><code>@require_data_admin\ndef write_to_message_log(self, level: str, message: str, **kwargs) -&gt; None:\n    \"\"\"\n    :param level: string, FATAL, ERROR, WARN, INFO, DEBUG\n    :param message: string\n    :return:\n    \"\"\"\n\n    return self.message_logs.create_entry(level=level, message=message, **kwargs)\n</code></pre>"},{"location":"reference/services/sessionservice/","title":"SessionService","text":""},{"location":"reference/services/sessionservice/#TM1py.Services.SessionService.SessionService","title":"<code>SessionService(rest)</code>","text":"<p>               Bases: <code>ObjectService</code></p> <p>Service to Query and Cancel Threads in TM1</p> Source code in <code>TM1py/Services/SessionService.py</code> <pre><code>def __init__(self, rest: RestService):\n    super().__init__(rest)\n    self.users = UserService(rest)\n</code></pre>"},{"location":"reference/services/sessionservice/#TM1py.Services.SessionService.SessionService.users","title":"<code>users = UserService(rest)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/services/sessionservice/#TM1py.Services.SessionService.SessionService.close","title":"<code>close(session_id, **kwargs)</code>","text":"Source code in <code>TM1py/Services/SessionService.py</code> <pre><code>def close(self, session_id, **kwargs) -&gt; Response:\n    url = format_url(f\"/Sessions('{session_id}')/tm1.Close\")\n    return self._rest.POST(url, **kwargs)\n</code></pre>"},{"location":"reference/services/sessionservice/#TM1py.Services.SessionService.SessionService.close_all","title":"<code>close_all(**kwargs)</code>","text":"Source code in <code>TM1py/Services/SessionService.py</code> <pre><code>@require_admin\ndef close_all(self, **kwargs) -&gt; list:\n    current_user = self.users.get_current(**kwargs)\n    sessions = self.get_all(**kwargs)\n    closed_sessions = list()\n    for session in sessions:\n        if \"User\" not in session:\n            continue\n        if session[\"User\"] is None:\n            continue\n        if \"Name\" not in session[\"User\"]:\n            continue\n        if case_and_space_insensitive_equals(current_user.name, session[\"User\"][\"Name\"]):\n            continue\n        self.close(session[\"ID\"], **kwargs)\n        closed_sessions.append(session)\n    return closed_sessions\n</code></pre>"},{"location":"reference/services/sessionservice/#TM1py.Services.SessionService.SessionService.get_all","title":"<code>get_all(include_user=True, include_threads=True, **kwargs)</code>","text":"Source code in <code>TM1py/Services/SessionService.py</code> <pre><code>def get_all(self, include_user: bool = True, include_threads: bool = True, **kwargs) -&gt; List:\n    url = \"/Sessions\"\n    if include_user or include_threads:\n        expands = list()\n        if include_user:\n            expands.append(\"User\")\n        if include_threads:\n            expands.append(\"Threads\")\n        url += \"?$expand=\" + \",\".join(expands)\n\n    response = self._rest.GET(url, **kwargs)\n    return response.json()[\"value\"]\n</code></pre>"},{"location":"reference/services/sessionservice/#TM1py.Services.SessionService.SessionService.get_current","title":"<code>get_current(**kwargs)</code>","text":"Source code in <code>TM1py/Services/SessionService.py</code> <pre><code>def get_current(self, **kwargs):\n    url = \"/ActiveSession\"\n\n    response = self._rest.GET(url, **kwargs)\n    return response.json()[\"value\"]\n</code></pre>"},{"location":"reference/services/sessionservice/#TM1py.Services.SessionService.SessionService.get_threads_for_current","title":"<code>get_threads_for_current(exclude_idle=True, **kwargs)</code>","text":"Source code in <code>TM1py/Services/SessionService.py</code> <pre><code>def get_threads_for_current(self, exclude_idle: bool = True, **kwargs):\n    url = \"/ActiveSession/Threads?$filter=Function ne 'GET /ActiveSession/Threads' and Function ne 'GET /api/v1/ActiveSession/Threads'\"\n    if exclude_idle:\n        url += \" and State ne 'Idle'\"\n\n    response = self._rest.GET(url, **kwargs)\n    return response.json()[\"value\"]\n</code></pre>"},{"location":"reference/services/subsetservice/","title":"SubsetService","text":""},{"location":"reference/services/subsetservice/#TM1py.Services.SubsetService.SubsetService","title":"<code>SubsetService(rest)</code>","text":"<p>               Bases: <code>ObjectService</code></p> <p>Service to handle Object Updates for TM1 Subsets (dynamic and static)</p> Source code in <code>TM1py/Services/SubsetService.py</code> <pre><code>def __init__(self, rest: RestService):\n    super().__init__(rest)\n    self._process_service = ProcessService(rest)\n</code></pre>"},{"location":"reference/services/subsetservice/#TM1py.Services.SubsetService.SubsetService.create","title":"<code>create(subset, private=False, **kwargs)</code>","text":"<p>create subset on the TM1 Server</p> <p>Parameters:</p> Name Type Description Default <code>subset</code> <code>Subset</code> <p>TM1py.Subset, the subset that shall be created</p> required <code>private</code> <code>bool</code> <p>boolean</p> <code>False</code> <p>Returns:</p> Type Description <code>Response</code> <p>string: the response</p> Source code in <code>TM1py/Services/SubsetService.py</code> <pre><code>def create(self, subset: Subset, private: bool = False, **kwargs) -&gt; Response:\n    \"\"\"create subset on the TM1 Server\n\n    :param subset: TM1py.Subset, the subset that shall be created\n    :param private: boolean\n\n    :return:\n        string: the response\n    \"\"\"\n    subsets = \"PrivateSubsets\" if private else \"Subsets\"\n    url = format_url(\n        \"/Dimensions('{}')/Hierarchies('{}')/{}\", subset.dimension_name, subset.hierarchy_name, subsets\n    )\n    response = self._rest.POST(url, subset.body, **kwargs)\n    return response\n</code></pre>"},{"location":"reference/services/subsetservice/#TM1py.Services.SubsetService.SubsetService.delete","title":"<code>delete(subset_name, dimension_name, hierarchy_name=None, private=False, **kwargs)</code>","text":"<p>Delete an existing subset on the TM1 Server</p> <p>Parameters:</p> Name Type Description Default <code>subset_name</code> <code>str</code> <p>String, name of the subset</p> required <code>dimension_name</code> <code>str</code> <p>String, name of the dimension</p> required <code>hierarchy_name</code> <code>str</code> <p>String, name of the hierarchy</p> <code>None</code> <code>private</code> <code>bool</code> <p>Boolean</p> <code>False</code> <p>Returns:</p> Type Description <code>Response</code> Source code in <code>TM1py/Services/SubsetService.py</code> <pre><code>def delete(\n    self, subset_name: str, dimension_name: str, hierarchy_name: str = None, private: bool = False, **kwargs\n) -&gt; Response:\n    \"\"\"Delete an existing subset on the TM1 Server\n\n    :param subset_name: String, name of the subset\n    :param dimension_name: String, name of the dimension\n    :param hierarchy_name: String, name of the hierarchy\n    :param private: Boolean\n    :return:\n    \"\"\"\n    hierarchy_name = hierarchy_name if hierarchy_name else dimension_name\n    subsets = \"PrivateSubsets\" if private else \"Subsets\"\n    url = format_url(\n        \"/Dimensions('{}')/Hierarchies('{}')/{}('{}')\", dimension_name, hierarchy_name, subsets, subset_name\n    )\n    response = self._rest.DELETE(url=url, **kwargs)\n    return response\n</code></pre>"},{"location":"reference/services/subsetservice/#TM1py.Services.SubsetService.SubsetService.delete_elements_from_static_subset","title":"<code>delete_elements_from_static_subset(dimension_name, hierarchy_name, subset_name, private, **kwargs)</code>","text":"Source code in <code>TM1py/Services/SubsetService.py</code> <pre><code>def delete_elements_from_static_subset(\n    self, dimension_name: str, hierarchy_name: str, subset_name: str, private: bool, **kwargs\n) -&gt; Response:\n    subsets = \"PrivateSubsets\" if private else \"Subsets\"\n    url = format_url(\n        \"/Dimensions('{}')/Hierarchies('{}')/{}('{}')/Elements/$ref\",\n        dimension_name,\n        hierarchy_name,\n        subsets,\n        subset_name,\n    )\n    return self._rest.DELETE(url=url, **kwargs)\n</code></pre>"},{"location":"reference/services/subsetservice/#TM1py.Services.SubsetService.SubsetService.exists","title":"<code>exists(subset_name, dimension_name, hierarchy_name=None, private=False, **kwargs)</code>","text":"<p>checks if private or public subset exists</p> <p>Parameters:</p> Name Type Description Default <code>subset_name</code> <code>str</code> required <code>dimension_name</code> <code>str</code> required <code>hierarchy_name</code> <code>str</code> <code>None</code> <code>private</code> <code>bool</code> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p>boolean</p> Source code in <code>TM1py/Services/SubsetService.py</code> <pre><code>def exists(\n    self, subset_name: str, dimension_name: str, hierarchy_name: str = None, private: bool = False, **kwargs\n) -&gt; bool:\n    \"\"\"checks if private or public subset exists\n\n    :param subset_name:\n    :param dimension_name:\n    :param hierarchy_name:\n    :param private:\n    :return: boolean\n    \"\"\"\n    hierarchy_name = hierarchy_name if hierarchy_name else dimension_name\n    subset_type = \"PrivateSubsets\" if private else \"Subsets\"\n    url = format_url(\n        \"/Dimensions('{}')/Hierarchies('{}')/{}('{}')\", dimension_name, hierarchy_name, subset_type, subset_name\n    )\n    return self._exists(url, **kwargs)\n</code></pre>"},{"location":"reference/services/subsetservice/#TM1py.Services.SubsetService.SubsetService.get","title":"<code>get(subset_name, dimension_name, hierarchy_name=None, private=False, **kwargs)</code>","text":"<p>get a subset from the TM1 Server</p> <p>Parameters:</p> Name Type Description Default <code>subset_name</code> <code>str</code> <p>string, name of the subset</p> required <code>dimension_name</code> <code>str</code> <p>string, name of the dimension</p> required <code>hierarchy_name</code> <code>str</code> <p>string, name of the hierarchy</p> <code>None</code> <code>private</code> <code>bool</code> <p>Boolean</p> <code>False</code> <p>Returns:</p> Type Description <code>Subset</code> <p>instance of TM1py.Subset</p> Source code in <code>TM1py/Services/SubsetService.py</code> <pre><code>def get(\n    self, subset_name: str, dimension_name: str, hierarchy_name: str = None, private: bool = False, **kwargs\n) -&gt; Subset:\n    \"\"\"get a subset from the TM1 Server\n\n    :param subset_name: string, name of the subset\n    :param dimension_name: string, name of the dimension\n    :param hierarchy_name: string, name of the hierarchy\n    :param private: Boolean\n\n    :return: instance of TM1py.Subset\n    \"\"\"\n    if not hierarchy_name:\n        hierarchy_name = dimension_name\n    subsets = \"PrivateSubsets\" if private else \"Subsets\"\n    url = format_url(\n        \"/Dimensions('{}')/Hierarchies('{}')/{}('{}')?$expand=Hierarchy($select=Dimension,Name),\"\n        \"Elements($select=Name)&amp;$select=*,Alias\",\n        dimension_name,\n        hierarchy_name,\n        subsets,\n        subset_name,\n    )\n    response = self._rest.GET(url=url, **kwargs)\n    return Subset.from_dict(response.json())\n</code></pre>"},{"location":"reference/services/subsetservice/#TM1py.Services.SubsetService.SubsetService.get_all_names","title":"<code>get_all_names(dimension_name, hierarchy_name=None, private=False, **kwargs)</code>","text":"<p>get names of all private or public subsets in a hierarchy</p> <p>Parameters:</p> Name Type Description Default <code>dimension_name</code> <code>str</code> required <code>hierarchy_name</code> <code>str</code> <code>None</code> <code>private</code> <code>bool</code> <p>Boolean</p> <code>False</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of Strings</p> Source code in <code>TM1py/Services/SubsetService.py</code> <pre><code>def get_all_names(\n    self, dimension_name: str, hierarchy_name: str = None, private: bool = False, **kwargs\n) -&gt; List[str]:\n    \"\"\"get names of all private or public subsets in a hierarchy\n\n    :param dimension_name:\n    :param hierarchy_name:\n    :param private: Boolean\n    :return: List of Strings\n    \"\"\"\n    hierarchy_name = hierarchy_name if hierarchy_name else dimension_name\n\n    subsets = \"PrivateSubsets\" if private else \"Subsets\"\n    url = format_url(\"/Dimensions('{}')/Hierarchies('{}')/{}?$select=Name\", dimension_name, hierarchy_name, subsets)\n    response = self._rest.GET(url=url, **kwargs)\n    subsets = response.json()[\"value\"]\n    return [subset[\"Name\"] for subset in subsets]\n</code></pre>"},{"location":"reference/services/subsetservice/#TM1py.Services.SubsetService.SubsetService.get_element_names","title":"<code>get_element_names(dimension_name, hierarchy_name, subset, private=False, **kwargs)</code>","text":"<p>Retrieve element names from a static or dynamic subset.</p> <p>Parameters:</p> Name Type Description Default <code>dimension_name</code> <code>str</code> <p>Name of the dimension.</p> required <code>hierarchy_name</code> <code>str</code> <p>Name of the hierarchy.</p> required <code>subset</code> <code>Union[str, Subset]</code> <p>Subset name (str) or Subset object.</p> required <code>private</code> <code>bool</code> <p>Whether the subset is private.</p> <code>False</code> <code>kwargs</code> <p>Additional arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of element names.</p> Source code in <code>TM1py/Services/SubsetService.py</code> <pre><code>def get_element_names(\n    self, dimension_name: str, hierarchy_name: str, subset: Union[str, Subset], private: bool = False, **kwargs\n) -&gt; List[str]:\n    \"\"\"\n    Retrieve element names from a static or dynamic subset.\n\n    :param dimension_name: Name of the dimension.\n    :param hierarchy_name: Name of the hierarchy.\n    :param subset: Subset name (str) or Subset object.\n    :param private: Whether the subset is private.\n    :param kwargs: Additional arguments.\n    :return: List of element names.\n    \"\"\"\n    if isinstance(subset, str):\n        subset = self.get(subset, dimension_name, hierarchy_name, private=private, **kwargs)\n    elif not isinstance(subset, Subset):\n        raise ValueError(f\"subset argument must be of type 'str' or 'Subset', not '{type(subset)}'.\")\n\n    if subset.is_static:\n        return list(subset.elements)\n\n    from TM1py.Services import ElementService\n\n    element_service = ElementService(self._rest)\n    tuples = element_service.execute_set_mdx(\n        mdx=subset.expression, member_properties=[\"Name\"], element_properties=None, parent_properties=None, **kwargs\n    )\n    return [entry[0].get(\"Name\", \"\") for entry in tuples if entry and \"Name\" in entry[0]]\n</code></pre>"},{"location":"reference/services/subsetservice/#TM1py.Services.SubsetService.SubsetService.make_static","title":"<code>make_static(subset_name, dimension_name, hierarchy_name=None, private=False)</code>","text":"<p>convert a dynamic subset into static subset on the TM1 Server</p> <p>Parameters:</p> Name Type Description Default <code>subset_name</code> <code>str</code> <p>String, name of the subset</p> required <code>dimension_name</code> <code>str</code> <p>String, name of the dimension</p> required <code>hierarchy_name</code> <code>str</code> <p>String, name of the hierarchy</p> <code>None</code> <code>private</code> <code>bool</code> <p>Boolean</p> <code>False</code> <p>Returns:</p> Type Description <code>Response</code> <p>response</p> Source code in <code>TM1py/Services/SubsetService.py</code> <pre><code>def make_static(\n    self, subset_name: str, dimension_name: str, hierarchy_name: str = None, private: bool = False\n) -&gt; Response:\n    \"\"\"convert a dynamic subset into static subset on the TM1 Server\n    :param subset_name: String, name of the subset\n    :param dimension_name: String, name of the dimension\n    :param hierarchy_name: String, name of the hierarchy\n    :param private: Boolean\n    :return: response\n    \"\"\"\n    import json\n    from collections import OrderedDict\n\n    hierarchy_name = hierarchy_name if hierarchy_name else dimension_name\n    payload = OrderedDict()\n    payload[\"Name\"] = subset_name\n    payload[\"MakePrivate\"] = True if private else False\n    payload[\"MakeStatic\"] = True\n    subsets = \"PrivateSubsets\" if private else \"Subsets\"\n    url = format_url(\n        \"/Dimensions('{}')/Hierarchies('{}')/{}('{}')/tm1.SaveAs\",\n        dimension_name,\n        hierarchy_name,\n        subsets,\n        subset_name,\n    )\n    return self._rest.POST(url=url, data=json.dumps(payload))\n</code></pre>"},{"location":"reference/services/subsetservice/#TM1py.Services.SubsetService.SubsetService.update","title":"<code>update(subset, private=False, **kwargs)</code>","text":"<p>update a subset on the TM1 Server</p> <p>Parameters:</p> Name Type Description Default <code>subset</code> <code>Subset</code> <p>instance of TM1py.Subset.</p> required <code>private</code> <code>bool</code> <p>Boolean</p> <code>False</code> <p>Returns:</p> Type Description <code>Response</code> <p>response</p> Source code in <code>TM1py/Services/SubsetService.py</code> <pre><code>def update(self, subset: Subset, private: bool = False, **kwargs) -&gt; Response:\n    \"\"\"update a subset on the TM1 Server\n\n    :param subset: instance of TM1py.Subset.\n    :param private: Boolean\n    :return: response\n    \"\"\"\n    if subset.is_static:\n        self.update_static_elements(subset=subset, elements=subset.elements, private=private, **kwargs)\n        subset = Subset(\n            subset_name=subset.name,\n            dimension_name=subset.dimension_name,\n            hierarchy_name=subset.hierarchy_name,\n            alias=subset.alias,\n            expression=subset.expression,\n        )\n    subsets = \"PrivateSubsets\" if private else \"Subsets\"\n    url = format_url(\n        \"/Dimensions('{}')/Hierarchies('{}')/{}('{}')\",\n        subset.dimension_name,\n        subset.hierarchy_name,\n        subsets,\n        subset.name,\n    )\n    return self._rest.PATCH(url=url, data=subset.body, **kwargs)\n</code></pre>"},{"location":"reference/services/subsetservice/#TM1py.Services.SubsetService.SubsetService.update_or_create","title":"<code>update_or_create(subset, private=False, **kwargs)</code>","text":"<p>update if exists else create</p> <p>Parameters:</p> Name Type Description Default <code>subset</code> <code>Subset</code> required <code>private</code> <code>bool</code> <code>False</code> <p>Returns:</p> Type Description <code>Response</code> Source code in <code>TM1py/Services/SubsetService.py</code> <pre><code>def update_or_create(self, subset: Subset, private: bool = False, **kwargs) -&gt; Response:\n    \"\"\"update if exists else create\n\n    :param subset:\n    :param private:\n    :return:\n    \"\"\"\n    if self.exists(\n        subset_name=subset.name,\n        dimension_name=subset.dimension_name,\n        hierarchy_name=subset.hierarchy_name,\n        private=private,\n        **kwargs,\n    ):\n        return self.update(subset=subset, private=private, **kwargs)\n\n    return self.create(subset=subset, private=private, **kwargs)\n</code></pre>"},{"location":"reference/services/subsetservice/#TM1py.Services.SubsetService.SubsetService.update_static_elements","title":"<code>update_static_elements(subset, dimension_name=None, hierarchy_name=None, private=False, elements=None, **kwargs)</code>","text":"<p>Replaces elements in a static subset.</p> <p>Parameters:</p> Name Type Description Default <code>subset</code> <code>Union[str, Subset]</code> <p>Subset name (str) or Subset object.</p> required <code>dimension_name</code> <code>str</code> <p>Name of the dimension.</p> <code>None</code> <code>hierarchy_name</code> <code>str</code> <p>Name of the hierarchy.</p> <code>None</code> <code>private</code> <code>bool</code> <p>Whether the subset is private.</p> <code>False</code> <code>elements</code> <code>Optional[Iterable[Union[str, Element]]]</code> <p>List of element names (str) or Element objects.</p> <code>None</code> <code>kwargs</code> <p>Additional arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>Response from TM1.</p> Source code in <code>TM1py/Services/SubsetService.py</code> <pre><code>def update_static_elements(\n    self,\n    subset: Union[str, Subset],\n    dimension_name: str = None,\n    hierarchy_name: str = None,\n    private: bool = False,\n    elements: Optional[Iterable[Union[str, Element]]] = None,\n    **kwargs,\n) -&gt; Response:\n    \"\"\"\n    Replaces elements in a static subset.\n    :param subset: Subset name (str) or Subset object.\n    :param dimension_name: Name of the dimension.\n    :param hierarchy_name: Name of the hierarchy.\n    :param private: Whether the subset is private.\n    :param elements: List of element names (str) or Element objects.\n    :param kwargs: Additional arguments.\n    :return: Response from TM1.\n    \"\"\"\n    if isinstance(subset, Subset):\n        subset_name = subset.name\n        if not subset.is_static:\n            raise ValueError(\"Subset must be static\")\n\n        if not dimension_name:\n            dimension_name = subset.dimension_name\n        elif not case_and_space_insensitive_equals(dimension_name, subset.dimension_name):\n            raise ValueError(\n                f\"dimension_name argument '{dimension_name}' \"\n                f\"differs from subset dimension_name '{subset.dimension_name}'\"\n            )\n\n        if not hierarchy_name:\n            hierarchy_name = subset.hierarchy_name\n        elif not case_and_space_insensitive_equals(hierarchy_name, subset.hierarchy_name):\n            raise ValueError(\n                f\"hierarchy_name argument '{hierarchy_name}' \"\n                f\"differs from subset hierarchy_name '{subset.hierarchy_name}'\"\n            )\n\n        if elements is None:\n            elements = subset.elements\n    elif isinstance(subset, str):\n        subset_name = subset\n        if not dimension_name:\n            raise ValueError(\"When subset is of type str, dimension_name must be provided.\")\n        if not hierarchy_name:\n            raise ValueError(\"When subset is of type str, hierarchy_name must be provided.\")\n        if elements is None:\n            raise ValueError(\"When subset is of type str, elements must be provided.\")\n\n    else:\n        raise ValueError(f\"subset argument must be of type 'str' or 'Subset', not '{type(subset)}'\")\n\n    subsets = \"PrivateSubsets\" if private else \"Subsets\"\n    url = format_url(\n        \"/Dimensions('{}')/Hierarchies('{}')/{}('{}')/Elements/$ref\",\n        dimension_name,\n        hierarchy_name,\n        subsets,\n        subset_name,\n    )\n\n    elements = [element.name if isinstance(element, Element) else element for element in elements]\n    elements = [\n        {\n            \"@odata.id\": format_url(\n                \"Dimensions('{}')/Hierarchies('{}')/Elements('{}')\", dimension_name, hierarchy_name, element\n            )\n        }\n        for element in elements\n    ]\n\n    return self._rest.PUT(url=url, data=json.dumps(elements, ensure_ascii=False), **kwargs)\n</code></pre>"},{"location":"reference/services/threadservice/","title":"ThreadService","text":""},{"location":"reference/services/threadservice/#TM1py.Services.ThreadService.ThreadService","title":"<code>ThreadService(rest)</code>","text":"<p>               Bases: <code>ObjectService</code></p> <p>Service to work with Threads in TM1 Deprecated as of TM1 Server v12</p> Source code in <code>TM1py/Services/ThreadService.py</code> <pre><code>def __init__(self, rest: RestService):\n    super().__init__(rest)\n    if verify_version(required_version=\"12.0.0\", version=self.version):\n        # warn only due to use in Monitoring Service\n        warn(\"Threads not available in this version of TM1, removed as of 12.0.0\", DeprecationWarning, 2)\n</code></pre>"},{"location":"reference/services/threadservice/#TM1py.Services.ThreadService.ThreadService.cancel","title":"<code>cancel(thread_id, **kwargs)</code>","text":"<p>Kill a running thread</p> <p>Parameters:</p> Name Type Description Default <code>thread_id</code> <code>int</code> required <p>Returns:</p> Type Description <code>Response</code> Source code in <code>TM1py/Services/ThreadService.py</code> <pre><code>@deprecated_in_version(version=\"12.0.0\")\ndef cancel(self, thread_id: int, **kwargs) -&gt; Response:\n    \"\"\"Kill a running thread\n\n    :param thread_id:\n    :return:\n    \"\"\"\n    url = format_url(\"/Threads('{}')/tm1.CancelOperation\", str(thread_id))\n    response = self._rest.POST(url, **kwargs)\n    return response\n</code></pre>"},{"location":"reference/services/threadservice/#TM1py.Services.ThreadService.ThreadService.cancel_all_running","title":"<code>cancel_all_running(**kwargs)</code>","text":"Source code in <code>TM1py/Services/ThreadService.py</code> <pre><code>@deprecated_in_version(version=\"12.0.0\")\ndef cancel_all_running(self, **kwargs) -&gt; list:\n    running_threads = self.get_all(**kwargs)\n    canceled_threads = list()\n    for thread in running_threads:\n        if thread[\"State\"] == \"Idle\":\n            continue\n        if thread[\"Type\"] == \"System\":\n            continue\n        if thread[\"Name\"] == \"Pseudo\":\n            continue\n        if thread[\"Function\"] == \"GET /Threads\":\n            continue\n        if thread[\"Function\"] == \"GET /api/v1/Threads\":\n            continue\n        self.cancel(thread[\"ID\"], **kwargs)\n        canceled_threads.append(thread)\n    return canceled_threads\n</code></pre>"},{"location":"reference/services/threadservice/#TM1py.Services.ThreadService.ThreadService.get_active","title":"<code>get_active(**kwargs)</code>","text":"<p>Return a list of non-idle threads from the TM1 Server</p> <p>Returns:</p> Type Description <p>list: TM1 threads as dict</p> Source code in <code>TM1py/Services/ThreadService.py</code> <pre><code>@deprecated_in_version(version=\"12.0.0\")\ndef get_active(self, **kwargs):\n    \"\"\"Return a list of non-idle threads from the TM1 Server\n\n    :return:\n        list: TM1 threads as dict\n    \"\"\"\n    url = \"/Threads?$filter=Function ne 'GET /Threads' and State ne 'Idle'\"\n    response = self._rest.GET(url, **kwargs)\n    return response.json()[\"value\"]\n</code></pre>"},{"location":"reference/services/threadservice/#TM1py.Services.ThreadService.ThreadService.get_all","title":"<code>get_all(**kwargs)</code>","text":"<p>Return a list of the currently running threads from the TM1 Server</p> <p>Returns:</p> Type Description <code>List</code> <p>dict: the response</p> Source code in <code>TM1py/Services/ThreadService.py</code> <pre><code>@deprecated_in_version(version=\"12.0.0\")\ndef get_all(self, **kwargs) -&gt; List:\n    \"\"\"Return a list of the currently running threads from the TM1 Server\n\n    :return:\n        dict: the response\n    \"\"\"\n    url = \"/Threads\"\n    response = self._rest.GET(url, **kwargs)\n    return response.json()[\"value\"]\n</code></pre>"},{"location":"reference/services/tm1service/","title":"TM1Service","text":""},{"location":"reference/services/tm1service/#TM1py.Services.TM1Service.TM1Service","title":"<code>TM1Service(**kwargs)</code>","text":"<p>All features of TM1py are exposed through this service</p> <p>Can be saved and restored from File, to avoid multiple authentication with TM1.</p> <p>Initiate the TM1Service</p> <p>Supported kwargs arguments:</p> <ul> <li>address (str): Address of the TM1 instance.</li> <li>port (int): HTTPPortNumber as specified in the tm1s.cfg.</li> <li>ssl (bool): Whether to use SSL, as specified in the tm1s.cfg.</li> <li>instance (str): Planning Analytics engine (v12) instance name.</li> <li>database (str): Planning Analytics engine (v12) database name.</li> <li>base_url (str): Base URL for the REST API.</li> <li>auth_url (str): Authentication URL for Planning Analytics engine (v12).</li> <li>user (str): Name of the user.</li> <li>password (str): Password of the user.</li> <li>decode_b64 (bool): Whether the password argument is Base64 encoded.</li> <li>namespace (str): Optional CAM namespace.</li> <li>cam_passport (str): The CAM passport.</li> <li>session_id (str): TM1SessionId, e.g., \"q7O6e1w49AixeuLVxJ1GZg\".</li> <li>application_client_id (str): Planning Analytics engine (v12) named application client ID.</li> <li>application_client_secret (str): Planning Analytics engine (v12) named application secret.</li> <li>api_key (str): Planning Analytics engine (v12) API Key.</li> <li>iam_url (str): IBM Cloud IAM URL. Default: \"https://iam.cloud.ibm.com\".</li> <li>pa_url (str): Planning Analytics engine (v12) PA URL.</li> <li>cpd_url (str): Cloud Pak for Data URL (aka ZEN).</li> <li>tenant (str): Planning Analytics engine (v12) tenant.</li> <li>session_context (str): Name of the application. Controls \"Context\" column in Arc/TM1top.</li> <li>verify (bool or str): Path to .cer file or boolean for SSL verification.</li> <li>logging (bool): Enable or disable verbose HTTP logging.</li> <li>timeout (float): Number of seconds to wait for a response.</li> <li>cancel_at_timeout (bool): Abort operation in TM1 when timeout is reached.</li> <li>async_requests_mode (bool): Enable asynchronous request mode.</li> <li>connection_pool_size (int): Maximum number of connections in the pool.</li> <li>pool_connections (int): Number of connection pools to cache.</li> <li>integrated_login (bool): True for IntegratedSecurityMode3.</li> <li>integrated_login_domain (str): NT Domain name.</li> <li>integrated_login_service (str): Kerberos Service type for remote Service Principal Name.</li> <li>integrated_login_host (str): Host name for Service Principal Name.</li> <li>integrated_login_delegate (bool): Delegate user credentials to the server.</li> <li>impersonate (str): Name of the user to impersonate.</li> <li>re_connect_on_session_timeout (bool): Attempt to reconnect once if session is timed out.</li> <li>re_connect_on_remote_disconnect (bool): Attempt to reconnect once if connection is aborted by remote end.</li> <li>remote_disconnect_max_retries (int): Maximum number of retry attempts after remote disconnect (default: 5).</li> <li>remote_disconnect_retry_delay (float): Initial delay in seconds before first retry attempt (default: 1).</li> <li>remote_disconnect_max_delay (float): Maximum delay cap in seconds between retry attempts (default: 30).</li> <li>remote_disconnect_backoff_factor (float): Multiplier for exponential backoff between retry attempts (default: 2).</li> <li>async_polling_initial_delay (float): Initial polling delay in seconds for async operations (default: 0.1).</li> <li>async_polling_max_delay (float): Maximum polling delay cap in seconds for async operations (default: 1.0).</li> <li>async_polling_backoff_factor (float): Multiplier for exponential backoff in async polling (default: 2).</li> <li>proxies (dict): Dictionary of proxies, e.g., {'http': 'http://proxy.example.com:8080'}.</li> <li>ssl_context: User-defined SSL context.</li> <li>cert (str or tuple): Path to SSL client cert file or ('cert', 'key') pair.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <p>See description above for all supported arguments</p> <code>{}</code> Source code in <code>TM1py/Services/TM1Service.py</code> <pre><code>def __init__(self, **kwargs):\n    \"\"\"Initiate the TM1Service\n\n    Supported kwargs arguments:\n\n    - **address** (str): Address of the TM1 instance.\n    - **port** (int): HTTPPortNumber as specified in the tm1s.cfg.\n    - **ssl** (bool): Whether to use SSL, as specified in the tm1s.cfg.\n    - **instance** (str): Planning Analytics engine (v12) instance name.\n    - **database** (str): Planning Analytics engine (v12) database name.\n    - **base_url** (str): Base URL for the REST API.\n    - **auth_url** (str): Authentication URL for Planning Analytics engine (v12).\n    - **user** (str): Name of the user.\n    - **password** (str): Password of the user.\n    - **decode_b64** (bool): Whether the password argument is Base64 encoded.\n    - **namespace** (str): Optional CAM namespace.\n    - **cam_passport** (str): The CAM passport.\n    - **session_id** (str): TM1SessionId, e.g., \"q7O6e1w49AixeuLVxJ1GZg\".\n    - **application_client_id** (str): Planning Analytics engine (v12) named application client ID.\n    - **application_client_secret** (str): Planning Analytics engine (v12) named application secret.\n    - **api_key** (str): Planning Analytics engine (v12) API Key.\n    - **iam_url** (str): IBM Cloud IAM URL. Default: \"https://iam.cloud.ibm.com\".\n    - **pa_url** (str): Planning Analytics engine (v12) PA URL.\n    - **cpd_url** (str): Cloud Pak for Data URL (aka ZEN).\n    - **tenant** (str): Planning Analytics engine (v12) tenant.\n    - **session_context** (str): Name of the application. Controls \"Context\" column in Arc/TM1top.\n    - **verify** (bool or str): Path to .cer file or boolean for SSL verification.\n    - **logging** (bool): Enable or disable verbose HTTP logging.\n    - **timeout** (float): Number of seconds to wait for a response.\n    - **cancel_at_timeout** (bool): Abort operation in TM1 when timeout is reached.\n    - **async_requests_mode** (bool): Enable asynchronous request mode.\n    - **connection_pool_size** (int): Maximum number of connections in the pool.\n    - **pool_connections** (int): Number of connection pools to cache.\n    - **integrated_login** (bool): True for IntegratedSecurityMode3.\n    - **integrated_login_domain** (str): NT Domain name.\n    - **integrated_login_service** (str): Kerberos Service type for remote Service Principal Name.\n    - **integrated_login_host** (str): Host name for Service Principal Name.\n    - **integrated_login_delegate** (bool): Delegate user credentials to the server.\n    - **impersonate** (str): Name of the user to impersonate.\n    - **re_connect_on_session_timeout** (bool): Attempt to reconnect once if session is timed out.\n    - **re_connect_on_remote_disconnect** (bool): Attempt to reconnect once if connection is aborted by remote end.\n    - **remote_disconnect_max_retries** (int): Maximum number of retry attempts after remote disconnect (default: 5).\n    - **remote_disconnect_retry_delay** (float): Initial delay in seconds before first retry attempt (default: 1).\n    - **remote_disconnect_max_delay** (float): Maximum delay cap in seconds between retry attempts (default: 30).\n    - **remote_disconnect_backoff_factor** (float): Multiplier for exponential backoff between retry attempts (default: 2).\n    - **async_polling_initial_delay** (float): Initial polling delay in seconds for async operations (default: 0.1).\n    - **async_polling_max_delay** (float): Maximum polling delay cap in seconds for async operations (default: 1.0).\n    - **async_polling_backoff_factor** (float): Multiplier for exponential backoff in async polling (default: 2).\n    - **proxies** (dict): Dictionary of proxies, e.g., {'http': 'http://proxy.example.com:8080'}.\n    - **ssl_context**: User-defined SSL context.\n    - **cert** (str or tuple): Path to SSL client cert file or ('cert', 'key') pair.\n\n    :param kwargs: See description above for all supported arguments\n\n    \"\"\"\n    self._tm1_rest = RestService(**kwargs)\n    self.annotations = AnnotationService(self._tm1_rest)\n    self.cells = CellService(self._tm1_rest)\n    self.chores = ChoreService(self._tm1_rest)\n    self.cubes = CubeService(self._tm1_rest)\n    self.dimensions = DimensionService(self._tm1_rest)\n    self.elements = ElementService(self._tm1_rest)\n    self.git = GitService(self._tm1_rest)\n    self.hierarchies = HierarchyService(self._tm1_rest)\n    self.processes = ProcessService(self._tm1_rest)\n    self.security = SecurityService(self._tm1_rest)\n    self.subsets = SubsetService(self._tm1_rest)\n    self.applications = ApplicationService(self._tm1_rest)\n    self.views = ViewService(self._tm1_rest)\n    self.sandboxes = SandboxService(self._tm1_rest)\n    self.files = FileService(self._tm1_rest)\n    self.jobs = JobService(self._tm1_rest)\n    self.users = UserService(self._tm1_rest)\n    self.threads = ThreadService(self._tm1_rest)\n    self.sessions = SessionService(self._tm1_rest)\n    self.transaction_logs = TransactionLogService(self._tm1_rest)\n    self.message_logs = MessageLogService(self._tm1_rest)\n    self.configuration = ConfigurationService(self._tm1_rest)\n    self.audit_logs = AuditLogService(self._tm1_rest)\n\n    # higher level modules\n    self.power_bi = PowerBiService(self._tm1_rest)\n    self.loggers = LoggerService(self._tm1_rest)\n\n    self._server = None\n    self._monitoring = None\n</code></pre>"},{"location":"reference/services/tm1service/#TM1py.Services.TM1Service.TM1Service.annotations","title":"<code>annotations = AnnotationService(self._tm1_rest)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/services/tm1service/#TM1py.Services.TM1Service.TM1Service.applications","title":"<code>applications = ApplicationService(self._tm1_rest)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/services/tm1service/#TM1py.Services.TM1Service.TM1Service.audit_logs","title":"<code>audit_logs = AuditLogService(self._tm1_rest)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/services/tm1service/#TM1py.Services.TM1Service.TM1Service.cells","title":"<code>cells = CellService(self._tm1_rest)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/services/tm1service/#TM1py.Services.TM1Service.TM1Service.chores","title":"<code>chores = ChoreService(self._tm1_rest)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/services/tm1service/#TM1py.Services.TM1Service.TM1Service.configuration","title":"<code>configuration = ConfigurationService(self._tm1_rest)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/services/tm1service/#TM1py.Services.TM1Service.TM1Service.connection","title":"<code>connection</code>  <code>property</code>","text":""},{"location":"reference/services/tm1service/#TM1py.Services.TM1Service.TM1Service.cubes","title":"<code>cubes = CubeService(self._tm1_rest)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/services/tm1service/#TM1py.Services.TM1Service.TM1Service.dimensions","title":"<code>dimensions = DimensionService(self._tm1_rest)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/services/tm1service/#TM1py.Services.TM1Service.TM1Service.elements","title":"<code>elements = ElementService(self._tm1_rest)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/services/tm1service/#TM1py.Services.TM1Service.TM1Service.files","title":"<code>files = FileService(self._tm1_rest)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/services/tm1service/#TM1py.Services.TM1Service.TM1Service.git","title":"<code>git = GitService(self._tm1_rest)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/services/tm1service/#TM1py.Services.TM1Service.TM1Service.hierarchies","title":"<code>hierarchies = HierarchyService(self._tm1_rest)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/services/tm1service/#TM1py.Services.TM1Service.TM1Service.jobs","title":"<code>jobs = JobService(self._tm1_rest)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/services/tm1service/#TM1py.Services.TM1Service.TM1Service.loggers","title":"<code>loggers = LoggerService(self._tm1_rest)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/services/tm1service/#TM1py.Services.TM1Service.TM1Service.message_logs","title":"<code>message_logs = MessageLogService(self._tm1_rest)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/services/tm1service/#TM1py.Services.TM1Service.TM1Service.metadata","title":"<code>metadata</code>  <code>property</code>","text":""},{"location":"reference/services/tm1service/#TM1py.Services.TM1Service.TM1Service.monitoring","title":"<code>monitoring</code>  <code>property</code>","text":""},{"location":"reference/services/tm1service/#TM1py.Services.TM1Service.TM1Service.power_bi","title":"<code>power_bi = PowerBiService(self._tm1_rest)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/services/tm1service/#TM1py.Services.TM1Service.TM1Service.processes","title":"<code>processes = ProcessService(self._tm1_rest)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/services/tm1service/#TM1py.Services.TM1Service.TM1Service.sandboxes","title":"<code>sandboxes = SandboxService(self._tm1_rest)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/services/tm1service/#TM1py.Services.TM1Service.TM1Service.security","title":"<code>security = SecurityService(self._tm1_rest)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/services/tm1service/#TM1py.Services.TM1Service.TM1Service.server","title":"<code>server</code>  <code>property</code>","text":""},{"location":"reference/services/tm1service/#TM1py.Services.TM1Service.TM1Service.sessions","title":"<code>sessions = SessionService(self._tm1_rest)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/services/tm1service/#TM1py.Services.TM1Service.TM1Service.subsets","title":"<code>subsets = SubsetService(self._tm1_rest)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/services/tm1service/#TM1py.Services.TM1Service.TM1Service.threads","title":"<code>threads = ThreadService(self._tm1_rest)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/services/tm1service/#TM1py.Services.TM1Service.TM1Service.transaction_logs","title":"<code>transaction_logs = TransactionLogService(self._tm1_rest)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/services/tm1service/#TM1py.Services.TM1Service.TM1Service.users","title":"<code>users = UserService(self._tm1_rest)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/services/tm1service/#TM1py.Services.TM1Service.TM1Service.version","title":"<code>version</code>  <code>property</code>","text":""},{"location":"reference/services/tm1service/#TM1py.Services.TM1Service.TM1Service.views","title":"<code>views = ViewService(self._tm1_rest)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/services/tm1service/#TM1py.Services.TM1Service.TM1Service.whoami","title":"<code>whoami</code>  <code>property</code>","text":""},{"location":"reference/services/tm1service/#TM1py.Services.TM1Service.TM1Service.__enter__","title":"<code>__enter__()</code>","text":"Source code in <code>TM1py/Services/TM1Service.py</code> <pre><code>def __enter__(self):\n    return self\n</code></pre>"},{"location":"reference/services/tm1service/#TM1py.Services.TM1Service.TM1Service.__exit__","title":"<code>__exit__(exception_type, exception_value, traceback)</code>","text":"Source code in <code>TM1py/Services/TM1Service.py</code> <pre><code>def __exit__(self, exception_type, exception_value, traceback):\n    try:\n        self.logout()\n    except Exception as e:\n        warnings.warn(f\"Logout Failed due to Exception: {e}\")\n</code></pre>"},{"location":"reference/services/tm1service/#TM1py.Services.TM1Service.TM1Service.logout","title":"<code>logout(**kwargs)</code>","text":"Source code in <code>TM1py/Services/TM1Service.py</code> <pre><code>def logout(self, **kwargs):\n    self._tm1_rest.logout(**kwargs)\n</code></pre>"},{"location":"reference/services/tm1service/#TM1py.Services.TM1Service.TM1Service.re_authenticate","title":"<code>re_authenticate()</code>","text":"Source code in <code>TM1py/Services/TM1Service.py</code> <pre><code>def re_authenticate(self):\n    self._tm1_rest.connect()\n</code></pre>"},{"location":"reference/services/tm1service/#TM1py.Services.TM1Service.TM1Service.re_connect","title":"<code>re_connect()</code>","text":"Source code in <code>TM1py/Services/TM1Service.py</code> <pre><code>def re_connect(self):\n    self._tm1_rest.connect()\n</code></pre>"},{"location":"reference/services/tm1service/#TM1py.Services.TM1Service.TM1Service.restore_from_file","title":"<code>restore_from_file(file_name)</code>  <code>classmethod</code>","text":"Source code in <code>TM1py/Services/TM1Service.py</code> <pre><code>@classmethod\ndef restore_from_file(cls, file_name):\n    with open(file_name, \"rb\") as file:\n        return pickle.load(file)\n</code></pre>"},{"location":"reference/services/tm1service/#TM1py.Services.TM1Service.TM1Service.save_to_file","title":"<code>save_to_file(file_name)</code>","text":"Source code in <code>TM1py/Services/TM1Service.py</code> <pre><code>def save_to_file(self, file_name):\n    with open(file_name, \"wb\") as file:\n        pickle.dump(self, file)\n</code></pre>"},{"location":"reference/services/transactionlogservice/","title":"TransactionLogService","text":""},{"location":"reference/services/transactionlogservice/#TM1py.Services.TransactionLogService.TransactionLogService","title":"<code>TransactionLogService(rest)</code>","text":"<p>               Bases: <code>ObjectService</code></p> Source code in <code>TM1py/Services/TransactionLogService.py</code> <pre><code>def __init__(self, rest: RestService):\n    super().__init__(rest)\n    if verify_version(required_version=\"12.0.0\", version=rest.version):\n        # warn only due to use in Monitoring Service\n        warn(\n            \"Transaction Logs are not available in this version of TM1, removed as of 12.0.0\", DeprecationWarning, 2\n        )\n    self.last_delta_request = None\n</code></pre>"},{"location":"reference/services/transactionlogservice/#TM1py.Services.TransactionLogService.TransactionLogService.last_delta_request","title":"<code>last_delta_request = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/services/transactionlogservice/#TM1py.Services.TransactionLogService.TransactionLogService.execute_delta_request","title":"<code>execute_delta_request(**kwargs)</code>","text":"Source code in <code>TM1py/Services/TransactionLogService.py</code> <pre><code>@deprecated_in_version(version=\"12.0.0\")\n@odata_track_changes_header\ndef execute_delta_request(self, **kwargs) -&gt; Dict:\n    response = self._rest.GET(url=\"/\" + self.last_delta_request, **kwargs)\n    self.last_delta_request = response.text[response.text.rfind(\"TransactionLogEntries/!delta('\") : -2]\n    return response.json()[\"value\"]\n</code></pre>"},{"location":"reference/services/transactionlogservice/#TM1py.Services.TransactionLogService.TransactionLogService.get_entries","title":"<code>get_entries(reverse=True, user=None, cube=None, since=None, until=None, top=None, element_tuple_filter=None, element_position_filter=None, **kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>reverse</code> <code>bool</code> <p>Boolean</p> <code>True</code> <code>user</code> <code>str</code> <p>UserName</p> <code>None</code> <code>cube</code> <code>str</code> <p>CubeName</p> <code>None</code> <code>since</code> <code>datetime</code> <p>of type datetime. If it doesn't have tz information, UTC is assumed.</p> <code>None</code> <code>until</code> <code>datetime</code> <p>of type datetime. If it doesn't have tz information, UTC is assumed.</p> <code>None</code> <code>top</code> <code>int</code> <p>int</p> <code>None</code> <code>element_tuple_filter</code> <code>Dict[str, str]</code> <p>of type dict. Element name as key and comparison operator as value</p> <code>None</code> <code>element_position_filter</code> <code>Dict[int, Dict[str, str]]</code> <p>not yet implemented tuple={'Actual':'eq','2020': 'ge'}</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict</code> Source code in <code>TM1py/Services/TransactionLogService.py</code> <pre><code>@deprecated_in_version(version=\"12.0.0\")\n@require_data_admin\ndef get_entries(\n    self,\n    reverse: bool = True,\n    user: str = None,\n    cube: str = None,\n    since: datetime = None,\n    until: datetime = None,\n    top: int = None,\n    element_tuple_filter: Dict[str, str] = None,\n    element_position_filter: Dict[int, Dict[str, str]] = None,\n    **kwargs,\n) -&gt; Dict:\n    \"\"\"\n    :param reverse: Boolean\n    :param user: UserName\n    :param cube: CubeName\n    :param since: of type datetime. If it doesn't have tz information, UTC is assumed.\n    :param until: of type datetime. If it doesn't have tz information, UTC is assumed.\n    :param top: int\n    :param element_tuple_filter: of type dict. Element name as key and comparison operator as value\n    :param element_position_filter: not yet implemented\n    tuple={'Actual':'eq','2020': 'ge'}\n    :return:\n    \"\"\"\n    if element_position_filter:\n        raise NotImplementedError(\"Feature expected in upcoming releases of TM1, TM1py\")\n\n    reverse = \"desc\" if reverse else \"asc\"\n    url = \"/TransactionLogEntries?$orderby=TimeStamp {} \".format(reverse)\n\n    # filter on user, cube, time and elements\n    if any([user, cube, since, until, element_tuple_filter, element_position_filter]):\n        log_filters = []\n        if user:\n            log_filters.append(format_url(\"User eq '{}'\", user))\n        if cube:\n            log_filters.append(format_url(\"Cube eq '{}'\", cube))\n        if element_tuple_filter:\n            log_filters.append(\n                format_url(\n                    \"Tuple/any(e: {})\".format(\n                        \" or \".join([f\"e {v} '{k}'\" for k, v in element_tuple_filter.items()])\n                    )\n                )\n            )\n        if since:\n            # If since doesn't have tz information, UTC is assumed\n            if not since.tzinfo:\n                since = utc_localize_time(since)\n            log_filters.append(format_url(\"TimeStamp ge {}\", since.strftime(\"%Y-%m-%dT%H:%M:%SZ\")))\n        if until:\n            # If until doesn't have tz information, UTC is assumed\n            if not until.tzinfo:\n                until = utc_localize_time(until)\n            log_filters.append(format_url(\"TimeStamp le {}\", until.strftime(\"%Y-%m-%dT%H:%M:%SZ\")))\n        url += \"&amp;$filter={}\".format(\" and \".join(log_filters))\n    # top limit\n    if top:\n        url += \"&amp;$top={}\".format(top)\n    response = self._rest.GET(url, **kwargs)\n    return response.json()[\"value\"]\n</code></pre>"},{"location":"reference/services/transactionlogservice/#TM1py.Services.TransactionLogService.TransactionLogService.initialize_delta_requests","title":"<code>initialize_delta_requests(filter=None, **kwargs)</code>","text":"Source code in <code>TM1py/Services/TransactionLogService.py</code> <pre><code>@deprecated_in_version(version=\"12.0.0\")\n@odata_track_changes_header\ndef initialize_delta_requests(self, filter=None, **kwargs):\n    url = \"/TailTransactionLog()\"\n    if filter:\n        url += \"?$filter={}\".format(filter)\n    response = self._rest.GET(url=url, **kwargs)\n    # Read the next delta-request-url from the response\n    self.last_delta_request = response.text[response.text.rfind(\"TransactionLogEntries/!delta('\") : -2]\n</code></pre>"},{"location":"reference/services/userservice/","title":"UserService","text":""},{"location":"reference/services/userservice/#TM1py.Services.UserService.UserService","title":"<code>UserService(rest)</code>","text":"<p>               Bases: <code>ObjectService</code></p> Source code in <code>TM1py/Services/UserService.py</code> <pre><code>def __init__(self, rest: RestService):\n    super().__init__(rest)\n</code></pre>"},{"location":"reference/services/userservice/#TM1py.Services.UserService.UserService.disconnect","title":"<code>disconnect(user_name, **kwargs)</code>","text":"<p>Disconnect User</p> <p>Parameters:</p> Name Type Description Default <code>user_name</code> <code>str</code> required <p>Returns:</p> Type Description <code>Response</code> Source code in <code>TM1py/Services/UserService.py</code> <pre><code>def disconnect(self, user_name: str, **kwargs) -&gt; Response:\n    \"\"\"Disconnect User\n\n    :param user_name:\n    :return:\n    \"\"\"\n    url = format_url(\"/Users('{}')/tm1.Disconnect\", user_name)\n    response = self._rest.POST(url, **kwargs)\n    return response\n</code></pre>"},{"location":"reference/services/userservice/#TM1py.Services.UserService.UserService.disconnect_all","title":"<code>disconnect_all(**kwargs)</code>","text":"Source code in <code>TM1py/Services/UserService.py</code> <pre><code>@require_admin\ndef disconnect_all(self, **kwargs) -&gt; list:\n    current_user = self.get_current(**kwargs)\n    active_users = self.get_active(**kwargs)\n    disconnected_users = list()\n    for active_user in active_users:\n        if not case_and_space_insensitive_equals(current_user.name, active_user.name):\n            self.disconnect(active_user.name, **kwargs)\n            disconnected_users += [active_user.name]\n    return disconnected_users\n</code></pre>"},{"location":"reference/services/userservice/#TM1py.Services.UserService.UserService.get_active","title":"<code>get_active(**kwargs)</code>","text":"<p>Get the activate users in TM1</p> <p>Returns:</p> Type Description <code>List[User]</code> <p>List of TM1py.User instances</p> Source code in <code>TM1py/Services/UserService.py</code> <pre><code>def get_active(self, **kwargs) -&gt; List[User]:\n    \"\"\"Get the activate users in TM1\n\n    :return: List of TM1py.User instances\n    \"\"\"\n    url = \"/Users?$filter=IsActive eq true&amp;$expand=Groups\"\n    response = self._rest.GET(url, **kwargs)\n    users = [User.from_dict(user) for user in response.json()[\"value\"]]\n    return users\n</code></pre>"},{"location":"reference/services/userservice/#TM1py.Services.UserService.UserService.get_all","title":"<code>get_all(**kwargs)</code>","text":"<p>Get all users</p> <p>Returns:</p> Type Description <code>List[User]</code> <p>List of TM1py.User instances</p> Source code in <code>TM1py/Services/UserService.py</code> <pre><code>def get_all(self, **kwargs) -&gt; List[User]:\n    \"\"\"Get all users\n\n    :return: List of TM1py.User instances\n    \"\"\"\n    url = \"/Users?$expand=Groups\"\n    response = self._rest.GET(url, **kwargs)\n    users = [User.from_dict(user) for user in response.json()[\"value\"]]\n    return users\n</code></pre>"},{"location":"reference/services/userservice/#TM1py.Services.UserService.UserService.get_current","title":"<code>get_current(**kwargs)</code>","text":"Source code in <code>TM1py/Services/UserService.py</code> <pre><code>def get_current(self, **kwargs):\n    from TM1py import SecurityService\n\n    security_service = SecurityService(self._rest)\n    return security_service.get_current_user(**kwargs)\n</code></pre>"},{"location":"reference/services/userservice/#TM1py.Services.UserService.UserService.is_active","title":"<code>is_active(user_name, **kwargs)</code>","text":"<p>Check if user is currently active in TM1</p> <p>Parameters:</p> Name Type Description Default <code>user_name</code> <code>str</code> required <p>Returns:</p> Type Description <code>bool</code> <p>Boolean</p> Source code in <code>TM1py/Services/UserService.py</code> <pre><code>def is_active(self, user_name: str, **kwargs) -&gt; bool:\n    \"\"\"Check if user is currently active in TM1\n\n    :param user_name:\n    :return: Boolean\n    \"\"\"\n    url = format_url(\"/Users('{}')/IsActive\", user_name)\n    response = self._rest.GET(url, **kwargs)\n    return bool(response.json()[\"value\"])\n</code></pre>"},{"location":"reference/services/viewservice/","title":"ViewService","text":""},{"location":"reference/services/viewservice/#TM1py.Services.ViewService.ViewService","title":"<code>ViewService(rest)</code>","text":"<p>               Bases: <code>ObjectService</code></p> <p>Service to handle Object Updates for cube views (NativeViews and MDXViews)</p> Source code in <code>TM1py/Services/ViewService.py</code> <pre><code>def __init__(self, rest: RestService):\n    super().__init__(rest)\n</code></pre>"},{"location":"reference/services/viewservice/#TM1py.Services.ViewService.ViewService.create","title":"<code>create(view, private=False, **kwargs)</code>","text":"<p>create a new view on TM1 Server</p> <p>Parameters:</p> Name Type Description Default <code>view</code> <code>Union[MDXView, NativeView]</code> <p>instance of subclass of TM1py.View (TM1py.NativeView or TM1py.MDXView)</p> required <code>private</code> <code>bool</code> <p>boolean</p> <code>False</code> <p>Returns:</p> Type Description <code>Response</code> <p>Response</p> Source code in <code>TM1py/Services/ViewService.py</code> <pre><code>def create(self, view: Union[MDXView, NativeView], private: bool = False, **kwargs) -&gt; Response:\n    \"\"\"create a new view on TM1 Server\n\n    :param view: instance of subclass of TM1py.View (TM1py.NativeView or TM1py.MDXView)\n    :param private: boolean\n\n    :return: Response\n    \"\"\"\n    view_type = \"PrivateViews\" if private else \"Views\"\n    url = format_url(\"/Cubes('{}')/{}\", view.cube, view_type)\n    return self._rest.POST(url, view.body, **kwargs)\n</code></pre>"},{"location":"reference/services/viewservice/#TM1py.Services.ViewService.ViewService.delete","title":"<code>delete(cube_name, view_name, private=False, **kwargs)</code>","text":"<p>Delete an existing view (MDXView or NativeView) on the TM1 Server</p> <p>Parameters:</p> Name Type Description Default <code>cube_name</code> <code>str</code> <p>String, name of the cube</p> required <code>view_name</code> <code>str</code> <p>String, name of the view</p> required <code>private</code> <code>bool</code> <p>Boolean</p> <code>False</code> <p>Returns:</p> Type Description <code>Response</code> <p>String, the response</p> Source code in <code>TM1py/Services/ViewService.py</code> <pre><code>def delete(self, cube_name: str, view_name: str, private: bool = False, **kwargs) -&gt; Response:\n    \"\"\"Delete an existing view (MDXView or NativeView) on the TM1 Server\n\n    :param cube_name: String, name of the cube\n    :param view_name: String, name of the view\n    :param private: Boolean\n\n    :return: String, the response\n    \"\"\"\n    view_type = \"PrivateViews\" if private else \"Views\"\n    url = format_url(\"/Cubes('{}')/{}('{}')\", cube_name, view_type, view_name)\n    response = self._rest.DELETE(url, **kwargs)\n    return response\n</code></pre>"},{"location":"reference/services/viewservice/#TM1py.Services.ViewService.ViewService.exists","title":"<code>exists(cube_name, view_name, private=None, **kwargs)</code>","text":"<p>Checks if view exists as private, public or both</p> <p>Parameters:</p> Name Type Description Default <code>cube_name</code> <code>str</code> <p>string, name of the cube</p> required <code>view_name</code> <code>str</code> <p>string, name of the view</p> required <code>private</code> <code>bool</code> <p>boolean, if None: check for private and public</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[bool, bool]</code> <p>Boolean tuple (private_exists, public_exists)</p> Source code in <code>TM1py/Services/ViewService.py</code> <pre><code>def exists(self, cube_name: str, view_name: str, private: bool = None, **kwargs) -&gt; Tuple[bool, bool]:\n    \"\"\"Checks if view exists as private, public or both\n\n    :param cube_name:  string, name of the cube\n    :param view_name: string, name of the view\n    :param private: boolean, if None: check for private and public\n\n    :return: Boolean tuple (private_exists, public_exists)\n    :rtype: tuple[bool, bool]\n    \"\"\"\n    url_template = \"/Cubes('{}')/{}('{}')\"\n    if private is not None:\n        url = format_url(url_template, cube_name, \"PrivateViews\" if private else \"Views\", view_name)\n        return self._exists(url, **kwargs)\n\n    view_types = collections.OrderedDict()\n    view_types[\"PrivateViews\"] = False\n    view_types[\"Views\"] = False\n    for view_type in view_types:\n        try:\n            url = format_url(url_template, cube_name, view_type, view_name)\n            self._rest.GET(url, **kwargs)\n            view_types[view_type] = True\n        except TM1pyRestException as e:\n            if e.status_code != 404:\n                raise e\n    return tuple(view_types.values())\n</code></pre>"},{"location":"reference/services/viewservice/#TM1py.Services.ViewService.ViewService.get","title":"<code>get(cube_name, view_name, private=False, **kwargs)</code>","text":"Source code in <code>TM1py/Services/ViewService.py</code> <pre><code>def get(self, cube_name: str, view_name: str, private: bool = False, **kwargs) -&gt; View:\n    view_type = \"PrivateViews\" if private else \"Views\"\n    url = format_url(\"/Cubes('{}')/{}('{}')?$expand=*\", cube_name, view_type, view_name)\n    response = self._rest.GET(url, **kwargs)\n    view_as_dict = response.json()\n    if \"MDX\" in view_as_dict:\n        return MDXView(cube_name=cube_name, view_name=view_name, MDX=view_as_dict[\"MDX\"])\n    else:\n        return self.get_native_view(cube_name=cube_name, view_name=view_name, private=private)\n</code></pre>"},{"location":"reference/services/viewservice/#TM1py.Services.ViewService.ViewService.get_all","title":"<code>get_all(cube_name, include_elements=True, **kwargs)</code>","text":"<p>Get all public and private views from cube.</p> <p>Parameters:</p> Name Type Description Default <code>cube_name</code> <code>str</code> <p>String, name of the cube.</p> required <code>include_elements</code> <code>bool</code> <p>false to return view details without elements, faster</p> <code>True</code> <p>Returns:</p> Type Description <code>Tuple[List[View], List[View]]</code> <p>2 Lists of TM1py.View instances: private views, public views</p> Source code in <code>TM1py/Services/ViewService.py</code> <pre><code>def get_all(self, cube_name: str, include_elements: bool = True, **kwargs) -&gt; Tuple[List[View], List[View]]:\n    \"\"\"Get all public and private views from cube.\n    :param cube_name: String, name of the cube.\n    :param include_elements: false to return view details without elements, faster\n    :return: 2 Lists of TM1py.View instances: private views, public views\n    \"\"\"\n\n    element_filter = \";$top=0\" if not include_elements else \"\"\n\n    private_views, public_views = [], []\n    for view_type in (\"PrivateViews\", \"Views\"):\n        url = format_url(\n            \"/Cubes('{}')/{}?$expand=\"\n            \"tm1.NativeView/Rows/Subset($expand=Hierarchy($select=Name;\"\n            \"$expand=Dimension($select=Name)),Elements($select=Name{});\"\n            \"$select=Expression,UniqueName,Name, Alias),  \"\n            \"tm1.NativeView/Columns/Subset($expand=Hierarchy($select=Name;\"\n            \"$expand=Dimension($select=Name)),Elements($select=Name{});\"\n            \"$select=Expression,UniqueName,Name,Alias), \"\n            \"tm1.NativeView/Titles/Subset($expand=Hierarchy($select=Name;\"\n            \"$expand=Dimension($select=Name)),Elements($select=Name{});\"\n            \"$select=Expression,UniqueName,Name,Alias), \"\n            \"tm1.NativeView/Titles/Selected($select=Name)\",\n            cube_name,\n            view_type,\n            element_filter,\n            element_filter,\n            element_filter,\n        )\n        response = self._rest.GET(url, **kwargs)\n        response_as_list = response.json()[\"value\"]\n        for view_as_dict in response_as_list:\n            if view_as_dict[\"@odata.type\"] == \"#ibm.tm1.api.v1.MDXView\":\n                view = MDXView.from_dict(view_as_dict, cube_name)\n            else:\n                view = NativeView.from_dict(view_as_dict, cube_name)\n            if view_type == \"PrivateViews\":\n                private_views.append(view)\n            else:\n                public_views.append(view)\n    return private_views, public_views\n</code></pre>"},{"location":"reference/services/viewservice/#TM1py.Services.ViewService.ViewService.get_all_names","title":"<code>get_all_names(cube_name, **kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>cube_name</code> <code>str</code> required <p>Returns:</p> Type Description <code>Tuple[List[str], List[str]]</code> Source code in <code>TM1py/Services/ViewService.py</code> <pre><code>def get_all_names(self, cube_name: str, **kwargs) -&gt; Tuple[List[str], List[str]]:\n    \"\"\"\n\n    :param cube_name:\n    :return:\n    \"\"\"\n    private_views, public_views = [], []\n    for view_type in (\"PrivateViews\", \"Views\"):\n        url = format_url(\"/Cubes('{}')/{}?$select=Name\", cube_name, view_type)\n        response = self._rest.GET(url, **kwargs)\n        response_as_list = response.json()[\"value\"]\n\n        for view in response_as_list:\n            if view_type == \"PrivateViews\":\n                private_views.append(view[\"Name\"])\n            else:\n                public_views.append(view[\"Name\"])\n\n    return private_views, public_views\n</code></pre>"},{"location":"reference/services/viewservice/#TM1py.Services.ViewService.ViewService.get_mdx_view","title":"<code>get_mdx_view(cube_name, view_name, private=False, **kwargs)</code>","text":"<p>Get an MDXView from TM1 Server</p> <p>Parameters:</p> Name Type Description Default <code>cube_name</code> <code>str</code> <p>String, name of the cube</p> required <code>view_name</code> <code>str</code> <p>String, name of the MDX view</p> required <code>private</code> <code>bool</code> <p>boolean</p> <code>False</code> <p>Returns:</p> Type Description <code>MDXView</code> <p>instance of TM1py.MDXView</p> Source code in <code>TM1py/Services/ViewService.py</code> <pre><code>def get_mdx_view(self, cube_name: str, view_name: str, private: bool = False, **kwargs) -&gt; MDXView:\n    \"\"\"Get an MDXView from TM1 Server\n\n    :param cube_name: String, name of the cube\n    :param view_name: String, name of the MDX view\n    :param private: boolean\n\n    :return: instance of TM1py.MDXView\n    \"\"\"\n    view_type = \"PrivateViews\" if private else \"Views\"\n    url = format_url(\"/Cubes('{}')/{}('{}')?$expand=*\", cube_name, view_type, view_name)\n    response = self._rest.GET(url, **kwargs)\n    mdx_view = MDXView.from_json(view_as_json=response.text)\n    return mdx_view\n</code></pre>"},{"location":"reference/services/viewservice/#TM1py.Services.ViewService.ViewService.get_native_view","title":"<code>get_native_view(cube_name, view_name, private=False, **kwargs)</code>","text":"<p>Get a NativeView from TM1 Server</p> <p>Parameters:</p> Name Type Description Default <code>cube_name</code> <code>str</code> <p>string, name of the cube</p> required <code>view_name</code> <code>str</code> <p>string, name of the native view</p> required <code>private</code> <p>boolean</p> <code>False</code> <p>Returns:</p> Type Description <code>NativeView</code> <p>instance of TM1py.NativeView</p> Source code in <code>TM1py/Services/ViewService.py</code> <pre><code>def get_native_view(self, cube_name: str, view_name: str, private=False, **kwargs) -&gt; NativeView:\n    \"\"\"Get a NativeView from TM1 Server\n\n    :param cube_name:  string, name of the cube\n    :param view_name:  string, name of the native view\n    :param private:    boolean\n\n    :return: instance of TM1py.NativeView\n    \"\"\"\n    view_type = \"PrivateViews\" if private else \"Views\"\n    url = format_url(\n        \"/Cubes('{}')/{}('{}')?$expand=\"\n        \"tm1.NativeView/Rows/Subset($expand=Hierarchy($select=Name;\"\n        \"$expand=Dimension($select=Name)),Elements($select=Name);\"\n        \"$select=Expression,UniqueName,Name, Alias),  \"\n        \"tm1.NativeView/Columns/Subset($expand=Hierarchy($select=Name;\"\n        \"$expand=Dimension($select=Name)),Elements($select=Name);\"\n        \"$select=Expression,UniqueName,Name,Alias), \"\n        \"tm1.NativeView/Titles/Subset($expand=Hierarchy($select=Name;\"\n        \"$expand=Dimension($select=Name)),Elements($select=Name);\"\n        \"$select=Expression,UniqueName,Name,Alias), \"\n        \"tm1.NativeView/Titles/Selected($select=Name)\",\n        cube_name,\n        view_type,\n        view_name,\n    )\n    response = self._rest.GET(url, **kwargs)\n    native_view = NativeView.from_json(response.text, cube_name)\n    return native_view\n</code></pre>"},{"location":"reference/services/viewservice/#TM1py.Services.ViewService.ViewService.is_mdx_view","title":"<code>is_mdx_view(cube_name, view_name, private=False, **kwargs)</code>","text":"Source code in <code>TM1py/Services/ViewService.py</code> <pre><code>def is_mdx_view(self, cube_name: str, view_name: str, private=False, **kwargs):\n    url_template = \"/Cubes('{}')/{}('{}')?select=Name\"\n    if private is not None:\n        url = format_url(url_template, cube_name, \"PrivateViews\" if private else \"Views\", view_name)\n\n    response = self._rest.GET(url, **kwargs)\n    # e.g.: \"ibm.tm1.api.v1.NativeView\"\n    odata_type = response.json()[\"@odata.type\"]\n    if odata_type.split(\".\")[-1] == \"NativeView\":\n        return False\n    return True\n</code></pre>"},{"location":"reference/services/viewservice/#TM1py.Services.ViewService.ViewService.is_native_view","title":"<code>is_native_view(cube_name, view_name, private=False)</code>","text":"Source code in <code>TM1py/Services/ViewService.py</code> <pre><code>def is_native_view(self, cube_name: str, view_name: str, private=False):\n    return not self.is_mdx_view(cube_name, view_name, private)\n</code></pre>"},{"location":"reference/services/viewservice/#TM1py.Services.ViewService.ViewService.search_subset_in_native_views","title":"<code>search_subset_in_native_views(dimension_name=None, subset_name=None, cube_name=None, include_elements=False, **kwargs)</code>","text":"<p>Get all public and private native views that utilize specified dimension subset</p> <p>Parameters:</p> Name Type Description Default <code>dimension_name</code> <code>str</code> <p>string, valid dimension name with subset to query</p> <code>None</code> <code>subset_name</code> <code>str</code> <p>string, valid subset name to search for in views</p> <code>None</code> <code>cube_name</code> <code>str</code> <p>str, optionally specify cube to search, otherwise will search all cubes</p> <code>None</code> <code>include_elements</code> <code>bool</code> <p>false to return view details without elements, faster</p> <code>False</code> <p>Returns:</p> Type Description <code>Tuple[List[View], List[View]]</code> <p>2 Lists of TM1py.View instances: private views, public views</p> Source code in <code>TM1py/Services/ViewService.py</code> <pre><code>def search_subset_in_native_views(\n    self,\n    dimension_name: str = None,\n    subset_name: str = None,\n    cube_name: str = None,\n    include_elements: bool = False,\n    **kwargs,\n) -&gt; Tuple[List[View], List[View]]:\n    \"\"\"Get all public and private native views that utilize specified dimension subset\n\n    :param dimension_name: string, valid dimension name with subset to query\n    :param subset_name: string, valid subset name to search for in views\n    :param cube_name: str, optionally specify cube to search, otherwise will search all cubes\n    :param include_elements: false to return view details without elements, faster\n    :return: 2 Lists of TM1py.View instances: private views, public views\n    \"\"\"\n\n    dimension_name = dimension_name.lower().replace(\" \", \"\")\n    subset_name = subset_name.lower().replace(\" \", \"\")\n\n    element_filter = \";$top=0\" if not include_elements else \"\"\n    if cube_name:\n        base_url = format_url(\n            \"/Cubes?$select=Name&amp;$filter=replace(tolower(Name),' ', '') eq '{}'\", cube_name.lower().replace(\" \", \"\")\n        )\n    else:\n        base_url = \"/Cubes?$select=Name\"\n\n    private_views, public_views = [], []\n    for view_type in (\"PrivateViews\", \"Views\"):\n        url = base_url + format_url(\n            \"&amp;$expand={}($filter=isof(tm1.NativeView) and\"\n            \"(\"\n            \"(tm1.NativeView/Rows/any (r: replace(tolower(r/Subset/Name), ' ', '') eq '{}' \"\n            \"and replace(tolower(r/Subset/Hierarchy/Dimension/Name), ' ', '') eq '{}'))\"\n            \"or\"\n            \"(tm1.NativeView/Columns/any (c: replace(tolower(c/Subset/Name), ' ', '') eq '{}' \"\n            \"and replace(tolower(c/Subset/Hierarchy/Dimension/Name), ' ', '') eq '{}')) \"\n            \"or\"\n            \"(tm1.NativeView/Titles/any (t: replace(tolower(t/Subset/Name), ' ', '') eq '{}' \"\n            \"and replace(tolower(t/Subset/Hierarchy/Dimension/Name), ' ', '') eq '{}'))\"\n            \");\"\n            \"$expand=tm1.NativeView/Rows/Subset($expand=Hierarchy($select=Name;\"\n            \"$expand=Dimension($select=Name)),Elements($select=Name{});\"\n            \"$select=Expression,UniqueName,Name, Alias),  \"\n            \"tm1.NativeView/Columns/Subset($expand=Hierarchy($select=Name;\"\n            \"$expand=Dimension($select=Name)),Elements($select=Name{});\"\n            \"$select=Expression,UniqueName,Name,Alias), \"\n            \"tm1.NativeView/Titles/Subset($expand=Hierarchy($select=Name;\"\n            \"$expand=Dimension($select=Name)),Elements($select=Name{});\"\n            \"$select=Expression,UniqueName,Name,Alias), \"\n            \"tm1.NativeView/Titles/Selected($select=Name))\",\n            view_type,\n            subset_name,\n            dimension_name,\n            subset_name,\n            dimension_name,\n            subset_name,\n            dimension_name,\n            element_filter,\n            element_filter,\n            element_filter,\n        )\n\n        response = self._rest.GET(url, **kwargs)\n        response_as_list = response.json()[\"value\"]\n        for cube in response_as_list:\n            for view_as_dict in cube[view_type]:\n                view = NativeView.from_dict(view_as_dict, cube[\"Name\"])\n                if view_type == \"PrivateViews\":\n                    private_views.append(view)\n                else:\n                    public_views.append(view)\n\n    return private_views, public_views\n</code></pre>"},{"location":"reference/services/viewservice/#TM1py.Services.ViewService.ViewService.update","title":"<code>update(view, private=False, **kwargs)</code>","text":"<p>Update an existing view</p> <p>Parameters:</p> Name Type Description Default <code>view</code> <code>Union[MDXView, NativeView]</code> <p>instance of TM1py.NativeView or TM1py.MDXView</p> required <code>private</code> <code>bool</code> <p>boolean</p> <code>False</code> <p>Returns:</p> Type Description <code>Response</code> <p>response</p> Source code in <code>TM1py/Services/ViewService.py</code> <pre><code>def update(self, view: Union[MDXView, NativeView], private: bool = False, **kwargs) -&gt; Response:\n    \"\"\"Update an existing view\n\n    :param view: instance of TM1py.NativeView or TM1py.MDXView\n    :param private: boolean\n    :return: response\n    \"\"\"\n    view_type = \"PrivateViews\" if private else \"Views\"\n    url = format_url(\"/Cubes('{}')/{}('{}')\", view.cube, view_type, view.name)\n    response = self._rest.PATCH(url, view.body, **kwargs)\n    return response\n</code></pre>"},{"location":"reference/services/viewservice/#TM1py.Services.ViewService.ViewService.update_or_create","title":"<code>update_or_create(view, private=False, **kwargs)</code>","text":"<p>update if exists, else create</p> <p>Parameters:</p> Name Type Description Default <code>view</code> <code>Union[MDXView, NativeView]</code> required <code>private</code> <code>bool</code> <code>False</code> <code>kwargs</code> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> Source code in <code>TM1py/Services/ViewService.py</code> <pre><code>def update_or_create(self, view: Union[MDXView, NativeView], private: bool = False, **kwargs) -&gt; Response:\n    \"\"\"update if exists, else create\n\n    :param view:\n    :param private:\n    :param kwargs:\n    :return:\n    \"\"\"\n    if self.exists(view.cube, view.name, private=private, **kwargs):\n        return self.update(view, private=private, **kwargs)\n\n    return self.create(view, private=private, **kwargs)\n</code></pre>"},{"location":"reference/utils/mdxutils/","title":"MDXUtils","text":""},{"location":"reference/utils/mdxutils/#TM1py.Utils.MDXUtils.DimensionSelection","title":"<code>DimensionSelection(dimension_name, elements=None, subset=None, expression=None)</code>","text":"<p>Instances of this class to be passed to construct_mdx function</p> Source code in <code>TM1py/Utils/MDXUtils.py</code> <pre><code>def __init__(self, dimension_name, elements=None, subset=None, expression=None):\n    warnings.warn(\n        \"class DimensionSelection will be deprecated. Use https://github.com/cubewise-code/mdxpy instead\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    self.dimension_name = dimension_name\n    self.selection_type = self.determine_selection_type(elements, subset, expression)\n    if self.selection_type == self.SUBSET:\n        self.expression = curly_braces(\n            expression=\"Tm1SubsetToSet([{dimension}], '{subset}')\".format(dimension=dimension_name, subset=subset)\n        )\n    elif self.selection_type == self.EXPRESSION:\n        self.expression = curly_braces(expression=expression)\n    elif self.selection_type == self.ITERABLE:\n        self.expression = curly_braces(\n            expression=\",\".join([\"[{}].[{}]\".format(dimension_name, element) for element in elements])\n        )\n    elif not self.selection_type:\n        self.expression = curly_braces(expression=\"TM1SubsetAll([{dimension}])\".format(dimension=dimension_name))\n</code></pre>"},{"location":"reference/utils/mdxutils/#TM1py.Utils.MDXUtils.DimensionSelection.EXPRESSION","title":"<code>EXPRESSION = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/utils/mdxutils/#TM1py.Utils.MDXUtils.DimensionSelection.ITERABLE","title":"<code>ITERABLE = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/utils/mdxutils/#TM1py.Utils.MDXUtils.DimensionSelection.SUBSET","title":"<code>SUBSET = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/utils/mdxutils/#TM1py.Utils.MDXUtils.DimensionSelection.dimension_name","title":"<code>dimension_name = dimension_name</code>  <code>instance-attribute</code>","text":""},{"location":"reference/utils/mdxutils/#TM1py.Utils.MDXUtils.DimensionSelection.expression","title":"<code>expression = curly_braces(expression=(\"Tm1SubsetToSet([{dimension}], '{subset}')\".format(dimension=dimension_name, subset=subset)))</code>  <code>instance-attribute</code>","text":""},{"location":"reference/utils/mdxutils/#TM1py.Utils.MDXUtils.DimensionSelection.selection_type","title":"<code>selection_type = self.determine_selection_type(elements, subset, expression)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/utils/mdxutils/#TM1py.Utils.MDXUtils.DimensionSelection.determine_selection_type","title":"<code>determine_selection_type(elements=None, subset=None, expression=None)</code>  <code>staticmethod</code>","text":"Source code in <code>TM1py/Utils/MDXUtils.py</code> <pre><code>@staticmethod\ndef determine_selection_type(elements=None, subset=None, expression=None):\n    warnings.warn(\n        \"Module MdxUtils will be deprecated. Use https://github.com/cubewise-code/mdxpy instead\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    if elements is not None and subset is None and expression is None:\n        return DimensionSelection.ITERABLE\n    elif elements is None and subset is not None and expression is None:\n        return DimensionSelection.SUBSET\n    elif elements is None and subset is None and expression is not None:\n        return DimensionSelection.EXPRESSION\n    elif elements is None and subset is None and expression is None:\n        return None\n    else:\n        raise ValueError(\n            \"DimensionSelection constructor takes one type of selection only: \" \"elements, subset or expression\"\n        )\n</code></pre>"},{"location":"reference/utils/mdxutils/#TM1py.Utils.MDXUtils.construct_mdx","title":"<code>construct_mdx(cube_name, rows, columns, contexts=None, suppress=None)</code>","text":"<p>Method to construct MDX Query from different dimension selection</p> <p>Parameters:</p> Name Type Description Default <code>cube_name</code> <p>Name of the Cube</p> required <code>rows</code> <p>List of DimensionSelections</p> required <code>columns</code> <p>List of DimensionSelections</p> required <code>contexts</code> <p>Dictionary of Dimensions and Elements</p> <code>None</code> <code>suppress</code> <p>\"Both\", \"Rows\", \"Columns\" or None</p> <code>None</code> <p>Returns:</p> Type Description <p>Generated MDX Query</p> Source code in <code>TM1py/Utils/MDXUtils.py</code> <pre><code>def construct_mdx(cube_name, rows, columns, contexts=None, suppress=None):\n    \"\"\"Method to construct MDX Query from different dimension selection\n\n    :param cube_name: Name of the Cube\n    :param rows: List of DimensionSelections\n    :param columns: List of DimensionSelections\n    :param contexts: Dictionary of Dimensions and Elements\n    :param suppress: \"Both\", \"Rows\", \"Columns\" or None\n    :return: Generated MDX Query\n    \"\"\"\n    warnings.warn(\n        \"Module MdxUtils will be deprecated. Use https://github.com/cubewise-code/mdxpy instead\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    # MDX Skeleton\n    mdx_template = \"SELECT {}{} ON ROWS, {}{} ON COLUMNS FROM [{}] {}\"\n    # Suppression\n    mdx_rows_suppress = \"NON EMPTY \" if suppress and suppress.upper() in [\"ROWS\", \"BOTH\"] else \"\"\n    mdx_columns_suppress = \"NON EMPTY \" if suppress and suppress.upper() in [\"COLUMNS\", \"BOTH\"] else \"\"\n    # Rows and Columns\n    mdx_rows = construct_mdx_axis(rows)\n    mdx_columns = construct_mdx_axis(columns)\n    # Context filter (where statement)\n    mdx_where = \"\"\n    if contexts:\n        mdx_where_parts = [\"[{}].[{}]\".format(dim, elem) for dim, elem in contexts.items()]\n        mdx_where = \"\".join([\"WHERE (\", \",\".join(mdx_where_parts), \")\"])\n    # Return Full MDX\n    return mdx_template.format(mdx_rows_suppress, mdx_rows, mdx_columns_suppress, mdx_columns, cube_name, mdx_where)\n</code></pre>"},{"location":"reference/utils/mdxutils/#TM1py.Utils.MDXUtils.construct_mdx_axis","title":"<code>construct_mdx_axis(dim_selections)</code>","text":"<p>Construct MDX for one Axis (Row or Column). Can have multiple dimensions stacked.</p> <p>Parameters:</p> Name Type Description Default <code>dim_selections</code> <p>instances of TM1py.Utils.MDXUtils.DimensionSelection</p> required <p>Returns:</p> Type Description <p>a valid MDX for an Axis</p> Source code in <code>TM1py/Utils/MDXUtils.py</code> <pre><code>def construct_mdx_axis(dim_selections):\n    \"\"\"Construct MDX for one Axis (Row or Column).\n    Can have multiple dimensions stacked.\n\n    :param dim_selections: instances of TM1py.Utils.MDXUtils.DimensionSelection\n    :return: a valid MDX for an Axis\n    \"\"\"\n    warnings.warn(\n        \"Module MdxUtils will be deprecated. Use https://github.com/cubewise-code/mdxpy instead\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    return \"*\".join(selection.expression for selection in dim_selections)\n</code></pre>"},{"location":"reference/utils/mdxutils/#TM1py.Utils.MDXUtils.curly_braces","title":"<code>curly_braces(expression)</code>","text":"<p>Put curly braces around a string</p> <p>Parameters:</p> Name Type Description Default <code>expression</code> required <p>Returns:</p> Type Description Source code in <code>TM1py/Utils/MDXUtils.py</code> <pre><code>def curly_braces(expression):\n    \"\"\"Put curly braces around a string\n\n    :param expression:\n    :return:\n    \"\"\"\n    warnings.warn(\n        \"Module MdxUtils will be deprecated. Use https://github.com/cubewise-code/mdxpy instead\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    return \"\".join(\n        [\"{\" if not expression.startswith(\"{\") else \"\", expression, \"}\" if not expression.endswith(\"}\") else \"\"]\n    )\n</code></pre>"},{"location":"reference/utils/mdxutils/#TM1py.Utils.MDXUtils.read_cube_name_from_mdx","title":"<code>read_cube_name_from_mdx(mdx)</code>","text":"<p>Read the cube name from a valid MDX Query</p> <p>Parameters:</p> Name Type Description Default <code>mdx</code> <p>The MDX Query as String</p> required <p>Returns:</p> Type Description <p>String, name of a cube</p> Source code in <code>TM1py/Utils/MDXUtils.py</code> <pre><code>def read_cube_name_from_mdx(mdx):\n    \"\"\"Read the cube name from a valid MDX Query\n\n    :param mdx: The MDX Query as String\n    :return: String, name of a cube\n    \"\"\"\n    warnings.warn(\n        \"Module MdxUtils will be deprecated. Use https://github.com/cubewise-code/mdxpy instead\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    cube, _, _, _ = read_dimension_composition_from_mdx(mdx)\n    return cube\n</code></pre>"},{"location":"reference/utils/mdxutils/#TM1py.Utils.MDXUtils.read_dimension_composition_from_mdx","title":"<code>read_dimension_composition_from_mdx(mdx)</code>","text":"<p>Parse a valid MDX Query and return the name of the cube and a list of dimensions for each axis</p> <p>Parameters:</p> Name Type Description Default <code>mdx</code> required <p>Returns:</p> Type Description Source code in <code>TM1py/Utils/MDXUtils.py</code> <pre><code>def read_dimension_composition_from_mdx(mdx):\n    \"\"\"Parse a valid MDX Query and return the name of the cube and a list of dimensions for each axis\n\n    :param mdx:\n    :return:\n    \"\"\"\n    warnings.warn(\n        \"Module MdxUtils will be deprecated. Use https://github.com/cubewise-code/mdxpy instead\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    mdx_rows, mdx_columns, mdx_from, mdx_where = split_mdx(mdx)\n\n    cube = mdx_from[1:-1]\n    rows = read_dimension_composition_from_mdx_set_or_tuple(mdx_rows)\n    columns = read_dimension_composition_from_mdx_set_or_tuple(mdx_columns)\n    titles = read_dimension_composition_from_mdx_set_or_tuple(mdx_where)\n\n    return cube, rows, columns, titles\n</code></pre>"},{"location":"reference/utils/mdxutils/#TM1py.Utils.MDXUtils.read_dimension_composition_from_mdx_set","title":"<code>read_dimension_composition_from_mdx_set(mdx)</code>","text":"Source code in <code>TM1py/Utils/MDXUtils.py</code> <pre><code>def read_dimension_composition_from_mdx_set(mdx):\n    warnings.warn(\n        \"Module MdxUtils will be deprecated. Use https://github.com/cubewise-code/mdxpy instead\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    dimensions = []\n    mdx_without_spaces = \"\".join(mdx.split())\n    for sub_mdx in mdx_without_spaces.split(\"}*{\"):\n        pos_start, pos_end = sub_mdx.find(\"[\"), sub_mdx.find(\"]\")\n        dimension_name = sub_mdx[pos_start + 1 : pos_end]\n        dimensions.append(dimension_name)\n    return dimensions\n</code></pre>"},{"location":"reference/utils/mdxutils/#TM1py.Utils.MDXUtils.read_dimension_composition_from_mdx_set_or_tuple","title":"<code>read_dimension_composition_from_mdx_set_or_tuple(mdx)</code>","text":"Source code in <code>TM1py/Utils/MDXUtils.py</code> <pre><code>def read_dimension_composition_from_mdx_set_or_tuple(mdx):\n    warnings.warn(\n        \"Module MdxUtils will be deprecated. Use https://github.com/cubewise-code/mdxpy instead\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    mdx_without_spaces = \"\".join(mdx.split())\n    # case for mdx statement no where statement\n    if len(mdx_without_spaces) == 0:\n        return []\n    # case for tuples mdx statement on rows or columns\n    if mdx_without_spaces[1] == \"(\" and mdx_without_spaces[-2] == \")\":\n        return read_dimension_composition_from_mdx_tuple(mdx)\n    # case for where mdx statement\n    elif mdx_without_spaces[0] == \"(\" and mdx_without_spaces[-1] == \")\":\n        return read_dimension_composition_from_mdx_tuple(mdx)\n    # case for set mdx statement on rows or columns\n    else:\n        return read_dimension_composition_from_mdx_set(mdx)\n</code></pre>"},{"location":"reference/utils/mdxutils/#TM1py.Utils.MDXUtils.read_dimension_composition_from_mdx_tuple","title":"<code>read_dimension_composition_from_mdx_tuple(mdx)</code>","text":"Source code in <code>TM1py/Utils/MDXUtils.py</code> <pre><code>def read_dimension_composition_from_mdx_tuple(mdx):\n    warnings.warn(\n        \"Module MdxUtils will be deprecated. Use https://github.com/cubewise-code/mdxpy instead\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    dimensions = []\n    for unique_member_name in mdx.split(\",\"):\n        pos_start, pos_end = unique_member_name.find(\"[\"), unique_member_name.find(\"]\")\n        dimension_name = unique_member_name[pos_start + 1 : pos_end]\n        # only parse through first tuple of potentially many tuples\n        if dimension_name in dimensions:\n            return dimensions\n        dimensions.append(dimension_name)\n    return dimensions\n</code></pre>"},{"location":"reference/utils/mdxutils/#TM1py.Utils.MDXUtils.split_mdx","title":"<code>split_mdx(mdx)</code>","text":"Source code in <code>TM1py/Utils/MDXUtils.py</code> <pre><code>def split_mdx(mdx):\n    warnings.warn(\n        \"Module MdxUtils will be deprecated. Use https://github.com/cubewise-code/mdxpy instead\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    try:\n        mdx_rows, mdx_rest = _find_case_and_space_insensitive_first_occurrence(\n            text=mdx, pattern_start=\"{\", pattern_end=\"}ONROWS\"\n        )\n        mdx_columns, mdx_rest = _find_case_and_space_insensitive_first_occurrence(\n            text=mdx_rest, pattern_start=\"{\", pattern_end=\"}ONCOLUMNSFROM\"\n        )\n        mdx_from, mdx_where = _find_case_and_space_insensitive_first_occurrence(text=mdx_rest, pattern_end=\"]WHERE\")\n        return mdx_rows, mdx_columns, mdx_from, mdx_where\n    except ValueError:\n        ValueError(\"Can't parse mdx: {}\".format(mdx))\n</code></pre>"},{"location":"reference/utils/utils/","title":"Utils","text":""},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveDict","title":"<code>CaseAndSpaceInsensitiveDict(data=None, **kwargs)</code>","text":"<p>               Bases: <code>MutableMapping</code></p> <p>A case-and-space-insensitive dict-like object with string keys.</p> <p>This class implements all methods and operations of <code>collections.abc.MutableMapping</code>, as well as dict's <code>copy</code>. It also provides <code>adjusted_items</code> and <code>adjusted_keys</code>. All keys are expected to be strings.</p> <p>The structure remembers the case of the last key set, and methods like <code>__iter__</code>, <code>keys()</code>, <code>items()</code>, etc., will contain case-sensitive keys.</p> <p>However, querying and membership tests are case-and-space-insensitive:     data = CaseAndSpaceInsensitiveDict()     data['Travel Expenses'] = 100     assert data['travelexpenses'] == 100  # True</p> <p>Entries are ordered.</p> <p>Initialize the dictionary with optional initial data.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def __init__(self, data=None, **kwargs):\n    \"\"\"Initialize the dictionary with optional initial data.\"\"\"\n    self._store = collections.OrderedDict()\n    if data is None:\n        data = {}\n    self.update(data, **kwargs)\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveDict.__contains__","title":"<code>__contains__(key)</code>","text":"<p>Check if the key exists in the dictionary.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def __contains__(self, key):\n    \"\"\"Check if the key exists in the dictionary.\"\"\"\n    adjusted_key = self._adjust_key(key)\n    return adjusted_key in self._store\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveDict.__delitem__","title":"<code>__delitem__(key)</code>","text":"<p>Delete the item associated with the key.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def __delitem__(self, key):\n    \"\"\"Delete the item associated with the key.\"\"\"\n    adjusted_key = self._adjust_key(key)\n    try:\n        del self._store[adjusted_key]\n    except KeyError:\n        raise KeyError(f\"Key '{key}' not found.\") from None\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveDict.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Check equality with another dictionary.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Check equality with another dictionary.\"\"\"\n    if isinstance(other, collections.abc.Mapping):\n        other = CaseAndSpaceInsensitiveDict(other)\n    else:\n        return NotImplemented\n    return dict(self.adjusted_items()) == dict(other.adjusted_items())\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveDict.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Retrieve the value for a key, using the adjusted key.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def __getitem__(self, key):\n    \"\"\"Retrieve the value for a key, using the adjusted key.\"\"\"\n    adjusted_key = self._adjust_key(key)\n    try:\n        return self._store[adjusted_key][1]\n    except KeyError:\n        raise KeyError(f\"Key '{key}' not found.\") from None\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveDict.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate over the keys in their original case.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over the keys in their original case.\"\"\"\n    return (key for key, _ in self._store.values())\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveDict.__len__","title":"<code>__len__()</code>","text":"Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def __len__(self):\n    return len(self._store)\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveDict.__repr__","title":"<code>__repr__()</code>","text":"<p>Return the dictionary's string representation.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def __repr__(self):\n    \"\"\"Return the dictionary's string representation.\"\"\"\n    items = \", \".join(f\"{key!r}: {value!r}\" for key, value in self.items())\n    return f\"{self.__class__.__name__}({{{items}}})\"\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveDict.__setitem__","title":"<code>__setitem__(key, value)</code>","text":"<p>Set the value for a key, adjusting the key as needed.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def __setitem__(self, key, value):\n    \"\"\"Set the value for a key, adjusting the key as needed.\"\"\"\n    adjusted_key = self._adjust_key(key)\n    self._store[adjusted_key] = (key, value)\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveDict.__str__","title":"<code>__str__()</code>","text":"<p>Return a user-friendly string representation.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def __str__(self):\n    \"\"\"Return a user-friendly string representation.\"\"\"\n    return repr(self)\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveDict.adjusted_items","title":"<code>adjusted_items()</code>","text":"<p>Return a generator of (adjusted_key, value) pairs.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def adjusted_items(self):\n    \"\"\"Return a generator of (adjusted_key, value) pairs.\"\"\"\n    return ((adjusted_key, key_value[1]) for adjusted_key, key_value in self._store.items())\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveDict.adjusted_keys","title":"<code>adjusted_keys()</code>","text":"<p>Return a generator of the adjusted keys.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def adjusted_keys(self):\n    \"\"\"Return a generator of the adjusted keys.\"\"\"\n    return (adjusted_key for adjusted_key in self._store.keys())\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveDict.clear","title":"<code>clear()</code>","text":"<p>Remove all items from the dictionary.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def clear(self):\n    \"\"\"Remove all items from the dictionary.\"\"\"\n    self._store.clear()\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveDict.copy","title":"<code>copy()</code>","text":"Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def copy(self):\n    return CaseAndSpaceInsensitiveDict(self._store.values())\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveDict.get","title":"<code>get(key, default=None)</code>","text":"<p>Return the value for key if key is in the dictionary, else default.</p> <p>Parameters:     key (str): The key to look up.     default: The value to return if the key is not found.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def get(self, key, default=None):\n    \"\"\"\n    Return the value for key if key is in the dictionary, else default.\n\n    Parameters:\n        key (str): The key to look up.\n        default: The value to return if the key is not found.\n    \"\"\"\n    try:\n        return self[key]\n    except KeyError:\n        return default\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveDict.items","title":"<code>items()</code>","text":"<p>Return a view of the items in their original case.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def items(self):\n    \"\"\"Return a view of the items in their original case.\"\"\"\n    return [(key, value) for key, value in self._store.values()]\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveDict.keys","title":"<code>keys()</code>","text":"<p>Return a view of the keys in their original case.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def keys(self):\n    \"\"\"Return a view of the keys in their original case.\"\"\"\n    return [key for key, _ in self._store.values()]\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveDict.pop","title":"<code>pop(key, default=None)</code>","text":"<p>Remove the specified key and return the corresponding value. If key is not found, default is returned if provided, otherwise KeyError is raised.</p> <p>Parameters:     key (str): The key to remove.     default: The value to return if the key is not found.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def pop(self, key, default=None):\n    \"\"\"\n    Remove the specified key and return the corresponding value.\n    If key is not found, default is returned if provided, otherwise KeyError is raised.\n\n    Parameters:\n        key (str): The key to remove.\n        default: The value to return if the key is not found.\n    \"\"\"\n    adjusted_key = self._adjust_key(key)\n    try:\n        value = self._store.pop(adjusted_key)[1]\n        return value\n    except KeyError:\n        if default is not None:\n            return default\n        else:\n            raise KeyError(f\"Key '{key}' not found.\") from None\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveDict.popitem","title":"<code>popitem()</code>","text":"<p>Remove and return a (key, value) pair from the dictionary. Pairs are returned in LIFO order.</p> <p>Raises:     KeyError: If the dictionary is empty.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def popitem(self):\n    \"\"\"\n    Remove and return a (key, value) pair from the dictionary.\n    Pairs are returned in LIFO order.\n\n    Raises:\n        KeyError: If the dictionary is empty.\n    \"\"\"\n    adjusted_key, (key, value) = self._store.popitem()\n    return key, value\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveDict.setdefault","title":"<code>setdefault(key, default=None)</code>","text":"<p>If key is in the dictionary, return its value. If not, insert key with a value of default and return default.</p> <p>Parameters:     key (str): The key to look up or insert.     default: The value to set if the key is not found.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def setdefault(self, key, default=None):\n    \"\"\"\n    If key is in the dictionary, return its value.\n    If not, insert key with a value of default and return default.\n\n    Parameters:\n        key (str): The key to look up or insert.\n        default: The value to set if the key is not found.\n    \"\"\"\n    if key in self:\n        return self[key]\n    else:\n        self[key] = default\n        return default\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveDict.update","title":"<code>update(other=(), **kwargs)</code>","text":"<p>Update the dictionary with key/value pairs from other, overwriting existing keys.</p> <p>Parameters:     other (Mapping or Iterable): A mapping or iterable of key-value pairs.     **kwargs: Additional key-value pairs.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def update(self, other=(), **kwargs):\n    \"\"\"\n    Update the dictionary with key/value pairs from other, overwriting existing keys.\n\n    Parameters:\n        other (Mapping or Iterable): A mapping or iterable of key-value pairs.\n        **kwargs: Additional key-value pairs.\n    \"\"\"\n    if isinstance(other, collections.abc.Mapping):\n        for key, value in other.items():\n            self[key] = value\n\n    elif hasattr(other, \"__iter__\"):\n        for item in other:\n            if not isinstance(item, collections.abc.Iterable):\n                raise TypeError(\"Items must be key-value pairs.\")\n            key, value = item\n            self[key] = value\n\n    elif other:\n        raise TypeError(\"Other object is not a mapping or iterable of key-value pairs.\")\n\n    for key, value in kwargs.items():\n        self[key] = value\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveDict.values","title":"<code>values()</code>","text":"<p>Return a view of the values.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def values(self):\n    \"\"\"Return a view of the values.\"\"\"\n    return [value for _, value in self._store.values()]\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveSet","title":"<code>CaseAndSpaceInsensitiveSet(*values)</code>","text":"<p>               Bases: <code>MutableSet</code></p> <p>A case-and-space-insensitive set-like object for strings.</p> <p>This class implements all methods and operations of <code>collections.abc.MutableSet</code>. All values are expected to be strings. The set remembers the case of the last value added, and methods like <code>__iter__</code> and <code>__str__</code> will contain case-sensitive values.</p> <p>However, membership tests are case-and-space-insensitive:     data = CaseAndSpaceInsensitiveSet('Apple', 'Banana')     assert 'apple' in data         # True     assert '  BANANA ' in data     # True</p> <p>Entries are ordered based on insertion order.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def __init__(self, *values):\n    self._store = {}\n    for v in values:\n        if isinstance(v, str):\n            self.add(v)\n        elif isinstance(v, Iterable):\n            for item in v:\n                self.add(item)\n        else:\n            self.add(v)\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveSet.__and__","title":"<code>__and__(other)</code>","text":"<p>Return the intersection of the sets as a new set.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def __and__(self, other):\n    \"\"\"Return the intersection of the sets as a new set.\"\"\"\n    return self.intersection(other)\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveSet.__contains__","title":"<code>__contains__(value)</code>","text":"Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def __contains__(self, value):\n    adjusted_value = self._adjust_value(value)\n    return adjusted_value in self._store\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveSet.__delitem__","title":"<code>__delitem__(key)</code>","text":"Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def __delitem__(self, key):\n    del self._store[key.lower().replace(\" \", \"\")]\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveSet.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Check equality with another set.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Check equality with another set.\"\"\"\n    if not isinstance(other, collections.abc.Set):\n        return NotImplemented\n    return set(self._adjust_value(v) for v in self) == set(self._adjust_value(v) for v in other)\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveSet.__ge__","title":"<code>__ge__(other)</code>","text":"<p>Test whether every element in other is in the set.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def __ge__(self, other):\n    \"\"\"Test whether every element in other is in the set.\"\"\"\n    return all(item in self for item in other)\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveSet.__gt__","title":"<code>__gt__(other)</code>","text":"<p>Test whether the set is a proper superset of other.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def __gt__(self, other):\n    \"\"\"Test whether the set is a proper superset of other.\"\"\"\n    return self &gt;= other and self != other\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveSet.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate over the values in their original case.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over the values in their original case.\"\"\"\n    return iter(self._store.values())\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveSet.__le__","title":"<code>__le__(other)</code>","text":"<p>Test whether every element in the set is in other.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def __le__(self, other):\n    \"\"\"Test whether every element in the set is in other.\"\"\"\n    return all(item in other for item in self)\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveSet.__len__","title":"<code>__len__()</code>","text":"Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def __len__(self):\n    return len(self._store)\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveSet.__lt__","title":"<code>__lt__(other)</code>","text":"<p>Test whether the set is a proper subset of other.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def __lt__(self, other):\n    \"\"\"Test whether the set is a proper subset of other.\"\"\"\n    return self &lt;= other and self != other\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveSet.__ne__","title":"<code>__ne__(other)</code>","text":"<p>Check inequality with another set.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def __ne__(self, other):\n    \"\"\"Check inequality with another set.\"\"\"\n    return not self == other\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveSet.__or__","title":"<code>__or__(other)</code>","text":"<p>Return the union of the sets as a new set.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def __or__(self, other):\n    \"\"\"Return the union of the sets as a new set.\"\"\"\n    return self.union(other)\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveSet.__repr__","title":"<code>__repr__()</code>","text":"<p>Return the set's string representation.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def __repr__(self):\n    \"\"\"Return the set's string representation.\"\"\"\n    items = \", \".join(repr(value) for value in self)\n    return f\"{self.__class__.__name__}([{items}])\"\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveSet.__str__","title":"<code>__str__()</code>","text":"<p>Return a user-friendly string representation.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def __str__(self):\n    \"\"\"Return a user-friendly string representation.\"\"\"\n    return f\"{{{', '.join(map(str, self))}}}\"\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveSet.__sub__","title":"<code>__sub__(other)</code>","text":"<p>Return a new set with elements in the set that are not in the others.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def __sub__(self, other):\n    \"\"\"Return a new set with elements in the set that are not in the others.\"\"\"\n    result = self.copy()\n    result.difference_update(other)\n    return result\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveSet.add","title":"<code>add(value)</code>","text":"Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def add(self, value):\n    adjusted_value = self._adjust_value(value)\n    self._store[adjusted_value] = value\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveSet.clear","title":"<code>clear()</code>","text":"Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def clear(self):\n    self._store.clear()\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveSet.copy","title":"<code>copy()</code>","text":"<p>Create a shallow copy of the set.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def copy(self):\n    \"\"\"Create a shallow copy of the set.\"\"\"\n    return CaseAndSpaceInsensitiveSet(self)\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveSet.difference","title":"<code>difference(*others)</code>","text":"<p>Return a new set with elements in the set that are not in the others.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def difference(self, *others):\n    \"\"\"Return a new set with elements in the set that are not in the others.\"\"\"\n    new_set = self.copy()\n    new_set.difference_update(*others)\n    return new_set\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveSet.difference_update","title":"<code>difference_update(*others)</code>","text":"<p>Remove all elements of another set from this set.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def difference_update(self, *others):\n    \"\"\"Remove all elements of another set from this set.\"\"\"\n    for iterable in others:\n        for value in iterable:\n            self.discard(value)\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveSet.discard","title":"<code>discard(value)</code>","text":"Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def discard(self, value):\n    adjusted_value = self._adjust_value(value)\n    self._store.pop(adjusted_value, None)\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveSet.intersection","title":"<code>intersection(*others)</code>","text":"<p>Return a new set with elements common to the set and all others.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def intersection(self, *others):\n    \"\"\"Return a new set with elements common to the set and all others.\"\"\"\n    new_set = CaseAndSpaceInsensitiveSet()\n    for value in self:\n        if all(value in other for other in others):\n            new_set.add(value)\n    return new_set\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveSet.pop","title":"<code>pop()</code>","text":"<p>Remove and return an arbitrary element from the set. Raises KeyError if the set is empty.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def pop(self):\n    \"\"\"\n    Remove and return an arbitrary element from the set.\n    Raises KeyError if the set is empty.\n    \"\"\"\n    if not self._store:\n        raise KeyError(\"pop from an empty set\")\n    adjusted_value, value = self._store.popitem()\n    return value\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveSet.union","title":"<code>union(*others)</code>","text":"<p>Return a new set with elements from the set and all others.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def union(self, *others):\n    \"\"\"Return a new set with elements from the set and all others.\"\"\"\n    new_set = self.copy()\n    new_set.update(*others)\n    return new_set\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveSet.update","title":"<code>update(*others)</code>","text":"<p>Update the set, adding elements from all others.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def update(self, *others):\n    \"\"\"Update the set, adding elements from all others.\"\"\"\n    for iterable in others:\n        for value in iterable:\n            self.add(value)\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveTuplesDict","title":"<code>CaseAndSpaceInsensitiveTuplesDict(data=None, **kwargs)</code>","text":"<p>               Bases: <code>MutableMapping</code></p> <p>A case-and-space-insensitive dict-like object with tuple of strings as keys.</p> <p>This class implements all methods and operations of <code>collections.abc.MutableMapping</code>, as well as dict's <code>copy</code>. It also provides <code>adjusted_items</code> and <code>adjusted_keys</code>. All keys are expected to be tuples of strings.</p> <p>The structure remembers the case of the last key set, and methods like <code>__iter__</code>, <code>keys()</code>, <code>items()</code>, etc., will contain case-sensitive keys.</p> <p>However, querying and membership tests are case-and-space-insensitive:     data = CaseAndSpaceInsensitiveTuplesDict()     data[('[Business Unit].[UK]', '[Scenario].[Worst Case]')] = 1000     assert data[('[BusinessUnit].[UK]', '[Scenario].[worstcase]')] == 1000     assert data[('[Business Unit].[UK]', '[Scenario].[Worst Case]')] == 1000</p> <p>Entries are ordered.</p> <p>Initialize the dictionary with optional initial data.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def __init__(self, data=None, **kwargs):\n    \"\"\"Initialize the dictionary with optional initial data.\"\"\"\n    self._store = collections.OrderedDict()\n    if data is None:\n        data = {}\n    self.update(data, **kwargs)\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveTuplesDict.__contains__","title":"<code>__contains__(key)</code>","text":"<p>Check if the key exists in the dictionary.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def __contains__(self, key):\n    \"\"\"Check if the key exists in the dictionary.\"\"\"\n    adjusted_key = self._adjust_key(key)\n    return adjusted_key in self._store\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveTuplesDict.__delitem__","title":"<code>__delitem__(key)</code>","text":"<p>Delete the item associated with the key.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def __delitem__(self, key):\n    \"\"\"Delete the item associated with the key.\"\"\"\n    adjusted_key = self._adjust_key(key)\n    try:\n        del self._store[adjusted_key]\n    except KeyError:\n        raise KeyError(f\"Key {key} not found.\") from None\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveTuplesDict.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Check equality with another dictionary.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Check equality with another dictionary.\"\"\"\n    if isinstance(other, collections.abc.Mapping):\n        other = CaseAndSpaceInsensitiveTuplesDict(other)\n    else:\n        return NotImplemented\n    return dict(self.adjusted_items()) == dict(other.adjusted_items())\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveTuplesDict.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Retrieve the value for a key, using the adjusted key.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def __getitem__(self, key):\n    \"\"\"Retrieve the value for a key, using the adjusted key.\"\"\"\n    adjusted_key = self._adjust_key(key)\n    try:\n        return self._store[adjusted_key][1]\n    except KeyError:\n        raise KeyError(f\"Key {key} not found.\") from None\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveTuplesDict.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate over the keys in their original case.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over the keys in their original case.\"\"\"\n    return (key for key, _ in self._store.values())\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveTuplesDict.__len__","title":"<code>__len__()</code>","text":"<p>Return the number of items in the dictionary.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def __len__(self):\n    \"\"\"Return the number of items in the dictionary.\"\"\"\n    return len(self._store)\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveTuplesDict.__repr__","title":"<code>__repr__()</code>","text":"<p>Return the dictionary's string representation.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def __repr__(self):\n    \"\"\"Return the dictionary's string representation.\"\"\"\n    items = \", \".join(f\"{key!r}: {value!r}\" for key, value in self.items())\n    return f\"{self.__class__.__name__}({{{items}}})\"\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveTuplesDict.__setitem__","title":"<code>__setitem__(key, value)</code>","text":"<p>Set the value for a key, adjusting the key as needed.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def __setitem__(self, key, value):\n    \"\"\"Set the value for a key, adjusting the key as needed.\"\"\"\n    adjusted_key = self._adjust_key(key)\n    self._store[adjusted_key] = (key, value)\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveTuplesDict.__str__","title":"<code>__str__()</code>","text":"<p>Return a user-friendly string representation.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def __str__(self):\n    \"\"\"Return a user-friendly string representation.\"\"\"\n    return repr(self)\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveTuplesDict.adjusted_items","title":"<code>adjusted_items()</code>","text":"<p>Return a generator of (adjusted_key, value) pairs.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def adjusted_items(self):\n    \"\"\"Return a generator of (adjusted_key, value) pairs.\"\"\"\n    return ((adjusted_key, key_value[1]) for adjusted_key, key_value in self._store.items())\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveTuplesDict.adjusted_keys","title":"<code>adjusted_keys()</code>","text":"<p>Return a generator of the adjusted keys.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def adjusted_keys(self):\n    \"\"\"Return a generator of the adjusted keys.\"\"\"\n    return (adjusted_key for adjusted_key in self._store.keys())\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveTuplesDict.clear","title":"<code>clear()</code>","text":"<p>Remove all items from the dictionary.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def clear(self):\n    \"\"\"Remove all items from the dictionary.\"\"\"\n    self._store.clear()\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveTuplesDict.copy","title":"<code>copy()</code>","text":"<p>Create a shallow copy of the dictionary.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def copy(self):\n    \"\"\"Create a shallow copy of the dictionary.\"\"\"\n    new_copy = CaseAndSpaceInsensitiveTuplesDict()\n    new_copy._store = self._store.copy()\n    return new_copy\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveTuplesDict.get","title":"<code>get(key, default=None)</code>","text":"<p>Return the value for key if key is in the dictionary, else default.</p> <p>Parameters:     key (tuple): The key to look up.     default: The value to return if the key is not found.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def get(self, key, default=None):\n    \"\"\"\n    Return the value for key if key is in the dictionary, else default.\n\n    Parameters:\n        key (tuple): The key to look up.\n        default: The value to return if the key is not found.\n    \"\"\"\n    try:\n        return self[key]\n    except KeyError:\n        return default\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveTuplesDict.items","title":"<code>items()</code>","text":"<p>Return a view of the items (key-value pairs).</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def items(self):\n    \"\"\"Return a view of the items (key-value pairs).\"\"\"\n    return [(key, value) for key, value in self._store.values()]\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveTuplesDict.join","title":"<code>join(other)</code>","text":"<p>Merge another mapping or iterable of key-value pairs into this dictionary.</p> <p>Parameters:     other (Mapping or Iterable): A mapping or iterable of key-value pairs.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def join(self, other):\n    \"\"\"\n    Merge another mapping or iterable of key-value pairs into this dictionary.\n\n    Parameters:\n        other (Mapping or Iterable): A mapping or iterable of key-value pairs.\n    \"\"\"\n    self.update(other)\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveTuplesDict.keys","title":"<code>keys()</code>","text":"<p>Return a view of the keys in their original case.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def keys(self):\n    \"\"\"Return a view of the keys in their original case.\"\"\"\n    return [key for key, _ in self._store.values()]\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveTuplesDict.pop","title":"<code>pop(key, default=None)</code>","text":"<p>Remove the specified key and return the corresponding value. If key is not found, default is returned if provided, otherwise KeyError is raised.</p> <p>Parameters:     key (tuple): The key to remove.     default: The value to return if the key is not found.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def pop(self, key, default=None):\n    \"\"\"\n    Remove the specified key and return the corresponding value.\n    If key is not found, default is returned if provided, otherwise KeyError is raised.\n\n    Parameters:\n        key (tuple): The key to remove.\n        default: The value to return if the key is not found.\n    \"\"\"\n    adjusted_key = self._adjust_key(key)\n    try:\n        value = self._store.pop(adjusted_key)[1]\n        return value\n    except KeyError:\n        if default is not None:\n            return default\n        else:\n            raise KeyError(f\"Key {key} not found.\") from None\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveTuplesDict.popitem","title":"<code>popitem()</code>","text":"<p>Remove and return a (key, value) pair from the dictionary. Pairs are returned in LIFO order.</p> <p>Raises:     KeyError: If the dictionary is empty.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def popitem(self):\n    \"\"\"\n    Remove and return a (key, value) pair from the dictionary.\n    Pairs are returned in LIFO order.\n\n    Raises:\n        KeyError: If the dictionary is empty.\n    \"\"\"\n    adjusted_key, (key, value) = self._store.popitem()\n    return key, value\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveTuplesDict.setdefault","title":"<code>setdefault(key, default=None)</code>","text":"<p>If key is in the dictionary, return its value. If not, insert key with a value of default and return default.</p> <p>Parameters:     key (tuple): The key to look up or insert.     default: The value to set if the key is not found.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def setdefault(self, key, default=None):\n    \"\"\"\n    If key is in the dictionary, return its value.\n    If not, insert key with a value of default and return default.\n\n    Parameters:\n        key (tuple): The key to look up or insert.\n        default: The value to set if the key is not found.\n    \"\"\"\n    if key in self:\n        return self[key]\n    else:\n        self[key] = default\n        return default\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveTuplesDict.update","title":"<code>update(other=(), **kwargs)</code>","text":"<p>Update the dictionary with key/value pairs from other, overwriting existing keys.</p> <p>Parameters:     other (Mapping or Iterable): A mapping or iterable of key-value pairs.     **kwargs: Additional key-value pairs.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def update(self, other=(), **kwargs):\n    \"\"\"\n    Update the dictionary with key/value pairs from other, overwriting existing keys.\n\n    Parameters:\n        other (Mapping or Iterable): A mapping or iterable of key-value pairs.\n        **kwargs: Additional key-value pairs.\n    \"\"\"\n    if isinstance(other, collections.abc.Mapping):\n        for key, value in other.items():\n            self[key] = value\n\n    elif hasattr(other, \"__iter__\"):\n        for item in other:\n            if not isinstance(item, collections.abc.Iterable):\n                raise TypeError(\"Items must be key-value pairs.\")\n            key, value = item\n            self[key] = value\n\n    elif other:\n        raise TypeError(\"Other object is not a mapping or iterable of key-value pairs.\")\n\n    for key, value in kwargs.items():\n        self[key] = value\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CaseAndSpaceInsensitiveTuplesDict.values","title":"<code>values()</code>","text":"<p>Return a view of the values.</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def values(self):\n    \"\"\"Return a view of the values.\"\"\"\n    return [value for _, value in self._store.values()]\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CellUpdateableProperty","title":"<code>CellUpdateableProperty</code>","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CellUpdateableProperty.CELL_IS_NOT_UPDATEABLE","title":"<code>CELL_IS_NOT_UPDATEABLE = 29</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CellUpdateableProperty.CONSOLIDATION_SPREADING_HOLD","title":"<code>CONSOLIDATION_SPREADING_HOLD = 11</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CellUpdateableProperty.LEAF_HOLD","title":"<code>LEAF_HOLD = 10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CellUpdateableProperty.NO_SPREADING_HOLD","title":"<code>NO_SPREADING_HOLD = 9</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CellUpdateableProperty.PICKLIST_EXISTS","title":"<code>PICKLIST_EXISTS = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CellUpdateableProperty.RULE_IS_APPLIED","title":"<code>RULE_IS_APPLIED = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CellUpdateableProperty.SANDBOX_VALUE_IS_DIFFERENT_TO_BASE","title":"<code>SANDBOX_VALUE_IS_DIFFERENT_TO_BASE = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CellUpdateableProperty.SECURITY_RESTRICTED","title":"<code>SECURITY_RESTRICTED = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CellUpdateableProperty.TEMPORARY_SPREADING_HOLD","title":"<code>TEMPORARY_SPREADING_HOLD = 12</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/utils/utils/#TM1py.Utils.Utils.CellUpdateableProperty.UPDATE_CUBE_APPLICABLE","title":"<code>UPDATE_CUBE_APPLICABLE = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/utils/utils/#TM1py.Utils.Utils.HTTPAdapterWithSocketOptions","title":"<code>HTTPAdapterWithSocketOptions(*args, **kwargs)</code>","text":"<p>               Bases: <code>HTTPAdapter</code></p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    self.socket_options = kwargs.pop(\"socket_options\", None)\n    self.ssl_context = kwargs.pop(\"ssl_context\", None)\n    super(HTTPAdapterWithSocketOptions, self).__init__(*args, **kwargs)\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.HTTPAdapterWithSocketOptions.socket_options","title":"<code>socket_options = kwargs.pop('socket_options', None)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/utils/utils/#TM1py.Utils.Utils.HTTPAdapterWithSocketOptions.ssl_context","title":"<code>ssl_context = kwargs.pop('ssl_context', None)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/utils/utils/#TM1py.Utils.Utils.HTTPAdapterWithSocketOptions.init_poolmanager","title":"<code>init_poolmanager(*args, **kwargs)</code>","text":"Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def init_poolmanager(self, *args, **kwargs):\n    # must use hasattr here, as socket_options may be not-set in case TM1Service was created with restore_from_file\n    if hasattr(self, \"socket_options\"):\n        kwargs[\"socket_options\"] = self.socket_options\n    if hasattr(self, \"ssl_context\"):\n        kwargs[\"ssl_context\"] = self.ssl_context\n    super(HTTPAdapterWithSocketOptions, self).init_poolmanager(*args, **kwargs)\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.abbreviate_mdx","title":"<code>abbreviate_mdx(mdx, size=100)</code>","text":"Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def abbreviate_mdx(mdx: str, size=100) -&gt; str:\n    if len(mdx) &lt; size:\n        return mdx\n    else:\n        return mdx[:size] + \"...\"\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.add_url_parameters","title":"<code>add_url_parameters(url, **kwargs)</code>","text":"<p>Append parameters to url string passed in kwargs</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <p>str</p> required <code>kwargs</code> <code>str</code> <p>key:value pairs of url parameters. For example, {'$select':'Name'}</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>str</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def add_url_parameters(url, **kwargs: str) -&gt; str:\n    \"\"\"Append parameters to url string passed in kwargs\n    :param url: str\n    :param kwargs: key:value pairs of url parameters. For example, {'$select':'Name'}\n    :return: str\n    \"\"\"\n    parameters = []\n    for key, value in kwargs.items():\n        if value is not None:\n            value = value.replace(\"'\", \"''\") if isinstance(value, str) else value\n            parameters.append(key + \"=\" + value)\n\n    url_parts = list(urlparse.urlparse(url))\n    query_part = url_parts[4]\n    if query_part:\n        query_part += \"&amp;\"\n    query_part += \"&amp;\".join(parameters)\n\n    url_parts[4] = query_part\n    return urlparse.urlunparse(url_parts)\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.aggregate_duplicate_intersections","title":"<code>aggregate_duplicate_intersections(df, dimension_headers, value_header)</code>","text":"Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def aggregate_duplicate_intersections(df, dimension_headers, value_header):\n    for col in dimension_headers:\n        df[col] = df[col].str.lower().str.replace(\" \", \"\")\n    return df.groupby([*dimension_headers])[value_header].sum().reset_index()\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.build_cellset_from_pandas_dataframe","title":"<code>build_cellset_from_pandas_dataframe(df, sum_numeric_duplicates=True)</code>","text":"<p>param sum_numeric_duplicates: Aggregate numerical values for duplicated intersections param df: a Pandas Dataframe, with dimension-column mapping in correct order. As created in build_pandas_dataframe_from_cellset</p> <p>Returns:</p> Type Description <code>CaseAndSpaceInsensitiveTuplesDict</code> <p>a CaseAndSpaceInsensitiveTuplesDict</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>@require_pandas\ndef build_cellset_from_pandas_dataframe(\n    df: \"pd.DataFrame\", sum_numeric_duplicates: bool = True\n) -&gt; \"CaseAndSpaceInsensitiveTuplesDict\":\n    \"\"\"\n\n    param sum_numeric_duplicates: Aggregate numerical values for duplicated intersections\n    param df: a Pandas Dataframe, with dimension-column mapping in correct order.\n    As created in build_pandas_dataframe_from_cellset\n\n    :return: a CaseAndSpaceInsensitiveTuplesDict\n    \"\"\"\n    df = build_dataframe_aggregate_intersections(df, sum_numeric_duplicates)\n\n    cellset = CaseAndSpaceInsensitiveTuplesDict(\n        dict(zip(df.iloc[:, :-1].itertuples(index=False, name=None), df.iloc[:, -1].values))\n    )\n    return cellset\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.build_content_from_cellset_dict","title":"<code>build_content_from_cellset_dict(raw_cellset_as_dict, top=None, element_unique_names=True, skip_cell_properties=False, skip_sandbox_dimension=False)</code>","text":"<p>transform raw cellset data into concise dictionary</p> <p>Parameters:</p> Name Type Description Default <code>raw_cellset_as_dict</code> <code>Dict</code> required <code>top</code> <code>Optional[int]</code> <p>Int, number of cells to return (counting from top)</p> <code>None</code> <code>element_unique_names</code> <code>bool</code> <p>'[d1].[h1].[e1]' or 'e1'</p> <code>True</code> <code>skip_cell_properties</code> <code>bool</code> <p>cell values in result dictionary, instead of cell_properties dictionary</p> <code>False</code> <code>skip_sandbox_dimension</code> <code>bool</code> <p>skip sandbox dimension</p> <code>False</code> <p>Returns:</p> Type Description <code>CaseAndSpaceInsensitiveTuplesDict</code> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def build_content_from_cellset_dict(\n    raw_cellset_as_dict: Dict,\n    top: Optional[int] = None,\n    element_unique_names: bool = True,\n    skip_cell_properties: bool = False,\n    skip_sandbox_dimension: bool = False,\n) -&gt; \"CaseAndSpaceInsensitiveTuplesDict\":\n    \"\"\"transform raw cellset data into concise dictionary\n    :param raw_cellset_as_dict:\n    :param top: Int, number of cells to return (counting from top)\n    :param element_unique_names: '[d1].[h1].[e1]' or 'e1'\n    :param skip_cell_properties: cell values in result dictionary, instead of cell_properties dictionary\n    :param skip_sandbox_dimension: skip sandbox dimension\n    :return:\n    \"\"\"\n    cube_dimensions = [dim[\"Name\"] for dim in raw_cellset_as_dict[\"Cube\"][\"Dimensions\"]]\n    if skip_sandbox_dimension and cube_dimensions[0].lower() == \"sandboxes\":\n        cube_dimensions = cube_dimensions[1:]\n\n    cells = raw_cellset_as_dict[\"Cells\"]\n    axes = extract_axes_from_cellset(raw_cellset_as_dict=raw_cellset_as_dict)\n\n    content_as_dict = CaseAndSpaceInsensitiveTuplesDict()\n    for cell_ordinal, cell in enumerate(cells[: top or len(cells)]):\n        # if skip is used in execution we must use the original ordinal from the cell, if not we can simply enumerate\n        cell_ordinal = cell.get(\"Ordinal\", cell_ordinal)\n\n        coordinates = []\n        for axis_ordinal, axis in enumerate(axes):\n\n            if axis_ordinal == 0:\n                index_columns = cell_ordinal % axis[\"Cardinality\"]\n                coordinate = extract_unique_names_from_members(axis[\"Tuples\"][index_columns][\"Members\"])\n                coordinates.extend(coordinate)\n\n            else:\n                tuple_ordinal = cell_ordinal\n                for pre_axis_ordinal in range(axis_ordinal):\n                    tuple_ordinal = tuple_ordinal // axes[pre_axis_ordinal][\"Cardinality\"]\n\n                tuple_ordinal = tuple_ordinal % axis.get(\"Cardinality\")\n                coordinate = extract_unique_names_from_members(axis[\"Tuples\"][tuple_ordinal][\"Members\"])\n                coordinates.extend(coordinate)\n\n        coordinates = sort_coordinates(cube_dimensions, coordinates, element_unique_names=element_unique_names)\n        content_as_dict[coordinates] = cell[\"Value\"] if skip_cell_properties else cell\n    return content_as_dict\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.build_csv_from_cellset_dict","title":"<code>build_csv_from_cellset_dict(row_dimensions, column_dimensions, raw_cellset_as_dict, top=None, csv_dialect=None, line_separator='\\r\\n', value_separator=',', include_attributes=False, include_headers=True, mdx_headers=False)</code>","text":"<p>transform raw cellset data into concise dictionary</p> <p>Parameters:</p> Name Type Description Default <code>column_dimensions</code> <code>List[str]</code> required <code>row_dimensions</code> <code>List[str]</code> required <code>raw_cellset_as_dict</code> <code>Dict</code> required <code>top</code> <code>Optional[int]</code> <p>Maximum Number of cells</p> <code>None</code> <code>csv_dialect</code> <code>Dialect</code> <p>provide all csv output settings through standard library csv.Dialect If not provided dialect is created based on line_separator and value_separator arguments.</p> <code>None</code> <code>line_separator</code> <code>str</code> <code>'\\r\\n'</code> <code>value_separator</code> <code>str</code> <code>','</code> <code>include_attributes</code> <code>bool</code> <p>include attribute columns</p> <code>False</code> <code>include_headers</code> <code>bool</code> <p>bool</p> <code>True</code> <code>mdx_headers</code> <code>bool</code> <p>boolean. Fully qualified hierarchy name as header instead of simple dimension name</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def build_csv_from_cellset_dict(\n    row_dimensions: List[str],\n    column_dimensions: List[str],\n    raw_cellset_as_dict: Dict,\n    top: Optional[int] = None,\n    csv_dialect: \"csv.Dialect\" = None,\n    line_separator: str = \"\\r\\n\",\n    value_separator: str = \",\",\n    include_attributes: bool = False,\n    include_headers: bool = True,\n    mdx_headers: bool = False,\n) -&gt; str:\n    \"\"\"transform raw cellset data into concise dictionary\n    :param column_dimensions:\n    :param row_dimensions:\n    :param raw_cellset_as_dict:\n    :param top: Maximum Number of cells\n    :param csv_dialect: provide all csv output settings through standard library csv.Dialect\n        If not provided dialect is created based on line_separator and value_separator arguments.\n    :param line_separator:\n    :param value_separator:\n    :param include_attributes: include attribute columns\n    :param include_headers: bool\n    :param mdx_headers: boolean. Fully qualified hierarchy name as header instead of simple dimension name\n    :return:\n    \"\"\"\n\n    cells = raw_cellset_as_dict[\"Cells\"]\n    # empty cellsets produce \"\" in order to be compliant with previous implementation that used `/Content` API endpoint\n    if len(cells) == 0:\n        return \"\"\n\n    if csv_dialect is None:\n        csv.register_dialect(\"TM1py\", delimiter=value_separator, lineterminator=line_separator)\n        csv_dialect = csv.get_dialect(\"TM1py\")\n\n    csv_content = StringIO()\n    csv_writer = csv.writer(csv_content, dialect=csv_dialect)\n\n    axes = extract_axes_from_cellset(raw_cellset_as_dict=raw_cellset_as_dict)\n    column_axis = axes[0]\n    if len(axes) &gt; 1:\n        row_axis = axes[1]\n    else:\n        row_axis = list()\n\n    num_headers = 0\n    if include_headers:\n        headers = _build_headers_for_csv(\n            row_axis=row_axis,\n            column_axis=column_axis,\n            row_dimensions=row_dimensions,\n            column_dimensions=column_dimensions,\n            include_attributes=include_attributes,\n            mdx_headers=mdx_headers,\n        )\n        csv_writer.writerow(headers)\n        num_headers = len(headers)\n\n    for ordinal, cell in enumerate(cells[: top or len(cells)]):\n        # if skip is used in execution we must use the original ordinal from the cell, if not we can simply enumerate\n        ordinal = cell.get(\"Ordinal\", ordinal)\n\n        line = []\n        if column_axis and row_axis:\n            index_rows = ordinal // column_axis[\"Cardinality\"] % row_axis[\"Cardinality\"]\n            index_columns = ordinal % column_axis[\"Cardinality\"]\n\n            line_items = _build_csv_line_items_from_axis_tuple(\n                members=row_axis[\"Tuples\"][index_rows][\"Members\"], include_attributes=include_attributes\n            )\n            line.extend(line_items)\n\n            line_items = _build_csv_line_items_from_axis_tuple(\n                members=column_axis[\"Tuples\"][index_columns][\"Members\"], include_attributes=include_attributes\n            )\n            line.extend(line_items)\n\n        elif column_axis:\n            index_rows = ordinal % column_axis[\"Cardinality\"]\n\n            line_items = _build_csv_line_items_from_axis_tuple(\n                members=column_axis[\"Tuples\"][index_rows][\"Members\"], include_attributes=include_attributes\n            )\n            line.extend(line_items)\n\n        line.append(str(cell[\"Value\"] or \"\"))\n        if include_attributes and include_headers and not len(line) == num_headers:\n            raise ValueError(\n                \"Invalid response. With 'include_attributes' as True,\"\n                \" Attributes must be requested explicitly as PROPERTIES in the MDX\"\n            )\n        csv_writer.writerow(line)\n\n    return csv_content.getvalue().strip()\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.build_dataframe_aggregate_intersections","title":"<code>build_dataframe_aggregate_intersections(df, sum_numeric_duplicates=True)</code>","text":"<p>param sum_numeric_duplicates: Aggregate numerical values for duplicated intersections param df: A Dataframe, with dimension-column mapping in correct order.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A Dataframe</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>@require_pandas\ndef build_dataframe_aggregate_intersections(df: \"pd.DataFrame\", sum_numeric_duplicates: bool = True) -&gt; \"pd.DataFrame\":\n    \"\"\"\n\n    param sum_numeric_duplicates: Aggregate numerical values for duplicated intersections\n    param df: A Dataframe, with dimension-column mapping in correct order.\n\n    :return: A Dataframe\n    \"\"\"\n    if isinstance(df.index, pd.MultiIndex):\n        df.reset_index(inplace=True)\n\n    if sum_numeric_duplicates:\n        value_header = df.columns[-1]\n        dimension_headers = df.columns[:-1]\n\n        if pd.api.types.is_numeric_dtype(df[value_header]):\n            df = aggregate_duplicate_intersections(df, dimension_headers, value_header)\n        else:\n            filter_mask = df[value_header].apply(np.isreal)\n            df_n = df[filter_mask]\n            df_s = df[~filter_mask]\n            df_n = aggregate_duplicate_intersections(df_n, dimension_headers, value_header)\n            df = pd.concat([df_n, df_s])\n\n    return df\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.build_dataframe_from_csv","title":"<code>build_dataframe_from_csv(raw_csv, sep='~', shaped=False, fillna_numeric_attributes=False, fillna_numeric_attributes_value=0, fillna_string_attributes=False, fillna_string_attributes_value='', attribute_types_by_dimension=None, **kwargs)</code>","text":"Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def build_dataframe_from_csv(\n    raw_csv,\n    sep=\"~\",\n    shaped: bool = False,\n    fillna_numeric_attributes: bool = False,\n    fillna_numeric_attributes_value: Any = 0,\n    fillna_string_attributes: bool = False,\n    fillna_string_attributes_value: Any = \"\",\n    attribute_types_by_dimension: Dict[str, Dict[str, str]] = None,\n    **kwargs,\n) -&gt; \"pd.DataFrame\":\n    if not raw_csv:\n        return pd.DataFrame()\n\n    # make sure all element names are strings and values column is derived from data\n    if \"dtype\" not in kwargs:\n        kwargs[\"dtype\"] = {\"Value\": None, **{col: str for col in range(999)}}\n    try:\n        df = pd.read_csv(StringIO(raw_csv), sep=sep, na_values={\"Value\": [\"None\"]}, keep_default_na=False, **kwargs)\n\n    except ValueError:\n        # retry with dtype 'str' for results with a mixed value column\n        kwargs[\"dtype\"] = {\"Value\": str, **{col: str for col in range(999)}}\n        df = pd.read_csv(StringIO(raw_csv), sep=sep, na_values={\"Value\": [\"None\"]}, keep_default_na=False, **kwargs)\n\n    if fillna_numeric_attributes:\n        fill_numeric_bool_list = [\n            attr_type.lower() == \"numeric\"\n            for dimension, attributes in attribute_types_by_dimension.items()\n            for attr_type in [dimension] + list(attributes.values())\n        ]\n        fill_numeric_bool_list += [False]  # for the value column\n        df = df.apply(\n            lambda col: (\n                col.replace([\"\", \"None\"], np.nan).fillna(fillna_numeric_attributes_value)\n                if fill_numeric_bool_list[list(df.columns.values).index(col.name)]\n                else col\n            ),\n            axis=0,\n        )\n\n    if fillna_string_attributes:\n        fill_string_bool_list = [\n            attr_type.lower() == \"string\"\n            for dimension, attributes in attribute_types_by_dimension.items()\n            for attr_type in [dimension] + list(attributes.values())\n        ]\n        fill_string_bool_list += [False]  # for the value column\n        df = df.apply(\n            lambda col: (\n                col.replace([\"\", \"None\"], np.nan).fillna(fillna_string_attributes_value)\n                if fill_string_bool_list[list(df.columns.values).index(col.name)]\n                else col\n            ),\n            axis=0,\n        )\n\n    if not shaped:\n        return df\n\n    # due to csv creation logic, last column is bottom dimension from the column selection\n    idx_cols = list(df.columns[:-2])\n    col_col = df.columns[-2]\n    val_col = df.columns[-1]\n\n    # create a unique row id within each (idx_cols + col_col) group\n    df[\"_dup\"] = df.groupby(idx_cols + [col_col]).cumcount()\n    df = (\n        df.pivot(\n            index=idx_cols + [\"_dup\"],\n            columns=col_col,\n            values=val_col,\n        )\n        .fillna(0)\n        .reset_index()\n        .drop(columns=\"_dup\")\n    )\n\n    # drop title on index\n    return df.rename_axis(None, axis=1)\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.build_element_unique_names","title":"<code>build_element_unique_names(dimension_names, element_names, hierarchy_names=None)</code>","text":"<p>Create tuple of unique names from dimension, hierarchy and elements</p> <p>Parameters:</p> Name Type Description Default <code>dimension_names</code> <code>Iterable[str]</code> required <code>element_names</code> <code>Iterable[str]</code> required <code>hierarchy_names</code> <code>Optional[Iterable[str]]</code> <code>None</code> <p>Returns:</p> Type Description <code>Generator</code> <p>Generator</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def build_element_unique_names(\n    dimension_names: Iterable[str], element_names: Iterable[str], hierarchy_names: Optional[Iterable[str]] = None\n) -&gt; Generator:\n    \"\"\"Create tuple of unique names from dimension, hierarchy and elements\n\n    :param dimension_names:\n    :param element_names:\n    :param hierarchy_names:\n    :return: Generator\n    \"\"\"\n    if not hierarchy_names:\n        return (\"[{}].[{}]\".format(dim, elem) for dim, elem in zip(dimension_names, element_names))\n    else:\n        return (\n            \"[{}].[{}].[{}]\".format(dim, hier, elem)\n            for dim, hier, elem in zip(dimension_names, hierarchy_names, element_names)\n        )\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.build_headers_from_cellset","title":"<code>build_headers_from_cellset(raw_cellset_as_dict, force_header_dimensionality=1)</code>","text":"<p>Extract dimension headers from cellset into dictionary of titles (slicers) and headers (row,column,page) * Title dimensions are in a single list of dicts * Header dimensions are a 2-dimensional list of the element dicts   * The first dimension in the header list is the axis   * The second dimension is the list of elements on the axis * Dict format: {'name': 'element or compound name', 'members': [ {dict of dimension properties}, ... ] }   * Stacked headers on an axis will have a compount 'name' created by joining the member's 'Name' properties with a '/'   * Stacked headers will each be listed in the 'memebers' list; Single-element headers will only have one element in list</p> <p>Parameters:</p> Name Type Description Default <code>raw_cellset_as_dict</code> <code>Dict</code> <p>raw data from TM1</p> required <code>force_header_dimensionality</code> <code>int</code> <p>An optional integer (1,2 or 3) to force headers array to be at least that long</p> <code>1</code> <p>Returns:</p> Type Description <code>Dict</code> <p>dict : <code>{ titles: [ { 'name': 'xx', 'members': {} } ], headers: [axis][ { 'name': 'xx', 'members': {} } ] }</code></p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def build_headers_from_cellset(raw_cellset_as_dict: Dict, force_header_dimensionality: int = 1) -&gt; Dict:\n    \"\"\"Extract dimension headers from cellset into dictionary of titles (slicers) and headers (row,column,page)\n    * Title dimensions are in a single list of dicts\n    * Header dimensions are a 2-dimensional list of the element dicts\n      * The first dimension in the header list is the axis\n      * The second dimension is the list of elements on the axis\n    * Dict format: {'name': 'element or compound name', 'members': [ {dict of dimension properties}, ... ] }\n      * Stacked headers on an axis will have a compount 'name' created by joining the member's 'Name' properties with a '/'\n      * Stacked headers will each be listed in the 'memebers' list; Single-element headers will only have one element in list\n    :param raw_cellset_as_dict: raw data from TM1\n    :param force_header_dimensionality: An optional integer (1,2 or 3) to force headers array to be at least that long\n    :return: dict : `{ titles: [ { 'name': 'xx', 'members': {} } ], headers: [axis][ { 'name': 'xx', 'members': {} } ] }`\n    \"\"\"\n    dimensionality = len(raw_cellset_as_dict[\"Axes\"])\n    cardinality = [raw_cellset_as_dict[\"Axes\"][axis][\"Cardinality\"] for axis in range(dimensionality)]\n\n    titles = []\n    headers = []\n    for axis in range(dimensionality):\n        members = []\n        for tindex in range(cardinality[axis]):\n            tuples_as_dict = raw_cellset_as_dict[\"Axes\"][axis][\"Tuples\"][tindex][\"Members\"]\n            name = \" / \".join(tuple(member[\"Name\"] for member in tuples_as_dict))\n            members.append({\"name\": name, \"members\": tuples_as_dict})\n\n        if axis == dimensionality - 1 and cardinality[axis] == 1:\n            titles = members\n        else:\n            headers.append(members)\n\n    dimensionality = len(headers)\n    cardinality = [len(headers[axis]) for axis in range(dimensionality)]\n\n    # Handle 1, 2 and 3-dimensional cellsets. Use dummy row/page headers when missing\n    if dimensionality == 1 and force_header_dimensionality &gt; 1:\n        headers += [[{\"name\": \"Row\"}]]\n        cardinality.insert(1, 1)\n        dimensionality += 1\n    if dimensionality == 2 and force_header_dimensionality &gt; 2:\n        headers += [[{\"name\": \"Page\"}]]\n        cardinality.insert(2, 1)\n        dimensionality += 1\n\n    return {\"titles\": titles, \"headers\": headers, \"dimensionality\": dimensionality, \"cardinality\": cardinality}\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.build_mdx_and_values_from_cellset","title":"<code>build_mdx_and_values_from_cellset(cells, cube_name, dimensions)</code>","text":"Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def build_mdx_and_values_from_cellset(cells: Dict, cube_name: str, dimensions: Iterable[str]) -&gt; Tuple[str, List]:\n    values = []\n    query = MdxBuilder.from_cube(cube_name)\n    for coordinates, value in cells.items():\n        members = (Member.of(dimension, element) for dimension, element in zip(dimensions, coordinates))\n        query.add_member_tuple_to_columns(*members)\n        values.append(value)\n    mdx = query.to_mdx()\n    return mdx, values\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.build_mdx_from_cellset","title":"<code>build_mdx_from_cellset(cells, cube_name, dimensions)</code>","text":"Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def build_mdx_from_cellset(cells: Dict, cube_name: str, dimensions: Iterable[str]) -&gt; str:\n    query = MdxBuilder.from_cube(cube_name)\n    for coordinates in cells:\n        members = (Member.of(dimension, element) for dimension, element in zip(dimensions, coordinates))\n        query.add_member_tuple_to_columns(*members)\n    mdx = query.to_mdx()\n    return mdx\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.build_pandas_dataframe_from_cellset","title":"<code>build_pandas_dataframe_from_cellset(cellset, multiindex=True, sort_values=True)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>cellset</code> <code>Dict</code> required <code>multiindex</code> <code>bool</code> <p>True or False</p> <code>True</code> <code>sort_values</code> <code>bool</code> <p>Boolean to control sorting in result DataFrame</p> <code>True</code> <p>Returns:</p> Type Description <code>DataFrame</code> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>@require_pandas\ndef build_pandas_dataframe_from_cellset(\n    cellset: Dict, multiindex: bool = True, sort_values: bool = True\n) -&gt; \"pd.DataFrame\":\n    \"\"\"\n\n    :param cellset:\n    :param multiindex: True or False\n    :param sort_values: Boolean to control sorting in result DataFrame\n    :return:\n    \"\"\"\n    try:\n        cellset_clean = {}\n        coordinates = []\n        for coordinates, cell in cellset.items():\n            element_names = element_names_from_element_unique_names(coordinates)\n            cellset_clean[element_names] = cell[\"Value\"] if cell else None\n        dimension_names = tuple(unique_name[1 : unique_name.find(\"].[\")] for unique_name in coordinates)\n\n        # create index\n        keylist = list(cellset_clean.keys())\n        index = pd.MultiIndex.from_tuples(keylist, names=dimension_names)\n\n        # create DataFrame\n        values = list(cellset_clean.values())\n        df = pd.DataFrame(values, index=index, columns=[\"Values\"])\n\n        if not multiindex:\n            df.reset_index(inplace=True)\n            if sort_values:\n                df.sort_values(inplace=True, by=list(dimension_names))\n        return df\n    except UnboundLocalError:\n        message = \"\"\"\n            Can't build DataFrame from empty cellset. \n            Make sure the underlying MDX / View is not fully zero suppressed.\n        \"\"\"\n        raise ValueError(message)\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.build_ui_arrays_from_cellset","title":"<code>build_ui_arrays_from_cellset(raw_cellset_as_dict, value_precision, top=None)</code>","text":"<p>Transform raw 1,2 or 3-dimension cellset data into concise dictionary * Useful for grids or charting libraries that want an array of cell values per row * Returns 3-dimensional cell structure for tabbed grids or multiple charts * Rows and pages are dicts, addressable by their name. Proper order of rows can be obtained in headers[1] * Example 'cells' return format: <pre><code>    'cells': {\n        '10100': {\n            'Net Operating Income': [ 19832724.72429739,\n                                      20365654.788303416,\n                                      20729201.329183243,\n                                      20480205.20121749],\n            'Revenue': [ 28981046.50724231,\n                         29512482.207418434,\n                         29913730.038971487,\n                         29563345.9542385]},\n        '10200': {\n            'Net Operating Income': [ 9853293.623709997,\n                                       10277650.763958748,\n                                       10466934.096533755,\n                                       10333095.839474997],\n            'Revenue': [ 13888143.710000003,\n                         14300216.43,\n                         14502421.63,\n                         14321501.940000001]}\n    },\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>raw_cellset_as_dict</code> <code>Dict</code> <p>raw data from TM1</p> required <code>value_precision</code> <code>int</code> <p>Integer (optional) specifying number of decimal places to return</p> required <code>top</code> <code>int</code> <p>Int, number of cells to return (counting from top)</p> <code>None</code> <p>Returns:</p> Type Description <p>dict : <code>{ titles: [], headers: [axis][], cells: { Page0: { Row0: { [row values], Row1: [], ...}, ...}, ...} }</code></p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def build_ui_arrays_from_cellset(raw_cellset_as_dict: Dict, value_precision: int, top: int = None):\n    \"\"\"Transform raw 1,2 or 3-dimension cellset data into concise dictionary\n    * Useful for grids or charting libraries that want an array of cell values per row\n    * Returns 3-dimensional cell structure for tabbed grids or multiple charts\n    * Rows and pages are dicts, addressable by their name. Proper order of rows can be obtained in headers[1]\n    * Example 'cells' return format:\n    ```\n        'cells': {\n            '10100': {\n                'Net Operating Income': [ 19832724.72429739,\n                                          20365654.788303416,\n                                          20729201.329183243,\n                                          20480205.20121749],\n                'Revenue': [ 28981046.50724231,\n                             29512482.207418434,\n                             29913730.038971487,\n                             29563345.9542385]},\n            '10200': {\n                'Net Operating Income': [ 9853293.623709997,\n                                           10277650.763958748,\n                                           10466934.096533755,\n                                           10333095.839474997],\n                'Revenue': [ 13888143.710000003,\n                             14300216.43,\n                             14502421.63,\n                             14321501.940000001]}\n        },\n    ```\n    :param raw_cellset_as_dict: raw data from TM1\n    :param value_precision: Integer (optional) specifying number of decimal places to return\n    :param top: Int, number of cells to return (counting from top)\n    :return: dict : `{ titles: [], headers: [axis][], cells: { Page0: { Row0: { [row values], Row1: [], ...}, ...}, ...} }`\n    \"\"\"\n    header_map = build_headers_from_cellset(raw_cellset_as_dict, force_header_dimensionality=3)\n    titles = header_map[\"titles\"]\n    headers = header_map[\"headers\"]\n    cardinality = header_map[\"cardinality\"]\n    value_format_string = \"\"\n\n    if value_precision:\n        value_format_string = \"{{0:.{}f}}\".format(value_precision)\n\n    cells = {}\n    ordinal_cells = 0\n    for z in range(cardinality[2]):\n        z_header = headers[2][z][\"name\"]\n        pages = {}\n        for y in range(cardinality[1]):\n            y_header = headers[1][y][\"name\"]\n            row = []\n            for x in range(cardinality[0]):\n                if top and top &lt;= ordinal_cells:\n                    break\n                raw_value = raw_cellset_as_dict[\"Cells\"][ordinal_cells][\"Value\"] or 0\n                if value_precision:\n                    row.append(float(value_format_string.format(raw_value)))\n                else:\n                    row.append(raw_value)\n                ordinal_cells += 1\n            pages[y_header] = row\n        cells[z_header] = pages\n    return {\"titles\": titles, \"headers\": headers, \"cells\": cells}\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.build_ui_dygraph_arrays_from_cellset","title":"<code>build_ui_dygraph_arrays_from_cellset(raw_cellset_as_dict, value_precision=None)</code>","text":"<p>Transform raw 1,2 or 3-dimension cellset data into dygraph-friendly format * Useful for grids or charting libraries that want an array of cell values per column * Returns 3-dimensional cell structure for tabbed grids or multiple charts * Example 'cells' return format: <pre><code>    'cells': {\n        '10100': [\n            ['Q1-2004', 28981046.50724231, 19832724.72429739],\n            ['Q2-2004', 29512482.207418434, 20365654.788303416],\n            ['Q3-2004', 29913730.038971487, 20729201.329183243],\n            ['Q4-2004', 29563345.9542385, 20480205.20121749]],\n        '10200': [\n            ['Q1-2004', 13888143.710000003, 9853293.623709997],\n            ['Q2-2004', 14300216.43, 10277650.763958748],\n            ['Q3-2004', 14502421.63, 10466934.096533755],\n            ['Q4-2004', 14321501.940000001, 10333095.839474997]]\n    },\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>raw_cellset_as_dict</code> <code>Dict</code> <p>raw data from TM1</p> required <code>value_precision</code> <code>int</code> <p>Integer (optional) specifying number of decimal places to return</p> <code>None</code> <p>Returns:</p> Type Description <p>dict : <code>{ titles: [], headers: [axis][], cells: { Page0: [  [column name, column values], [], ... ], ...} }</code></p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def build_ui_dygraph_arrays_from_cellset(raw_cellset_as_dict: Dict, value_precision: int = None):\n    \"\"\"Transform raw 1,2 or 3-dimension cellset data into dygraph-friendly format\n    * Useful for grids or charting libraries that want an array of cell values per column\n    * Returns 3-dimensional cell structure for tabbed grids or multiple charts\n    * Example 'cells' return format:\n    ```\n        'cells': {\n            '10100': [\n                ['Q1-2004', 28981046.50724231, 19832724.72429739],\n                ['Q2-2004', 29512482.207418434, 20365654.788303416],\n                ['Q3-2004', 29913730.038971487, 20729201.329183243],\n                ['Q4-2004', 29563345.9542385, 20480205.20121749]],\n            '10200': [\n                ['Q1-2004', 13888143.710000003, 9853293.623709997],\n                ['Q2-2004', 14300216.43, 10277650.763958748],\n                ['Q3-2004', 14502421.63, 10466934.096533755],\n                ['Q4-2004', 14321501.940000001, 10333095.839474997]]\n        },\n    ```\n    :param raw_cellset_as_dict: raw data from TM1\n    :param value_precision: Integer (optional) specifying number of decimal places to return\n    :return: dict : `{ titles: [], headers: [axis][], cells: { Page0: [  [column name, column values], [], ... ], ...} }`\n    \"\"\"\n    header_map = build_headers_from_cellset(raw_cellset_as_dict, force_header_dimensionality=3)\n    titles = header_map[\"titles\"]\n    headers = header_map[\"headers\"]\n    cardinality = header_map[\"cardinality\"]\n    value_format_string = \"\"\n\n    if value_precision:\n        value_format_string = \"{{0:.{}f}}\".format(value_precision)\n\n    cells = {}\n    for z in range(cardinality[2]):\n        z_header = headers[2][z][\"name\"]\n        page = []\n        for x in range(cardinality[0]):\n            x_header = headers[0][x][\"name\"]\n            row = [x_header]\n            for y in range(cardinality[1]):\n                cell_addr = x + cardinality[0] * y + cardinality[0] * cardinality[1] * z\n                raw_value = raw_cellset_as_dict[\"Cells\"][cell_addr][\"Value\"] or 0\n                if value_precision:\n                    row.append(float(value_format_string.format(raw_value)))\n                else:\n                    row.append(raw_value)\n            page.append(row)\n        cells[z_header] = page\n\n    return {\"titles\": titles, \"headers\": headers, \"cells\": cells}\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.build_url_friendly_object_name","title":"<code>build_url_friendly_object_name(object_name)</code>","text":"Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def build_url_friendly_object_name(object_name: str) -&gt; str:\n    return (\n        object_name.replace(\"'\", \"''\").replace(\"%\", \"%25\").replace(\"#\", \"%23\").replace(\"?\", \"%3F\").replace(\"&amp;\", \"%26\")\n    )\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.case_and_space_insensitive_equals","title":"<code>case_and_space_insensitive_equals(item1, item2)</code>","text":"Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def case_and_space_insensitive_equals(item1: str, item2: str) -&gt; bool:\n    return lower_and_drop_spaces(item1) == lower_and_drop_spaces(item2)\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.cell_is_updateable","title":"<code>cell_is_updateable(cell)</code>","text":"<p>Function checks if the cell can be updated</p> <p>Parameters:</p> Name Type Description Default <code>cell</code> <code>dict</code> <p>dict cell including Updateable property</p> required <p>Returns:</p> Type Description <code>bool</code> <p>bool</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def cell_is_updateable(cell: dict) -&gt; bool:\n    \"\"\"Function checks if the cell can be updated\n    :param cell: dict cell including Updateable property\n    :return: bool\n    \"\"\"\n    if \"Updateable\" not in cell:\n        raise ValueError(\"cell dictionary must contain key 'Updateable'\")\n\n    bit = extract_cell_updateable_property(cell[\"Updateable\"], CellUpdateableProperty.CELL_IS_NOT_UPDATEABLE)\n    updateable = not bit\n    return updateable\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.create_server_on_adminhost","title":"<code>create_server_on_adminhost(adminhost='localhost', server_as_dict=None)</code>","text":"Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def create_server_on_adminhost(adminhost: str = \"localhost\", server_as_dict: Dict = None):\n    from TM1py.Objects import Server\n\n    \"\"\"  Create new TM1 instance on Adminhost\n    :param adminhost: IP or DNS Alias of the adminhost\n    :param server_as_dict: \n            server_as_dict = {\n                \"Name\":\"MyModel1\",\n                \"IPAddress\":\"172.20.10.10\",\n                \"IPv6Address\":None,\n                \"PortNumber\":12345,\n                \"UsingSSL\": True,\n                \"ClientMessagePortNumber\":61098,\n                \"HTTPPortNumber\":12999,\n                \"ClientExportSSLSvrCert\":True,\n                \"ClientExportSSLSvrKeyID\":\"whateverExportSSLSvrKeyID\",\n                \"AcceptingClients\":True }\n    :return: instance of TM1py.Server\n    \"\"\"\n\n    if not server_as_dict:\n        raise ValueError(\"server_as_dict must be provided\")\n\n    if not adminhost:\n        adminhost = \"localhost\"\n\n    url = f\"http://{adminhost}:5895/Servers\"\n    response = requests.post(url, data=json.dumps(server_as_dict), headers={\"Content-Type\": \"application/json\"})\n    response.raise_for_status()\n\n    return Server(response.json())\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.decohints","title":"<code>decohints(decorator)</code>","text":"<p>Decorator for decorators to see parameters of decorated functions in PyCharm</p> <p>Implementation of https://github.com/gri-gus/decohints</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def decohints(decorator: Callable) -&gt; Callable:\n    \"\"\"\n    Decorator for decorators to see parameters of decorated functions in PyCharm\n\n    Implementation of https://github.com/gri-gus/decohints\n    \"\"\"\n    return decorator\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.delete_server_on_adminhost","title":"<code>delete_server_on_adminhost(adminhost=None, server_name=None)</code>","text":"Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def delete_server_on_adminhost(adminhost: str = None, server_name: str = None):\n    if not server_name:\n        raise ValueError(\"server_name must be provided\")\n\n    if not adminhost:\n        adminhost = \"localhost\"\n\n    url = f\"http://{adminhost}:5895/Servers('{server_name}')\"\n    response = requests.delete(url, headers={\"Content-Type\": \"application/json\"})\n    response.raise_for_status()\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.deprecated_in_version","title":"<code>deprecated_in_version(version)</code>","text":"<p>Higher order function to check required version for TM1py function</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>@decohints\ndef deprecated_in_version(version):\n    \"\"\"Higher order function to check required version for TM1py function\"\"\"\n\n    def wrap(func):\n        @functools.wraps(func)\n        def wrapper(self, *args, **kwargs):\n            if verify_version(required_version=version, version=self.version):\n                raise TM1pyVersionDeprecationException(func.__name__, version)\n            return func(self, *args, **kwargs)\n\n        return wrapper\n\n    return wrap\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.dimension_hierarchy_element_tuple_from_unique_name","title":"<code>dimension_hierarchy_element_tuple_from_unique_name(element_unique_name)</code>","text":"<p>Extract dimension name, hierarchy name and element name from element unique name. Works with explicit and implicit hierarchy references.</p> <p>Parameters:</p> Name Type Description Default <code>element_unique_name</code> <code>str</code> <p>e.g. [d1].[e1] or [d1].[leaves].[e1]</p> required <p>Returns:</p> Type Description <code>Tuple[str, str, str]</code> <p>tuple of dimension name, hierarchy name, element name</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def dimension_hierarchy_element_tuple_from_unique_name(element_unique_name: str) -&gt; Tuple[str, str, str]:\n    \"\"\"Extract dimension name, hierarchy name and element name from element unique name.\n    Works with explicit and implicit hierarchy references.\n    :param element_unique_name: e.g. [d1].[e1] or [d1].[leaves].[e1]\n    :return: tuple of dimension name, hierarchy name, element name\n    \"\"\"\n    dimension = dimension_name_from_element_unique_name(element_unique_name)\n    element = element_name_from_element_unique_name(element_unique_name)\n    if element_unique_name.count(\"].[\") == 1:\n        return dimension, dimension, element\n    hierarchy = hierarchy_name_from_element_unique_name(element_unique_name)\n    return dimension, hierarchy, element\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.dimension_name_from_element_unique_name","title":"<code>dimension_name_from_element_unique_name(element_unique_name)</code>","text":"Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def dimension_name_from_element_unique_name(element_unique_name: str) -&gt; str:\n    return element_unique_name[1 : element_unique_name.find(\"].[\")]\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.dimension_names_from_element_unique_names","title":"<code>dimension_names_from_element_unique_names(element_unique_names)</code>","text":"<p>Get tuple of simple element names from the full element unique names</p> <p>Parameters:</p> Name Type Description Default <code>element_unique_names</code> <code>Iterable[str]</code> <p>tuple of element unique names ([dim1].[hier1].[elem1], ... )</p> required <p>Returns:</p> Type Description <code>Tuple[str]</code> <p>tuple of element names: (elem1, elem2, ... )</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def dimension_names_from_element_unique_names(element_unique_names: Iterable[str]) -&gt; Tuple[str]:\n    \"\"\"Get tuple of simple element names from the full element unique names\n    :param element_unique_names: tuple of element unique names ([dim1].[hier1].[elem1], ... )\n    :return: tuple of element names: (elem1, elem2, ... )\n    \"\"\"\n    return tuple(dimension_name_from_element_unique_name(unique_name) for unique_name in element_unique_names)\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.drop_dimension_properties","title":"<code>drop_dimension_properties(mdx)</code>","text":"Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def drop_dimension_properties(mdx: str):\n    pattern = re.compile(r\"(?i)DIMENSION\\s+PROPERTIES\\s+.*?\\s+ON\")\n    mdx = pattern.sub(\" ON\", mdx)\n\n    pattern = re.compile(r\"(?i)\\s+PROPERTIES\\s+.*?\\s+ON\")\n    return pattern.sub(\" ON\", mdx)\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.element_name_from_element_unique_name","title":"<code>element_name_from_element_unique_name(element_unique_name)</code>","text":"Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def element_name_from_element_unique_name(element_unique_name: str) -&gt; str:\n    return element_unique_name[element_unique_name.rfind(\"].[\") + 3 : -1].replace(\"]]\", \"]\")\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.element_names_from_element_unique_names","title":"<code>element_names_from_element_unique_names(element_unique_names)</code>","text":"<p>Get tuple of simple element names from the full element unique names</p> <p>Parameters:</p> Name Type Description Default <code>element_unique_names</code> <code>Iterable[str]</code> <p>tuple of element unique names ([dim1].[hier1].[elem1], ... )</p> required <p>Returns:</p> Type Description <code>Tuple[str]</code> <p>tuple of element names: (elem1, elem2, ... )</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def element_names_from_element_unique_names(element_unique_names: Iterable[str]) -&gt; Tuple[str]:\n    \"\"\"Get tuple of simple element names from the full element unique names\n    :param element_unique_names: tuple of element unique names ([dim1].[hier1].[elem1], ... )\n    :return: tuple of element names: (elem1, elem2, ... )\n    \"\"\"\n    return tuple(element_name_from_element_unique_name(unique_name) for unique_name in element_unique_names)\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.extract_axes_from_cellset","title":"<code>extract_axes_from_cellset(raw_cellset_as_dict)</code>","text":"Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def extract_axes_from_cellset(raw_cellset_as_dict: Dict) -&gt; Tuple[Any, ...]:\n    raw_axes = raw_cellset_as_dict[\"Axes\"]\n\n    axes = list()\n\n    for axis in raw_axes:\n        if axis and \"Tuples\" in axis and len(axis[\"Tuples\"]) &gt; 0:\n            axes.append(axis)\n\n    return tuple(axes)\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.extract_cell_properties_from_odata_context","title":"<code>extract_cell_properties_from_odata_context(context)</code>","text":"<p>Takes in an odata_context and returns a list of properties e.g   [Ordinal, Value, RuleDerived, ...]</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>str</code> <p>A valid odata_context returned when querying cells</p> required <p>Returns:</p> Type Description <code>List[str]</code> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def extract_cell_properties_from_odata_context(context: str) -&gt; List[str]:\n    \"\"\"Takes in an odata_context and returns a list of properties e.g\n      [Ordinal, Value, RuleDerived, ...]\n    :param context: A valid odata_context returned when querying cells\n    :return:\n    \"\"\"\n    pattern = re.compile(r\"\\$metadata#Cellsets\\(Cells\\(([A-Za-z,]+)\\)\\)/\\$entity\")\n    matches = pattern.match(context)\n    if not matches:\n        raise ValueError(\"Could not extract cell properties from odata context\")\n    cell_properties = matches.groups()[0].split(\",\")\n    return cell_properties\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.extract_cell_updateable_property","title":"<code>extract_cell_updateable_property(decimal_value, cell_property)</code>","text":"<p>Function converts passed decimal (integer) value to binary and extracts specified (cell_property) bit counting from the right. It will return TRUE if bit is set, and FALSE if bit is not set Each cell has 'Updateable' property - a decimal value, which needs to be converted to binary to get information about the cell</p> <p>Parameters:</p> Name Type Description Default <code>decimal_value</code> <code>int</code> <p>int Decimal number</p> required <code>cell_property</code> <code>CellUpdateableProperty</code> <p>CellUpdateableProperty enum property to extract from decimal value</p> required <p>Returns:</p> Type Description <code>bool</code> <p>bool</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def extract_cell_updateable_property(decimal_value: int, cell_property: CellUpdateableProperty) -&gt; bool:\n    \"\"\"Function converts passed decimal (integer) value to binary\n    and extracts specified (cell_property) bit counting from the right.\n    It will return TRUE if bit is set, and FALSE if bit is not set\n    Each cell has 'Updateable' property - a decimal value, which needs to be converted to binary to get information\n    about the cell\n\n    :param decimal_value: int Decimal number\n    :param cell_property: CellUpdateableProperty enum property to extract from decimal value\n    :return: bool\n\n    \"\"\"\n    bit = (decimal_value &amp; (1 &lt;&lt; cell_property.value - 1)) != 0\n    return bit\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.extract_compact_json_cellset","title":"<code>extract_compact_json_cellset(context, response, return_as_dict)</code>","text":"<p>Translates odata compact response json into default dictionary response or plain list (e.g., list of values)</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>str</code> <p>The context field from the TM1 response JSON</p> required <code>response</code> <code>Dict</code> <p>The JSON response</p> required <code>return_as_dict</code> <code>bool</code> <p>boolean</p> required <p>Returns:</p> Type Description <code>Union[Dict, List]</code> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def extract_compact_json_cellset(context: str, response: Dict, return_as_dict: bool) -&gt; Union[Dict, List]:\n    \"\"\"Translates odata compact response json into default dictionary response or plain list (e.g., list of values)\n\n    :param context: The context field from the TM1 response JSON\n    :param response: The JSON response\n    :param return_as_dict: boolean\n    :return:\n    \"\"\"\n    props = extract_cell_properties_from_odata_context(context)\n\n    # First element [0] is the cellset ID, second is the cellset data\n    cells_data = response[\"value\"][1]\n\n    # return props with data if required\n    if return_as_dict:\n        return map_cell_properties_to_compact_json_response(props, cells_data)\n\n    if len(props) == 1:\n        return [value[0] for value in cells_data]\n\n    if props == [\"Ordinal\", \"Value\"]:\n        return [value[1] for value in cells_data]\n\n    return cells_data\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.extract_element_names_from_members","title":"<code>extract_element_names_from_members(members)</code>","text":"<p>Extract list of unique names from part of the cellset response in: [{'UniqueName': '[dim1].[dim1].[elem1]', 'Element': {'UniqueName': '[dim1].[dim1].[elem1]'}}, {'UniqueName': '[dim2].[dim2].[elem3]', 'Element': {'UniqueName': '[dim2].[dim2].[elem3]'}}] out: [\"elem1\", \"elem3\"]</p> <p>Parameters:</p> Name Type Description Default <code>members</code> <code>Iterable[Dict]</code> <p>dictionary</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>list of unique names</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def extract_element_names_from_members(members: Iterable[Dict]) -&gt; List[str]:\n    \"\"\"Extract list of unique names from part of the cellset response\n    in:\n    [{'UniqueName': '[dim1].[dim1].[elem1]', 'Element': {'UniqueName': '[dim1].[dim1].[elem1]'}},\n    {'UniqueName': '[dim2].[dim2].[elem3]', 'Element': {'UniqueName': '[dim2].[dim2].[elem3]'}}]\n    out:\n    [\"elem1\", \"elem3\"]\n    :param members: dictionary\n    :return: list of unique names\n    \"\"\"\n    return [m[\"Element\"][\"Name\"] if \"Element\" in m and m[\"Element\"] else m[\"Name\"] for m in members]\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.extract_unique_names_from_members","title":"<code>extract_unique_names_from_members(members)</code>","text":"<p>Extract list of unique names from part of the cellset response in: [{'UniqueName': '[dim1].[dim1].[elem1]', 'Element': {'UniqueName': '[dim1].[dim1].[elem1]'}}, {'UniqueName': '[dim2].[dim2].[elem3]', 'Element': {'UniqueName': '[dim2].[dim2].[elem3]'}}] out: [\"[dim1].[dim1].[elem1]\", \"[dim2].[dim2].[elem3]\"]</p> <p>Parameters:</p> Name Type Description Default <code>members</code> <code>Iterable[Dict]</code> <p>dictionary</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>list of unique names</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def extract_unique_names_from_members(members: Iterable[Dict]) -&gt; List[str]:\n    \"\"\"Extract list of unique names from part of the cellset response\n    in:\n    [{'UniqueName': '[dim1].[dim1].[elem1]', 'Element': {'UniqueName': '[dim1].[dim1].[elem1]'}},\n    {'UniqueName': '[dim2].[dim2].[elem3]', 'Element': {'UniqueName': '[dim2].[dim2].[elem3]'}}]\n    out:\n    [\"[dim1].[dim1].[elem1]\", \"[dim2].[dim2].[elem3]\"]\n    :param members: dictionary\n    :return: list of unique names\n    \"\"\"\n    return [m[\"Element\"][\"UniqueName\"] if \"Element\" in m and m[\"Element\"] else m[\"UniqueName\"] for m in members]\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.format_url","title":"<code>format_url(url, *args, **kwargs)</code>","text":"<p>build url and escape single quotes in args and kwargs</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <p>url with {} placeholders</p> required <code>args</code> <code>str</code> <p>arguments to placeholders</p> <code>()</code> <p>Returns:</p> Type Description <code>str</code> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def format_url(url, *args: str, **kwargs: str) -&gt; str:\n    \"\"\"build url and escape single quotes in args and kwargs\n    :param url: url with {} placeholders\n    :param args: arguments to placeholders\n    :return:\n    \"\"\"\n    args = [build_url_friendly_object_name(arg) if isinstance(arg, str) else arg for arg in args]\n\n    kwargs = {\n        key: build_url_friendly_object_name(value) if isinstance(value, str) else value for key, value in kwargs.items()\n    }\n\n    return url.format(*args, **kwargs)\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.frame_to_significant_digits","title":"<code>frame_to_significant_digits(x, digits=15)</code>","text":"Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def frame_to_significant_digits(x, digits=15):\n    if x == 0 or not math.isfinite(x):\n        return str(x).replace(\"e+\", \"E\")\n    digits -= math.ceil(math.log10(abs(x)))\n    return str(round(x, digits)).replace(\"e+\", \"E\")\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.get_all_servers_from_adminhost","title":"<code>get_all_servers_from_adminhost(adminhost='localhost', port=None, use_ssl=False)</code>","text":"Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def get_all_servers_from_adminhost(adminhost=\"localhost\", port=None, use_ssl=False) -&gt; List:\n    from TM1py.Objects import Server\n\n    \"\"\" Ask Adminhost for TM1 Servers\n    :param adminhost: IP or DNS Alias of the adminhost\n    :param port: numeric port to connect to adminhost\n    :param ssl: True for secure connection\n    :return: List of Servers (instances of the TM1py.Server class)\n    \"\"\"\n\n    if not use_ssl:\n        conn = http_client.HTTPConnection(adminhost, port or 5895)\n    else:\n        conn = http_client.HTTPSConnection(adminhost, port or 5898, context=ssl._create_unverified_context())\n    request = \"/api/v1/Servers\"\n    conn.request(\"GET\", request, body=\"\")\n    response = conn.getresponse().read().decode(\"utf-8\")\n    response_as_dict = json.loads(response)\n    servers = []\n    for server_as_dict in response_as_dict[\"value\"]:\n        server = Server(server_as_dict)\n        servers.append(server)\n    return servers\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.get_cube","title":"<code>get_cube(mdx)</code>","text":"Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def get_cube(mdx: str) -&gt; str:\n    # replace tabs, line breaks, spaces\n    mdx = re.sub(r\"\\s+\", \"\", mdx)\n\n    # happy case: cube name in square brackets\n    pattern = r\"(?s)(?i)FROM\\[(.*?)\\]\"\n    search_result = re.search(pattern, mdx)\n    if search_result:\n        return search_result.group(1)\n\n    # cut off where\n    pattern = r\"(?s)(?i).*SELECT.*ON.*FROM.*WHERE\\(.*\"\n    if re.search(pattern=pattern, string=mdx):\n        # part before where\n        mdx = re.split(r\"(?s)(?i)WHERE\\(.*\", mdx)[0]\n\n    # part after from\n    cube = re.split(r\"(?s)(?i)FROM\", mdx)[-1]\n\n    return cube\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.get_dimensions_from_where_clause","title":"<code>get_dimensions_from_where_clause(mdx)</code>","text":"Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def get_dimensions_from_where_clause(mdx: str) -&gt; List[str]:\n    mdx = mdx.replace(\" \", \"\").upper()\n    if \"WHERE(\" not in mdx:\n        return []\n\n    where = mdx[mdx.rfind(\"WHERE(\") + 6 : -1]\n    unique_names = where.split(\",\")\n    return [dimension_name_from_element_unique_name(unique_name) for unique_name in unique_names]\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.get_seconds_from_duration","title":"<code>get_seconds_from_duration(time_str)</code>","text":"<p>This function will convert the TM1 time to seconds</p> <p>Parameters:</p> Name Type Description Default <code>time_str</code> <code>str</code> <p>P0DT00H01M43S</p> required <p>Returns:</p> Type Description <code>int</code> <p>int</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def get_seconds_from_duration(time_str: str) -&gt; int:\n    \"\"\"\n    This function will convert the TM1 time to seconds\n    :param time_str: P0DT00H01M43S\n    :return: int\n    \"\"\"\n    import re\n\n    pattern = re.compile(r\"\\w(\\d+)\\w\\w(\\d+)\\w(\\d+)\\w(\\d+)\\w\")\n    matches = pattern.search(time_str)\n    d, h, m, s = matches.groups()\n    seconds = (int(d) * 86400) + (int(h) * 3600) + (int(m) * 60) + int(s)\n    return seconds\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.get_tm1_time_value_now","title":"<code>get_tm1_time_value_now(use_excel_serial_date=False)</code>","text":"<p>This function can be used to replicate TM1's NOW function to return current date/time value in serial number format.</p> <p>Parameters:</p> Name Type Description Default <code>use_excel_serial_date</code> <code>bool</code> <p>Boolean</p> <code>False</code> <p>Returns:</p> Type Description <code>float</code> <p>serial number</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def get_tm1_time_value_now(use_excel_serial_date: bool = False) -&gt; float:\n    \"\"\"\n    This function can be used to replicate TM1's NOW function\n    to return current date/time value in serial number format.\n    :param use_excel_serial_date: Boolean\n    :return: serial number\n    \"\"\"\n    from datetime import datetime\n\n    # timestamp according to tm1\n    start_datetime = datetime(1899, 12, 30) if use_excel_serial_date else datetime(1960, 1, 1)\n    current_datetime = datetime.now()\n    delta = current_datetime - start_datetime\n    return delta.days + (delta.seconds / 86400)\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.hierarchy_name_from_element_unique_name","title":"<code>hierarchy_name_from_element_unique_name(element_unique_name)</code>","text":"Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def hierarchy_name_from_element_unique_name(element_unique_name: str) -&gt; str:\n    return element_unique_name[element_unique_name.find(\"].[\") + 3 : element_unique_name.rfind(\"].[\")]\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.integerize_version","title":"<code>integerize_version(version, precision=4)</code>","text":"Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def integerize_version(version: str, precision: int = 4) -&gt; int:\n    return int(version[:precision].replace(\".\", \"\").ljust(precision, \"0\"))\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.lower_and_drop_spaces","title":"<code>lower_and_drop_spaces(item)</code>","text":"Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def lower_and_drop_spaces(item: str) -&gt; str:\n    return item.replace(\" \", \"\").lower()\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.map_cell_properties_to_compact_json_response","title":"<code>map_cell_properties_to_compact_json_response(properties, compact_cells_response)</code>","text":"<p>Map cell properties to compact json response e.g properties = [Ordinal, Value, RuleDerived] compact_cells_response = [[0, 258, 100], [1, 258, 500]] result: {Cells: [     { Ordinal: 0, Value: 100, RuleDerived: 258},     { Ordinal: 1, Value: 500, RuleDerived: 258} ]}</p> <p>Parameters:</p> Name Type Description Default <code>properties</code> <code>List</code> <p>list of <code>Cell</code> properties e.g [Ordinal, Value, Updateable, ...]</p> required <code>compact_cells_response</code> <code>List</code> <p>list of cells returned in compact json format</p> required <p>Returns:</p> Type Description <code>Dict</code> <p>dict with properties mapped to compact json response</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def map_cell_properties_to_compact_json_response(properties: List, compact_cells_response: List) -&gt; Dict:\n    \"\"\"Map cell properties to compact json response e.g\n    properties = [Ordinal, Value, RuleDerived]\n    compact_cells_response = [[0, 258, 100], [1, 258, 500]]\n    result: {Cells: [\n        { Ordinal: 0, Value: 100, RuleDerived: 258},\n        { Ordinal: 1, Value: 500, RuleDerived: 258}\n    ]}\n\n\n    :param properties: list of `Cell` properties e.g [Ordinal, Value, Updateable, ...]\n    :param compact_cells_response: list of cells returned in compact json format\n    :return: dict with properties mapped to compact json response\n    \"\"\"\n    cells_dict = dict()\n    cells = []\n    for cell in compact_cells_response:\n        d = dict()\n        for index, prop in enumerate(properties):\n            d[prop] = cell[index]\n        cells.append(d)\n    cells_dict[\"Cells\"] = cells\n    return cells_dict\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.odata_track_changes_header","title":"<code>odata_track_changes_header(func)</code>","text":"<p>Higher Order function to handle addition and removal of odata.track-changes HTTP Header</p> <p>Parameters:</p> Name Type Description Default <code>func</code> required <p>Returns:</p> Type Description Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>@decohints\ndef odata_track_changes_header(func):\n    \"\"\"Higher Order function to handle addition and removal of odata.track-changes HTTP Header\n\n    :param func:\n    :return:\n    \"\"\"\n\n    @functools.wraps(func)\n    def wrapper(self, *args, **kwargs):\n        # Add header\n        self._rest.add_http_header(\"Prefer\", \"odata.track-changes\")\n        # Do stuff\n        response = func(self, *args, **kwargs)\n        # Remove Header\n        self._rest.remove_http_header(\"Prefer\")\n        return response\n\n    return wrapper\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.read_object_name_from_url","title":"<code>read_object_name_from_url(url, pattern)</code>","text":"Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def read_object_name_from_url(url: str, pattern: str) -&gt; str:\n    match = re.match(pattern, url)\n    if not match:\n        return None\n\n    return unquote(match.group(1))\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.reorder_with_priority","title":"<code>reorder_with_priority(original_items, priority_items=None, exclude_items=None, sort_remaining=True, **kwargs)</code>","text":"<p>Reorder a list of original items so that items in 'priority_items' list appear first (in specified order), followed by the remaining items of original items. The order of the remaining items depends on the 'sort_remaining' parameter: if True, the original order is preserved; if False, the items are sorted alphabetically. Items in the 'exclude_items' list are omitted. Missing priority items and exclude items are ignored.</p> <p>Example case: hierarchy names \"correct\" order: first the main hierarchy name (matching the dimension name), then the Leaves hierarchy, then the other hierarchy names (sorted or not). When trying to create the Leaves hierarchy when it already exists (because of creating a different alternate hierarchy), an error pops up. Set exclude_items equal to ['Leaves'].</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def reorder_with_priority(\n    original_items: List[Any],\n    priority_items: List[Any] = None,\n    exclude_items: List[Any] = None,\n    sort_remaining: bool = True,\n    **kwargs,\n) -&gt; List[Any]:\n    \"\"\"\n    Reorder a list of original items so that items in 'priority_items' list appear first (in specified order),\n    followed by the remaining items of original items. The order of the remaining items depends on the\n    'sort_remaining' parameter: if True, the original order is preserved; if False, the items\n    are sorted alphabetically. Items in the 'exclude_items' list are omitted. Missing priority items\n    and exclude items are ignored.\n\n    Example case: hierarchy names\n    \"correct\" order: first the main hierarchy name (matching the dimension name),\n    then the Leaves hierarchy, then the other hierarchy names (sorted or not).\n    When trying to create the Leaves hierarchy when it already exists (because of creating a different alternate hierarchy),\n    an error pops up. Set exclude_items equal to ['Leaves'].\n    \"\"\"\n    result = [s for s in priority_items if s in original_items]\n    remaining = [s for s in original_items if (s not in result) and (s not in exclude_items)]\n    result += sorted(remaining) if sort_remaining else remaining\n    return result\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.require_admin","title":"<code>require_admin(func)</code>","text":"Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>@decohints\ndef require_admin(func):\n    @functools.wraps(func)\n    def wrapper(self, *args, **kwargs):\n        if not self.is_admin:\n            raise TM1pyNotAdminException(func.__name__)\n        return func(self, *args, **kwargs)\n\n    return wrapper\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.require_data_admin","title":"<code>require_data_admin(func)</code>","text":"Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>@decohints\ndef require_data_admin(func):\n    @functools.wraps(func)\n    def wrapper(self, *args, **kwargs):\n        if not self.is_data_admin:\n            raise TM1pyNotDataAdminException(func.__name__)\n        return func(self, *args, **kwargs)\n\n    return wrapper\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.require_ops_admin","title":"<code>require_ops_admin(func)</code>","text":"Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>@decohints\ndef require_ops_admin(func):\n    @functools.wraps(func)\n    def wrapper(self, *args, **kwargs):\n        if not self.is_ops_admin:\n            raise TM1pyNotOpsAdminException(func.__name__)\n        return func(self, *args, **kwargs)\n\n    return wrapper\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.require_pandas","title":"<code>require_pandas(func)</code>","text":"Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>@decohints\ndef require_pandas(func):\n    @functools.wraps(func)\n    def wrapper(self, *args, **kwargs):\n        try:\n            import pandas  # noqa: F401\n\n            return func(self, *args, **kwargs)\n        except ImportError:\n            raise ImportError(f\"Function '{func.__name__}' requires pandas\")\n\n    return wrapper\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.require_security_admin","title":"<code>require_security_admin(func)</code>","text":"Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>@decohints\ndef require_security_admin(func):\n    @functools.wraps(func)\n    def wrapper(self, *args, **kwargs):\n        if not self.is_security_admin:\n            raise TM1pyNotSecurityAdminException(func.__name__)\n        return func(self, *args, **kwargs)\n\n    return wrapper\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.require_version","title":"<code>require_version(version)</code>","text":"<p>Higher order function to check required version for TM1py function</p> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>@decohints\ndef require_version(version):\n    \"\"\"Higher order function to check required version for TM1py function\"\"\"\n\n    def wrap(func):\n        @functools.wraps(func)\n        def wrapper(self, *args, **kwargs):\n            if not verify_version(required_version=version, version=self.version):\n                raise TM1pyVersionException(func.__name__, version)\n            return func(self, *args, **kwargs)\n\n        return wrapper\n\n    return wrap\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.resembles_mdx","title":"<code>resembles_mdx(mdx)</code>","text":"Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def resembles_mdx(mdx: str) -&gt; bool:\n    pattern = r\"(?s)(?i).*SELECT.*ON.*FROM.*\"\n    if re.search(pattern=pattern, string=mdx):\n        return True\n    return False\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.sort_coordinates","title":"<code>sort_coordinates(cube_dimensions, unsorted_coordinates, element_unique_names)</code>","text":"Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def sort_coordinates(\n    cube_dimensions: Iterable[str], unsorted_coordinates: Iterable[str], element_unique_names: True\n) -&gt; Tuple[str]:\n    sorted_coordinates = []\n    for dimension in cube_dimensions:\n        # could be more than one hierarchy!\n        address_elements = [item for item in unsorted_coordinates if item.startswith(\"[\" + dimension + \"].\")]\n        # address_elements could be ( [dim1].[hier1].[elem1], [dim1].[hier2].[elem3] )\n        for address_element in address_elements:\n            if element_unique_names:\n                coordinate = address_element\n            else:\n                coordinate = element_name_from_element_unique_name(address_element)\n            sorted_coordinates.append(coordinate)\n    return tuple(sorted_coordinates)\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.update_server_on_adminhost","title":"<code>update_server_on_adminhost(adminhost='localhost', server_as_dict=None)</code>","text":"Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def update_server_on_adminhost(adminhost: str = \"localhost\", server_as_dict: Dict = None):\n    from TM1py.Objects import Server\n\n    \"\"\"  Create new TM1 instance on Adminhost\n    :param adminhost: IP or DNS Alias of the adminhost\n    :param server_as_dict: \n            server_as_dict = {\n                \"Name\":\"MyModel1\",\n                \"IPAddress\":\"172.20.10.10\",\n                \"IPv6Address\":None,\n                \"PortNumber\":12345,\n                \"UsingSSL\": True,\n                \"ClientMessagePortNumber\":61098,\n                \"HTTPPortNumber\":12999,\n                \"ClientExportSSLSvrCert\":True,\n                \"ClientExportSSLSvrKeyID\":\"whateverExportSSLSvrKeyID\",\n                \"AcceptingClients\":True }\n    :return: instance of TM1py.Server\n    \"\"\"\n\n    if not server_as_dict:\n        raise ValueError(\"server_as_dict must be provided\")\n\n    if not adminhost:\n        adminhost = \"localhost\"\n\n    url = f\"http://{adminhost}:5895/Servers\"\n    response = requests.patch(url, body=json.dumps(server_as_dict), headers={\"Content-Type\": \"application/json\"})\n    response.raise_for_status()\n\n    return Server(response.json())\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.utc_localize_time","title":"<code>utc_localize_time(timestamp)</code>","text":"Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def utc_localize_time(timestamp):\n    timestamp = pytz.utc.localize(timestamp)\n    timestamp_utc = timestamp.astimezone(pytz.utc)\n    return timestamp_utc\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.verify_version","title":"<code>verify_version(required_version, version)</code>","text":"Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def verify_version(required_version: str, version: str) -&gt; bool:\n    expected = integerize_version(required_version, precision=len(required_version))\n    actual = integerize_version(version, precision=len(required_version))\n    return actual &gt;= expected\n</code></pre>"},{"location":"reference/utils/utils/#TM1py.Utils.Utils.wrap_in_curly_braces","title":"<code>wrap_in_curly_braces(expression)</code>","text":"<p>Put curly braces around a string</p> <p>Parameters:</p> Name Type Description Default <code>expression</code> <code>str</code> required <p>Returns:</p> Type Description <code>str</code> Source code in <code>TM1py/Utils/Utils.py</code> <pre><code>def wrap_in_curly_braces(expression: str) -&gt; str:\n    \"\"\"Put curly braces around a string\n    :param expression:\n    :return:\n    \"\"\"\n    return \"\".join(\n        [\"{\" if not expression.startswith(\"{\") else \"\", expression, \"}\" if not expression.endswith(\"}\") else \"\"]\n    )\n</code></pre>"}]}